WBigTitle(`More decorators')
Using the expressive power of programmatic refactoring many different decorators can be designed. Here we list and explain some of the most useful.

WTitle(`Public')
The Wcode(Public) decorator allows to 
select certain members as Wcode(Public), and to hide all the others: for any nested class containing at least one Wcode(Public) annotation, Wcode(Public) hides all the non Wcode(Public) annoted members.
WBR
Consider the following example:
OBCode
MyProgram = Public:{
  Person = Data:{
    @Public var S name
    var I age
    @Public class method mut This (S name, I age)
    @Public mut method Void birthDay() = this.age(\age+1I)
    }
  Car = Data:{
    capsule Person driver
    @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
CCode
Here we have a Wcode(Person) class with Wcode(name) and Wcode(age),
but we expose only the Wcode(name).
We also expose the method Wcode(birthDay), that can update the Wcode(age).
WBR
Wcode(Data) is generating a bunch of other methods, but we are not exposing them.
In order to make our Wcode(Person) class usable, we need to at least export a factory, as we do in line 5.
WBR
On the other side, consider Wcode(Car): since there is no Wcode(Public) annotation in Wcode(Car), no members are hidden.
Also, note how the Wcode(Car) invariant can normally refer to Wcode(Person.age()). This works because the Wcode(Public) decorator is applied outside of both Wcode(Person) and Wcode(Car). This is indeed a very common pattern: Wcode(Public) is often used high up in the nested tree, to allow for tightly connected classes to see each other privates when needed.
Using the outline IDE feature, we could see the following:
OBCode
  MyProgram={
    Car={
      [This2.HasToS]
      class method mut This #apply(capsule This1.Person driver)=(..)
      method This2.Bool #bangequal0(This that)=(..)
      method This2.Bool #equalequal0(This that)=(..)
      class method This #immK(This1.Person driver)=(..)
      mut method capsule This capsuleClone()=(..)
      read method This immClone()=(..)
      read method read This1.Person driver()=(..)
      @This2.Cache.Now read method Void drivingAge()native{..}=(..)
      class method Void drivingAge(read This1.Person driver)=(..)
      method This norm()=(..)
      read method This2.Bool readEquality(read This that)=(..)
      read method This2.S toS()=(..)
      method This with(This1.Person driver)=(..)
      }
    Person={
      [This2.HasToS]
      @This2.Public class method mut This #apply(This2.S name, This2.I age)=(..)
      @This2.Public mut method Void birthDay()=(..)
      @This2.Public read method This2.S name()=(..)
      @This2.Public mut method Void name(This2.S that)=(..)
      read method This2.S toS()=(..)
      }
    }
CCode
As you can see, Wcode(Car) exposes all of the methods generated by Wcode(Data), while Wcode(Person) exposes only a minimal interface.
WP
Alternativelly,
when we only wish to hide a few specific methods,
we could just specify the private members. To this aim, we need to specify in Wcode(Public) the path to use to indicate privatness. We could for example use Wcode(X), that loosely speaking represents a form of denial:

OBCode
MyProgram = Public(private=\(X)):{
  Person = Data:{ /*..as before..*/}
  Car = Data:{
    capsule Person driver
    @X @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
CCode
The code above hides the Wcode(Car) invariant; this of course means that the invariant is still enforced, but methods Wcode(drivingAge()) nor Wcode(drivingAge(driver)) are not polluting the interface of Wcode(Car) any more.
WP
Finally, Wcode(Public) is closing all the nested classes;
this means that the fields and constructors are not any more abstract methods but implemented methods delegating  to hidden ones.
A close class encapsulate its state, but can be reused in less flexible ways: the code of two closed classes can not be merged with trait operators Wcode(+) and Wcode(:).

WTitle(`Organize')

With metaprogramming, often we have to create code in a certain order,
and this order may be in contrast with the final structure we want to create.
For example, we may want to have an interface whose nested classes implements such interface.
However, the following code:
OBCode
I = {interface
  method Void foo()
  A= Data:{[I] foo()=void}
  }
CCode
Would not work: we can not apply Data on Wcode({[I] foo()=void}) since Wcode(I) it is not compiled yet.

We could use rename and write
OBCode
I = Class:Trait({
  Top = {interface method Void foo() }
  A= Data:{[Top] foo()=void}
  })['Top=>'This]
CCode
That is, first we create a bunch of nested classes, and then we organize the result by renaming to obtain the desired shape.
This common pattern is automated by the decorator Wcode(Organize)
performing a standard pattern of renames:
WBR
Names containing the special Wcode($) character are renamed in names where Wcode($) is replaced with a Wcode(.) or just removed; for example Wcode(A$B$C) is renamed in Wcode(A.B.C),
Wcode(A$) is renamed in Wcode(A) and Wcode($) is renamed into Wcode(This).

Thus, we could rewrite the code above as
OBCode
I = Organize:{
  $ = {interface method Void foo() }
  A= Data:{[$] foo()=void}
  }
CCode
WP

In metaprogramming systems, code generation needs to proceed in a specific order. This sometimes creates difficoult situations.
For example, the following naive implementation of a Wcode(Person) with a map of friends to locations would not work:

OBCode
Point = Data:{ Num x, Num y }
Person = Data:{ Map friends }
Map = Collection.map(key=Person, val=Point)
CCode
Wcode(Map) can not be generated, since Wcode(Person) is untypable until Wcode(Map) is generated.
WBR
We can circumvents 
those limitations with Wcode(Organize) by writing:
OBCode
MyCode = Organize:{
  Point = Data:{ Num x, Num y }
  Person$ = {}
  Map = Collection.map(key=Person$, val=Point)
  Person = Data:{ Map friends }
  }
CCode

Wcode(Organize) is also very useful to avoid redeclaring 
abstract methods when extending code.
This sometimes requires to use Wterm(late typing), usually by introducing an extra nested class that will only be used
as a dependency.

One such case happend while designing a little 42 videogame; where we encountered the setting below:
We have Wcode(NPC) following each others in a Wcode(Map).
As for the example above, the map is going to have specialized location aware operations.
The Wcode(NPC) knows about the Wcode(Map), the Wcode(Map) values are Wcode(NPCs).
Moreover, we do not just reuse a Wcode(Collection.map) but we add new operations to it.

OBCode
Point = Data:{I x, I y}
Game = Organize:{
  NPC$ = {}
  Map$ = Collection.map(key=Point, val=NPC$)
  NPC = Data:{
    var Point location
    var I lifePoints
    var mut This target
    mut method Void step(mut Map$ map) = /*lots of code*/
    }
  Map = {
    mut method Void add(mut NPC that) = this.#put(key=that.location(), val=that)
    mut method Void remove(mut NPC that) = this.remove(key=that.location())
    mut method Void move(mut NPC that,Point to) = (
      this.remove(that)
      that.location(to)
      this.add(that)
      )
    mut method mut NPC get(Point that) =
      (this<:mut @Late Map$).#val(key=that).#val()
    mut method Void stepAll() =
      for (mut val) in this<:mut Map$
        (val<:mut NPC).step(map=this)
    }
  }
Late = {}
CCode
The former code declares both Wcode(NPC) and Wcode(NPC$), and both Wcode(Map) and Wcode(Map$).
They will be merged by Wcode(Organize) but are still separated inside the code library, before Wcode(Organize) can act.
This is relevant when type inference is required.
For example, method Wcode(Map.get(that))
can not be simply implemented as
Wcode(this.#val(key=that).#val())
since there is no method Wcode(#val(key)) in Wcode(Map); such method is presented in Wcode(Map$).
The solution is to add an up-cast to Wcode(Map$).
However, if this code was typed before Wcode(Organize) could
run, such a cast would not typecheck, since Wcode(Map$) is not Wcode(Map).
We can easly delay the type checking by adding an annotation:
Wcode(this<:mut @Late Map$)
casts Wcode(this) to Wcode(mut Map$) only when also nested class Wcode(Late) can be typed. Since Wcode(Late) is declared after Wcode(Game), this is happening after Wcode(Organize) has been applied.
Alternatively, we could use a local variable declaration and write the following:
OBCode
mut method mut NPC get(Point that) = (
  mut @Late Map$ self=this
  self.#val(key=that).#val()
  )
CCode
WBR
Also method Wcode(stepAll()) requires upcasting; however we do not need to repeat the Wcode(Late) annotation since type dependencies are class-wide: a single Wcode(Late) annotation anywhere in any method covers all the methods of the same class (but not the methods in nested classes).


WTitle(`Data.**')
The Wcode(Data) decorator contains many useful nested classes, that can be used as independent decorators.
Wcode(Data.AddConstructors) applies an heuristic to decide what are the field of a class and add appropriate constructors. (autoNorm forces the imm state? no? I'm testing it right now.)
Wcode(Data.Close) 
 Close also close have Name and autoNorm
 Wither
Defaults

 Relax

 AddList
 AddOpt
 AddSet


WTitle(`Decorator')
The Wcode(Decorator) decorator 

the decorator decorator
//mention example Alphanumeric/Enum as Decorator:

Make your own decorators: when is it good?

summary



MultiConcrete5 = Class:Trait({
  $ = Class.Relax:MultiLevel[ 'A->'SuperA; 'C.D.space()->'C.D.superSpace() ]
  A = {
    class method S hi() = S"[%$.SuperA.hi()]"
    B = {class method S world() = S"[%$.SuperA.B.world()]"}
    }
  C={ D={ class method S space()=S"[%$.C.D.superSpace()]" } }
  })['$=>'This]
  
Main8 = MultiConcrete5.C.print() //now prints "[hi][ ][world]"
  
Concrete3 = Class:Code1['C.m()->'C.superM()]
  : {C={method S superM() method S m()=this.superM()++S"!" } }
Main3 = (
  Debug(Concrete3.D().callBoth())
  )


Operator Wcode(:) merges multiple units of code together; but sometime code needs some kind of adaptation before it can be merged

Note that Wcode(traitEnsureTransaction()) is just a normal 
class method that directly returns a library literal.
Traits in 42 are nothing fancier than that.

Now Wcode(MyAction) will execute the operation inside of a transaction.

However, as you can see declaring Wcode(MyAction) using 
Wcode(Refactor.compose) is verbose,
and we need to know the code of Wcode(traitEnsureTransaction())
to use it;
we now show how to improve.
WP

Manually declaring a class just to define a single trait method
returning a library literal is verbose.
In AdamsTowel we can use the class Wcode(Resource)
which automate this process.
WBR
For example: 
OBCode
TraitEnsureTransaction: Resource <>< {
  class method
  Void (mut Db.Connection connection) //method selector here is '(connection)'
  exception Db.Query.Failure 

  class method
  Void (mut Db.Connection that) //method selector here is '(that)'
  exception Db.Query.Failure (/*..as before..*/)
  }

MyAction: Refactor.compose(
  left: TraitEnsureTransaction()
  right: { /*..as before..*/})
CCode

This let us save just a couple of lines. 
We can improve further and make a Wcode(Transaction)
class decorator: 

OBCode
Transaction: {
  InvalidAction: Message.$ <>< {implements MetaGuard}
  //meta guard is the root of all the metaprogramming guards
  class method //using <>< to define the babelfish operator
  Library <>< (Library that) 
  exception InvalidAction {
    i= Introspection(lib: that)
    if !i.hasMethod(\"(connection)") (exception InvalidAction
      "Action method '(connection)' missing")
    composed= Refactor.compose(  left: TraitEnsureTransaction(), right: that  )
    exception on MetaGuard ( InvalidAction
      "Action invalid: type of '(connection)' does not fit or already defined '(that)'")
    return Refactor.HideSelector(\"(connection)") <>< composed
    error on Metaguard
      X"'(connection)' is there, ready to be hidden"
    }  
  }
//So, MyAction becomes shorter and better checked: 
MyAction: Transaction <>< {
  class method
  Void(mut Db.Connection connection)
  exception Db.Query.Failure {
    /*..my operation..*/
    }
  }
CCode

Note how we check some well formedness of the parameter
in an Wcode(if), then we catch and wrap the exceptions of Wcode(compose(left,right)),
and finally we state our assumption that Wcode(HideSelector) can not fail in
that context.

Now we can use Wcode(Transaction) as a decorator.


WTitle((3/5)Extend)

Wcode(Extend)
 is a decorator implemented using 
Wcode(Refactor) and
Wcode(Introspection)
which provides a flexible model of multiple inheritance with super calls in AdamsTowel.
WBR
As an example, in a game we can have a chest which contains objects in certain positions,
a boat which host humanoids, and
a cargo boat, which host humanoids and contains objects like a chest.
We want to reuse the code of chest and boat to obtain the cargo boat.
WBR 
For example: 
OBCode
ChestTrait: Resource <>< {
  mut Objects objects
  /*.. methods to validate access to objects..*/
  read method
  Kg weight() {
    var Kg res= 0Kg
    with o in this.objects().vals() (res+= o.weight() )
    return res
    }
  }

BoatTrait: Resource <>< {
  mut Humanoids crew
  Kg maxCapacity
  /*.. methods to validate access to crew..*/
  read method
  Kg weight() {/*..with-loop on the crew..*/}
  
  read method
  Kg capacityLeft()
    this.maxCapacity()-this.weight()    
  }

Chest: Data <>< ChestTrait()
Boat: Data <>< BoatTrait()
CargoBoat: Data <>< Extend[ChestTrait();BoatTrait()] <>< {
  read method @override //explained below
  Kg weight() this.#1weight()+this.#2weight()
  }
CCode

As you see, we annotate with Wcode(@override) to 
override the Wcode(weight()) method, and we use 
Wcode(`#'1weight()) and 
Wcode(`#'2weight()) to refer to the super implementations.
As an alternative to Wcode(@override),
we could use Wcode(@hide) to just hide the old methods and put our new
version on top. There are two main difference between Wcode(@override) and 
Wcode(@hide).
With override internal references will refer to the new implementation,
while with hide they will refer to the old one.
With override the method type must be identical,
while with hide they can be completely different.


WTitle((4/5)An intolerant type system)

As an exercise, lets try to use what we learned to add a Wcode(sum()) method to
a vector.

OBCode
Nums: Extends[Collections.vector(of: Num)] <>< {
  read method
  Num sum(){
    var Num res= 0Num
    with n in this.vals() (res+= n )
    return res
    }
  }
CCode

Easy.
However, note that we are calling Wcode(this.vals()) to
do the iteration, and we are not declaring a Wcode(vals())
method.
The idea is that while computing Wcode(Nums), the type system is temporary allowing for incomplete/untypable code at the right of the Wcode(:).
The typesystem will check that all is ok when the declaration of Wcode(Nums) is complete.
WP
However, we have done an extension only on our specific Wcode(Nums) vector, we would have to repeat
such code for each vector.
Can we directly produce vectors that will have a Wcode(sum()) method?
Well, this can only work for vectors of elements with a Wcode(+) operator, and a zero concept. Luckily, all 
numeric classes offer a Wcode(zero()) 
and Wcode(one()) method.
WBR
Building on that, we could attempt the following, invalid solution: 
OBCode
MyCollection: {
  class method
  Library traitSum()
    { //my sum feature
    T: {
      class method T zero()
      method T +(T that)
      }
    read method
    Num sum(){
      var T res= T.zero()
      with n in this.vals() (res+= n ) //error here, vals() undefined
      return res
      }
    }
  class method
  Library vector(class Any of) {
    oldPart= Collections.vector(of: of)
    newPart= Refactor.Redirect(Path"T" to: of) <>< this.traitSum()
    return Refactor.compose(left: oldPart, right: newPart)
    }
CCode

Conceptually, we define a new trait for the sum method,
and we make it general introducing Wcode(T) and our
needed requirements.
Sadly, this is not going to compile, since 
in the method Wcode(sum()) we call Wcode(this.vals()),
and there is no definition for such method.
Similar code worked in the former example, but here
the definition of Wcode(MyCollection) gets completed,
and the code in the method Wcode(traitSum()) is still 
incomplete.
We could just repeat there the definition of Wcode(vals()),
but that would be duplicating code; moreover, Wcode(vals()) returns an iterator, which has methods too...
WP

Wcode(Collection) offers a solution: a trait containing
the minimal code skeleton to make Wcode(vals()) over path 
Wcode(T).
WBR
The idea is that
the composition of Wcode(traitSum()) and
Wcode(Collections.traitValsT()) is complete code.
However, even declaring Wcode(traitSum()) as
OBCode
class method
Library traitSum() 
  Extend[Collections.traitValsT()] <>< {/*my sum feature as before*/}
CCode

whould not work: the Wcode(<><) method would
be called when Wcode(traitSum()) runs, leaving incomplete code in the resulting library literal.
We need to force the computation to happen before
Wcode(MyColleciton) is completed.
A solution is to use Wcode(Resource).

OBCode
TraitSum: Resource <>< Extend[Collections.traitValsT()] <>< {/*my sum feature as before*/}
MyCollection: {
  class method
  Library vector(class Any of) (
    oldPart= Collections.vector(of: of) //surely works
    {newPart= Refactor.Redirect(Path"T" to: of) <>< TraitSum()
    return Extend[oldPart] <>< newPart
    catch exception MetaGuard g return oldPart
    })
CCode

By the way, earlier we also forgot to handle exceptions!
If our parameter does not support zero and plus,
we will just return a normal collection. We need to insert additional brackets otherwise the 
binding Wcode(oldPart) would not be visible in the catch body.

As you may notice there is some incoherence in our programming style: 
should traits be methods in a class or Resources?
should we use 
the more primitive
Wcode(Refactor.compose(left,right))
or the more flexible Wcode(Extend[] <><)?
In the current state of the art we do not have an answer for what is the best in 42.
WBR
Indeed, we still do not understand the question.







WTitle((1/5)Refactor and Introspection)

WTitle(Refactor)
Wcode(Refactor) is a class supporting modification of
library literals.
For example, you may want to rename the method Wcode(importStructure(that)) into just Wcode(import(that)).
You can do the following: 
OBCode
{reuse L42.is/AdamsTowel
Db: Refactor.RenameSelector(
  Selector"importStructure(that)" to: Selector"import(that)"
  ) <>< Load <>< {reuse L42.is/Db}
UnivDb: Db.import(Db.ConnectionS"...")
/*..*/
}
CCode
The type Wcode(Selector) represent method selectors;
in the same way the type Wcode(Path) represent 
paths inside library literals, as in Wcode(Path"MyNested.MyNestedNested") or
Wcode(Path"This").

There are a lot of refactoring operations nested under Wcode(Refactor): 
<ul><li>
Wcode(RenameSelector)
and 
Wcode(RenamePath)
rename methods either at top level (as we just did) or
in an arbitrary nested library;
or rename paths into other paths
</li><li>

Wcode(Redirect)
removes a nested library and redirects all its references to
an external one. This emulates generics, as we will see later.
</li><li>
Wcode(UpdateDocumentationSelector)
and Wcode(UpdateDocumentationPath)
add to, alter or delete the documentation of methods/paths.
</li><li>
Wcode(MakeAbstractSelector)
and Wcode(MakeAbstractPath)
remove all the implementation out of a method or path,
leaving only the public skeleton
</li><li>
Wcode(HideSelector)
and Wcode(HidePath)
mark methods or paths as private.
We have not seen details on private members, the main idea is that
they are renamed into invisible names that you can never guess, and automatically renamed to avoid collisions 
by refactoring operations.
</li></ul>
WP
In addition to all those nested classes,
Wcode(Refactor) offers Wcode(`Refactor.compose(left,right)')
allowing a simmetric sum of two library literals.
The main idea is that members with the same name are recursively composed

WTitle(Introspection)
Wcode(Introspection) is
a class for exploring libraries, to discover what methods they have and so on.

The main classes inside of Introspection are
Wcode(Introspection.NestedLibrary),
 Wcode(Introspection.Method) and
Wcode(Introspection.Type).
You can obtain a nested library by calling the factory methods 
Wcode(Introspection(lib)) and Wcode(Introspection(classObj)),
respectively for library literals or class objects.
We will see some example later of use of Wcode(Introspection).



WTitle((5/5)Metaprogramming summary)
<ul><li>
Metaprogramming is hard; 42 tries to make it simpler, but not trivial.
</li><li>
Error handling is important while writing decorators.
More then half of decorators code should be dedicated
to handling errors and lifting them into a more understandable
form, for the sake of the final user.
</li><li>
We are just scratching the surface of what we
can do with metaprogramming.
If you are interested in becoming a Magrathean, then
refer to the painful metaprogramming guide (link);
otherwise just use existing metaprogramming libraries 
and use Wcode(Refactor) only when all the other options feel more painful.
</li></ul>


