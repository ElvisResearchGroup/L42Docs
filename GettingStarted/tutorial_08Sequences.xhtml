<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="https://www.googletagmanager.com/gtag/js?id=G-M0E4M0XH2Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-M0E4M0XH2Z');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-212820693-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-212820693-1');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=AW-10810288706"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'AW-10810288706');
    </script>
<!-- Event snippet for Page view conversion page -->
<script>
gtag('event', 'conversion', {'send_to': 'AW-10810288706/U3KJCKekmIUDEMLU36Io'});
</script>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logoBlue.png' alt='42' width='120' height='120'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90"> Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="tutorial_01Basics.xhtml"> Basic concepts </a></li>
 <li><a href="tutorial_02ModifiersIntro.xhtml"> Introduction to modifiers </a></li>
 <li><a href="tutorial_03BasicClasses.xhtml"> Basic Classes </a></li>
 <li><a href="tutorial_04ErrorsAndExceptions.xhtml"> Errors and Exceptions </a></li>
 <li><a href="tutorial_05Caching.xhtml"> Caching </a></li>
 <li><a href="tutorial_06CachingMut.xhtml"> Caching on Mutable objects </a></li>
 <li><a href="tutorial_07InterfacesAndMatching.xhtml"> Interfaces and Matching </a></li>
 <li><a href="tutorial_08Sequences.xhtml"> Collections and Sequences </a></li>
 <li><a href="tutorial_09InputOutput.xhtml"> Input Output </a></li>
 <li><a href="tutorial_10Exercises.xhtml"> Exercises </a></li>
 <li><a href="tutorial_11MetaprogrammingIntro.xhtml"> Metaprogramming Introduction </a></li>
 <li><a href="tutorial_12Refactoring.xhtml"> Programmatic Refactoring </a></li> 
 <li><a href="tutorial_13MoreDecorators.xhtml"> More Decorators </a></li>
 <li><a href="tutorial_14ExampleOfProgram.xhtml"> Example of a 42 Program </a></li>
 <li><a href="tutorial_15DeployCode.xhtml"> Deploy code </a></li>
</ol>
</div></div><div class="finishFloat"></div></div>
<br/>
<div class="index"><div class="wrapFloat"><div class="inFloat">
</div><div class="inFloat">
&nbsp; &nbsp; &nbsp; <a href="tutorial_07InterfacesAndMatching.xhtml"> Previous </a>...<a href="tutorial_09InputOutput.xhtml"> Next </a>
</div></div><div class="finishFloat"></div></div>
<br/>

 </p><p id="Sequences"> </p><div style="break-after:page"></div><h1> Collection: list, map, set, optional and their operations </h1> <p>

</p><h2> (1/5)lists manipulation </h2> <p>

As we have seen before, lists can be defined using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums: Collection.list(Num) //declaration for a list of nums
/*..*/
xs0 = Nums[10\;20\;30\] //xs0 <: mut Nums
Nums xs1 = Nums[10\;20\;30\] //xs1 <: imm Nums == //xs1 <: Nums
imm xs2 = Nums[10\;20\;30\] //xs2 <: imm Nums == //xs2 <: Nums
xs3 = Num.List[10\;20\;30\] //xs3 is another kind of list of nums
]]></pre>
As you can see above, many of the most common <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> classes have a nested class
called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.List]]></span><it style="font-style: bold; color:green;">&#187;</it> as a convenience feature, to avoid having to define your own in most programs.

<br/>

Lists can be created with square brackets; they are born mutable but can become immutable 
if they are directly assigned to an immutable local binding or parameter, or by other forms of promotion; for example,
a method without <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters returning a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference
can be used to initialize an immutable binding.
You need to specify the type of the local binding to force the promotion.
<br/>
For example: 

<pre class="l42Big"><![CDATA[
Nums myNums= DoIt.getMutableNums() //ok promotions happens, myNums is immutable

myNums= DoIt.getMutableNums() //myNums type is inferred to be mut Nums
]]></pre>

Immutable lists can be combined with operators.
The general idea is that operators 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+,-]]></span><it style="font-style: bold; color:green;">&#187;</it> work 
on one sequences and one element,
while the corresponding doubled-up operators
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[++,--]]></span><it style="font-style: bold; color:green;">&#187;</it>
work on two sequences.
You can see the details of this below.
<pre class="l42Big"><![CDATA[
X[
  //element addition
  Nums[a;b;c]+d == Nums[a;b;c;d];
  //element addition works both ways
  k+Nums[a;b;c]+d == Nums[k;a;b;c;d];
  //sequence concatenation
  Nums[a;b]++Nums[c;d] == Nums[a;b;c;d];
  //element removal
  Nums[a;b;b;c]-b == Nums[a;c];
  //sequence subtraction (like removeAll / set minus)
  Nums[a;b;b;c]--Nums[b;c] == Nums[a];
  ]
]]></pre>
In addition of operators, immutable lists also support a plethora of methods:
<pre class="l42Big"><![CDATA[
X[
  //replacement
  Nums[a;b;c;d].with(2I,val=e) == Nums[a;b;e;d];
  Nums[a;b;c;d].with(left=e) == Nums[e;b;c;d];//equivalent to Nums[..].with(0I val=e)
  Nums[a;b;c;d].with(right=e) == Nums[a;b;c;e];//equivalent to Nums[..].with(\size-1I val=e)
  //insertion
  Nums[a;b;c;d].withAlso(2I,val=e) == Nums[a;b;e;c;d];
  Nums[a;b;c;d].withAlso(left=e) == Nums[e;a;b;c;d];
  Nums[a;b;c;d].withAlso(right=e) == Nums[a;b;c;d;e];
  //skipping/filtering
  Nums[a;b;c;d].without(2I) == Nums[a;b;d];
  Nums[a;b;c;d].withoutLeft() == Nums[b;c;d];
  Nums[a;b;c;d].withoutRight() == Nums[a;b;c];
  Nums[a;b;c;b;d].withoutAll(val=b) == Nums[a;c;d];
  Nums[a;b;c;b;d].without(left=b) == Nums[a;c;b;d]; //filters out the leftmost b
  Nums[a;b;c;b;d].without(right=b) == Nums[a;b;c;d]; //filter out the rightmost b
  ]
]]></pre>
As you notice, there are different kind of actions: 
replace an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with]]></span><it style="font-style: bold; color:green;">&#187;</it>),
insert an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[withAlso]]></span><it style="font-style: bold; color:green;">&#187;</it>)
and skipping/filtering elements out (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[without]]></span><it style="font-style: bold; color:green;">&#187;</it>).
Then, elements can be specified by index, by being
the leftmost or the rightmost.
To filter elements out,
you can also just provide the element.

</p><p>


Immutable collections (and also mutable ones, as we will see later)
can be accessed with the following methods: 

<pre class="l42Big"><![CDATA[
X[
  //access
  Nums[a;b;c;d].left() == a;
  Nums[a;b;c;d].right() == d;
  Nums[a;b;c;d].val(2I) == c;
  Nums[a;b;c;d].size() == 4I;
  !Nums[a;b;c;d].isEmpty();
  ]
]]></pre>

</p><h2> Mutate sequences </h2> <p>

Mutable sequences can contain mutable objects.
While this can be useful in special circumstances, it can create aliasing issues similar to the
ones of the animals example of before.
To warn against such issues, methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left()]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> return 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> references to mutable objects. In order to obtain 
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, the user needs to use the methods
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#left()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#right()]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>

Mutable sequences can be more efficient that 
immutable ones, and are more general, since they 
can store mutable objects.
<br/>


Now we show some methods over a mutable list <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[foo = Nums[a;b;c;d]]]></span><it style="font-style: bold; color:green;">&#187;</it>; consider each following line independently: 
<pre class="l42Big"><![CDATA[
//setting a value in a position
foo.set(2I val=e) //foo == Nums[a;b;e;d]
//setting at left or right
foo.left(e) //foo == Nums[e;b;c;d]
foo.right(e) //foo == Nums[a;b;c;e]

//add a value in a position
foo.add(2I val=e) //foo == Nums[a;b;e;c;d]

//add at left or right
foo.add(left=e) //foo == Nums[e;a;b;c;d]
foo.add(right=e) //foo == Nums[a;b;c;d;e]

//removal
foo.remove(2I) //foo == Nums[a;b;d]
foo.removeLeft() //foo == Nums[b;c;d]
foo.removeRight() //foo == Nums[a;b;c]

//removal
foo.removeAll(val=b) //foo == Nums[a;c;d]
foo.remove(left=b) //remove the leftmost b
foo.remove(right=b) //remove the rightmost b
]]></pre>


</p><h2> (2/5) Iterations on lists and views </h2> <p>

We now show various pattens to iterate on lists.
First some usual foreach:
<pre class="l42Big"><![CDATA[
vec = S.List[S"foo"; S"bar"; S"beer"]
var S result = S""
for myElem in vec ( result++=myElem ) 
//result==S"foobarbeer"
]]></pre>

In 42 foreach allows to iterate on multiple collections at once, and also to update the collections:
<pre class="l42Big"><![CDATA[
rs = Nums[1\;2\;3\;]
as =  Nums[10\;20\;30\;]
bs =  Nums[100\;200\;300\;]
for a in as, b in bs, var r in rs ( r:= r+a+b )
//now rs==Nums[111\;222\;333\;]
]]></pre>

In the example above, a dynamic error would be raised if 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[rs]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[as]]></span><it style="font-style: bold; color:green;">&#187;</it> and
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bs]]></span><it style="font-style: bold; color:green;">&#187;</it> have different length.
We believe this is the right default behaviour.
To allow, for example, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bs]]></span><it style="font-style: bold; color:green;">&#187;</it> to be longer then <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[as]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[rs]]></span><it style="font-style: bold; color:green;">&#187;</it>,the programmer can 
use some variants of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>; a method producing an iterator on a subsequence of the original sequence.
The following variants are available: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(to)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In concrete example below we use them control iteration:
<pre class="l42Big"><![CDATA[
for a in as, b in bs.vals(to=as.size()), var r in rs ( r:= r+a+b )
//will give error if bs.size()<as.size() or as.size()!=rs.size()

for a in as.vals(1I), b in bs.vals(1I to=as.size()), var r in rs ( r:= r+a+b )
//will skip the first element of as and bs. Will skip any extra element of bs.
//will give error if as.size()!=rs.size()+1I
]]></pre>

The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.View]]></span><it style="font-style: bold; color:green;">&#187;</it> provides flexible iterators and sub-sequences.
Consider the following code examples:
<pre class="l42Big"><![CDATA[
NView = Collection.View(Num.List).cut()
MainCut = {
  xs= Num.List[..]
  ys= Num.List[..]
  for x in xs, y in NView(ys) ( .. )
    //will iterate as long as xs, even if ys is longer.
    //will stop after xs.size() cycles, and fail if xs.size()>ys.size()
  for x in NView(xs), y in NView(ys) ( .. )
    //will iterate for as long as both xs and ys have elements.
    //similar to a functional zip
  }
NViewM = Collection.View(Num.List).more()
MainMore = {
  xs= Num.List[..]
  ys= Num.List[..]
  for x in xs, y in NViewM(ys, more=30Num) ( .. )
    //will iterate as long as xs, even if ys is shorter.
    //y = 30Num when the iteration get over ys.size()
  for x in NViewM(xs, more=10Num), y in NViewM(ys, more=30Num) ( .. )
    //will iterate for as long as either of xs and ys have elements, and values
    //x = 10Num, y = 30Num are used when the collections exhausted their elements.
  for x in NView(xs), y in NViewM(ys, more=30Num) ( .. )
    //behaves as in the "x in xs" case: a 'cut' view will consume 'more' elements
    //if they are available
  }
]]></pre>

</p><h2> The power of the \ </h2> <p>

There are various methods taking advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> syntactic sugar.
They provide an expressive power similar to what list-comprehensions provide in python and streams in Java, but by just using simple control flow like for/if:

<pre class="l42Big"><![CDATA[
as =  Num.List[1\;2\;3\;4\;]
//mapping
bs0 = Num.List()(for a in as \add(a*10Num))
//bs0==Num.List[10\;20\;30\;40\]
//filtering
bs1 = Num.List()(for a in as if a>2Num \add(a))
//bs1==Num.List[3\;4\]
//flatmapping
bs2 = Num.List()(for a in as for b in bs0 \add(a+b))
//bs0==Num.List[11\;21\;31\;41\;12\;22\;32\;42\;13\;23\;33\;43\;14\;24\;34\;44\;]
//reduce to string
str0 = S"the content is: ".builder()(for a in as \add(a))
//str0 = S"the content is: 1234"
str1 = (if ns.isEmpty() S"[]" 
    else S"[%ns.left()".builder()(for n in ns.vals(1I) \add(S", %n"))++S"]")
//str1 = S"[1, 2, 3, 4]"
acc  = (var x = 0Num for a in as ( x+=a ) x) //reduce/fold
acc  = 0Num.acc()(for a in as \add(a))
//acc == 10Num

//checks a property; great in an if or an X[]
ok0 = Match.Some()(for a in as \add(a>3Num))
//ok0==true
ok1 = Match.All()(for a in as \add(a>3Num))
//ok1==false
ok2 = Match.None()(for a in as \add(a>3Num))
//ok2==false
ok3 = Match.Count()(for a in as \add(a>3Num))
ok3 = 0I.acc()(for a in as \addIf(a>3Num))
//ok3==2I
asContainsAllBs = Match.All()(for b in bs \add(b in as))
asIntersectBs = Match.Some()(for b in bs \add(b in as))
asDisjointBs = Match.None()(for b in bs \add(b in as))
//Note: b in as == as.contains(b)

]]></pre>
The language 42 is expression based. Expressions that look like statements are just expressions with the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> return type.
Those methods that take advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> are simply methods with a single parameter 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void that]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method in the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match.**]]></span><it style="font-style: bold; color:green;">&#187;</it> examples short circuit when appropriate, so that the for can terminate as soon as the result is known.


</p><h2> (3/5) Lists with mutable and immutable elements </h2> <p>

Up to now we focused on lists of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>, but 
all instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> are immutable; we now discuss what happens where
mutable lists contains a mixture of mutable and immutable elements.
Consider the following code:
<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
Points = Collection.list(Point)
..
imm p0=Point(x=0\,y=0\) //an imm point
p1=Point(x=1\,y=1\) //a mut point
ps=Points[p0;mutVal=p1] //a mut list with both points
X[
  p0==ps.val(0\);
  p0==ps.left();
  p1.readEquality(ps.#val(1\)); //== only works on imms,
  p1.readEquality(ps.#right()); //readEquality checks for structural equality
  p0.readEquality(ps.readVal(0\)); // .readVal generalizes over imm/mut values
  p1.readEquality(ps.readVal(1\));
  ]
for read p in ps ( Debug(p) )
]]></pre>

As you can see, to insert a mutable point we need to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mutVal]]></span><it style="font-style: bold; color:green;">&#187;</it> and to
take the point out we have to add the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it> to the method.
When iterating on a list, if we expect a mixture of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> values we must add <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>
to avoid a runtime error.
If we expect all values to be <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> instead.
When a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> collection is promoted to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, it still remembers what values were originally inserted as
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
To make it so that all values can be read as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can use the method
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.immNorm()]]></span><it style="font-style: bold; color:green;">&#187;</it>. In addition of normalizing the collection, it also marks all values
accessible as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown in the code below:

<pre class="l42Big"><![CDATA[
Points immPs=(
  imm p0=Point(x=0\,y=0\) //an imm point
  p1=Point(x=1\,y=1\) //a mut point
  Points[p0;mutVal=p1] //a mut list with both points
  ).immNorm()
for p in ps ( Debug(p) ) //works, it would fail without 'immNorm()'
]]></pre>

</p><h2> (4/5) Map, set, opt.. </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> also support maps, sets, optional and enumerations.
We will add more kinds of collections in the future.

</p><h2> Optional </h2> <p>
In 42 there is no concept of null, and all the values are always intentionally initialized before
they can be read.
There are two main reasons programmers rely on nulls: optional values and circular/delayed initialization.
Circular initialization can be solved with a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd]]></span><it style="font-style: bold; color:green;">&#187;</it> types, an advanced typing feature that we do not discuss here.
Optional values are a staple of functional programming and are logically equivalent to a collection of zero or one element, or, if you prefer, a box that may or may not contain an element of a certain type.
Optionals values can be obtained with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.optional(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below.
Optionals are also optimized so that they do not require the creation of any new objects at run time.

<pre class="l42Big"><![CDATA[
Point = Data:{ var Num x, var Num y }
OPoint = Collection.optional(Point)
Main = (
  imm p00=Point(x=0\ y=0\)//an imm Point in 00
  mut p01=Point(x=0\ y=1\)//a mut Point originally in 01
  var imm p00Box = OPoint(p00) //immutable Optional Point
  var mut p01Box = OPoint(p01) //mutable Optional Point
  X[
    p00 in p00Box; //the in syntax checks if an object is in the box
    p00Box.val()==p00; //Data defines == only for imm references
    p01Box.val().readEquality(p01);//here .val() gives us a read reference
    ]
  if p00Box ( Debug(S"printing %p00Box") )//printing [Point(x=0, y=0)]
  //we can just check if a box is not empty as if it was a boolean
  p01Box.#val().x(50\)//updates the x value of the point
  Debug(S"printing %p01")//printing Point(x=50, y=1)
  p00Box:= OPoint()//updates the local variables with empty boxes
  p01Box:= OPoint()
  if !p00Box ( Debug(S"printing %p00Box") )//printing []
    X[
    !(p00 in p00Box);
    !p00Box;//using isPresent() or not is just a matter of style
    !p00Box.isPresent();
    ]
  )
]]></pre>
At this point in the tutorial, some readers will be confused that we can update the local variable binding 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> even if it is immutable.
Other readers instead will remember that immutability is a property of the reference and not of the binding/field: a local binding and fields declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> can be updated.
The updated value needs to respect the modifier of the field/binding type: if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> it needs to be updated with another <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it>; if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> then it can be updated with either
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Oh, yes, another reader will realize ... and a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> reference can be assigned to any of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Note how both local bindings are updated using the same exact expression:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()    p01Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it>
In 42 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> can be either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> (or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> indeed)
On the other side, consider 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p00)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p01)]]></span><it style="font-style: bold; color:green;">&#187;</it>: the first one is immutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>,
while the second one is mutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p01]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Map </h2> <p>
Thanks to normalization 42 can have very fast and most reliable hash sets and hash maps.
The values of sets and the keys of maps must be immutable, and are normalized just before being inserted in the collection.
Then, the value of the normalized pointer is used to check for equality and hashcode.
This has various positive effects:

<ul><li>
The user does not need to write equality and hashing behaviour
</li><li>
There is no risk of mistake in the equality and hashing behaviour
</li><li>
The intrinsic invariants of the hashmap/hashset are never violated/corrupted.
</li><li>
The equality is a perfect structural equality, but is as fast as pointer equality; for maps with large keys this can make a massive performance difference.
</li></ul>

Maps and sets have less methods than lists, but they can still be iterated upon, as shown in the following code:

<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
Points = Collection.list(Point)
PointToString = Collection.map(key=Point, val=S)
Roads = Collection.map(key=Point, val=Point)
Main = (
  map = PointToString[
    key=\(x=3\ y=4\), val=S"MyBase";
    key=\(x=0\ y=0\), val=S"Source";
    key=\(x=5\ y=8\), val=S"EnemyBase";
    ]
  for (key,val) in map ( Debug(S"%key->%val") )
  //we can use (..) to extract the key/val fields from PointToString.Entry
  //this iteration is straightforward since all values are imm
  roads = Roads[
    key=\(x=3\ y=4\), val=\(x=0\ y=0\); //immutable to immutable
    key=\(x=0\ y=0\), mutVal=\(x=0\ y=0\);//immutable to mutable
    key=\(x=5\ y=8\), mutVal=\(x=0\ y=0\);//immutable to mutable
    ]
  for read (key, val) in roads ( Debug(S"%key->%val") )
  //we add 'read' in front to be able to read mixed imm/mut values
  //if all the values were mutable, we could just add 'mut' in front
  )
  mut Roads.Opt?? optPoint = roads.#val(key=\(x=0\ y=0\)))
  optPoint.#val().x(50\)//update the field of the objectv inside the map
  ]]></pre>

As you can see, when objects are retried from the map, we obtain an optional value; this is because statically we can not know if a key is mapped to a value or not.
<br/>
In addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
maps offers the following methods:
<ul><li>
To extract a value using the key:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>; to extract an optional
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, respectively.
As for lists, it is always safe to extract a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference. An empty optional will be produced when attempting to extract as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm/mut]]></span><it style="font-style: bold; color:green;">&#187;</it> a value that was inserted as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> instead, so to reliably ask if a key is contained in the map we should write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[map.readVal(key=myKey).isPresent()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</li><li>
Mutable maps can be modified by
inserting immutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it> and mutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Finally, an association can be removed using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.map(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> creates a class remembering the insertion order.
This is needed to make the iteration deterministic.
The keys can be retrieved with their order using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[key(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> passing the desired <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I index]]></span><it style="font-style: bold; color:green;">&#187;</it>, from zero to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\size-1I]]></span><it style="font-style: bold; color:green;">&#187;</it>
The corresponding value can be retrieved by methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> 
to extract a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> (not optional) reference to the value, respectively.
</li></ul>
     

</p><h2> Set </h2> <p>
Sets behave a lot like maps where the values are irrelevant, and have differently named methods.
In particular, in addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
sets offer methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> to add and remove an element,
and elements can be extracted in the insertion order by using method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>

We are considering adding operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+,-,++,--]]></span><it style="font-style: bold; color:green;">&#187;</it> to sets, as supported by lists, and
support for the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> as well.
An operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[&&]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the intersection of the two sets.
On the other side, boolean methods like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[intersect(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[disjoint(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[containsAll(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> can already be easily emulated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match]]></span><it style="font-style: bold; color:green;">&#187;</it> as we shown for lists.

</p><h2> (5/5) Collection summary </h2> <p>

<ul><li>
There are tons of methods and operators to know, but since most code works 
around collections, it is worth the effort to memorize them.
</li><li>
Immutable collections are easy to play with, using operators and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with**]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
</li><li>
Mutable collections can be more efficient and flexible, but they come with additional
difficulties.
</li><li>
Most methods have a general version that works with an index, and specialized <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right]]></span><it style="font-style: bold; color:green;">&#187;</it> variants.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> can help remove a lot of boilerplate, but is a concept unique to 42, and require some effort to get used to.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> is very useful and flexible. It is common to find methods composed from just a large
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> statement plus a little pre and post processing around it.
</li></ul>

</p><h2> Digressions / Expansions </h2> <p>
Collections support iteration with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> syntax.
Iteration in 42 is way more flexible than in most other languages, and it is delegated on method calls.
Iteration in 42 is designed to support two main iteration strategy:
explicit indexes and iterator objects.
For example, the code

<pre class="l42Big"><![CDATA[
for read a in as, var b in bs ( b:=b.foo(a) )
]]></pre>
would expand to
<pre class="l42Big"><![CDATA[
aIt = as.#iterator()
bIt = bs.##iterator()
var ai = as.#startIndex()
var bi = bs.#startIndex()
while aIt.#hasElem(ai).#itAnd(bIt.#hasElem(bi)) (
  var a=aIt.#elem#read(ai)
  var b = bIt.#elem#default(bi)
  b := bIt.#update#default(bi,val=b.foo(a))
  ai := ai.#succ()
  bi := bi.#succ()
  ) 
]]></pre>
Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#elem#read]]></span><it style="font-style: bold; color:green;">&#187;</it> is used instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#elem#default]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.##iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> is used instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Iteration methods in detail </h2> <p>

<ul>
<li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[##iterator]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
They return an object able to provide the elements of the list. The second variant
returns a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> object, this is needed to provide the mutable version of those elements, and to update those elements in the list.
The second variant is used if the local binding is explicitly declared either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>,<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For complex bindings, like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(key, mut val)=e]]></span><it style="font-style: bold; color:green;">&#187;</it>, the second variant is used if any binding component would require it.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
The initial iteration hint is produced by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> and moved forward by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#itAnd]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#more]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
The iterator checks if it has more elements to provide by calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since iterations in 42 can work on multiple collections at the same time,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> results can be combined with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#itAnd]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This design offers a lot of flexibility;
special kinds of collections may return special data types to coordinate termination in some way.
The AdamsTowel collections opt for an efficient solution where 
there are four logical results for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustContinue]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canContinue]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canStop]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The iteration will stop if all the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canStop]]></span><it style="font-style: bold; color:green;">&#187;</it>,
and an error is raised if some <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustContinue]]></span><it style="font-style: bold; color:green;">&#187;</it> and some other returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it>.

With this design, the result of the single <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> method coordinates the various iterators to check if more elements are possibly available, and to decide how strongly to insist for those elements to be visited.
</li></ul>

</p><h2> Possible implementations of Iteration methods </h2> <p>

The iterator methods allows for a range of possible options.
The simplest one, and possibly the most efficient, is to delegate everything to the collection object:
in this case, there is no need to create a new object to serve as an iterator, since
the collection itself is able to simply access/update its elements by index, thus 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#varIterator]]></span><it style="font-style: bold; color:green;">&#187;</it> may simply return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> returns the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it> if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that<this.size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I"-1"]]></span><it style="font-style: bold; color:green;">&#187;</it> otherwise.
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#close]]></span><it style="font-style: bold; color:green;">&#187;</it> will throw error if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> would return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
Another option would be the one of a linked list, where it would be inefficient to
rely on the index to access the elements.
In this case,
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#varIterator]]></span><it style="font-style: bold; color:green;">&#187;</it> may simply return a singleton object
delegating the behaviour to the index object.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> can simply expose the first internal
node, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it> can produce the next node.
The singleton object may be able to see private methods of those
internal nodes, thus even if we expose the internal nodes, they will be 
just unusable black boxes to the library user, and all the interactions can be mediated, and checked by the singleton iterator object.
</p><p>
Iterators in Java and other languages will throw an error if the collection is somehow modified during the iteration. This could be supported by providing a specialized sublist object that can remember its version; but it is unclear if this is a good idea in 42, where most collections would be iterated while they are immutable.
The few cases of iteration on mutable collections
may be the ones where there are good reasons to perform mutation during iteration.
While adding elements at the start of a collection under iteration is most likely a bug, other operations have very reasonable use cases.
For example, 
appending elements at the end of a list while computing a fixpoint, removing tasks from the end of a list if they are now unneeded,
or replacing already visited elements with new ones.
<br/>
<div class="index"><div class="wrapFloat"><div class="inFloat">
</div><div class="inFloat">
&nbsp; &nbsp; &nbsp; <a href="tutorial_07InterfacesAndMatching.xhtml"> Previous </a>...<a href="tutorial_09InputOutput.xhtml"> Next </a>
</div></div><div class="finishFloat"></div></div>
<br/>

        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'>
            <a href="mailto:marco.servetto@gmail.com" rel="me">Contact Us</a> |</li>
            <li style='display:inline;'>
            <a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>

