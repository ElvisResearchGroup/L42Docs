<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logo.png' alt='42'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
</p><h1> Basics </h1> <p>
</p><h2> (1/5)Simple hello world program </h2> <p>
Let's look at a simple hello world program:
<pre class="l42Big"><![CDATA[ 
{reuse L42.is/AdamTowel
Main:{
  Debug(S"Hello world")
  return ExitCode.success()
  }
}
]]></pre>
At the right of <span class="code"><![CDATA[Main:]]></span> we write the expression that
we wish to execute; in this case a sequence of two statements.
<span class="code"><![CDATA[Main]]></span> is not a method, and <span class="code"><![CDATA[Main]]></span> is not special name either. In 42 there is no concept of main method as in
Java or C. For now you can think of <span class="code"><![CDATA[Main:]]></span> as a top level command, we will understand later how this fits with the general language design.

When we write <span class="code"><![CDATA[reuse L42.is/AdamTowel]]></span> we are asking 42 to
reuse the code offered by the library offered in the internet address 
<span class="code"><![CDATA[L42.is/AdamTowel]]></span>.
AdamTowel is our Towel, that is the set of classes and interfaces that we wish to start from (<a href="towel.xhtml">see more on towels</a>).
<span class="code"><![CDATA[L42.is]]></span> is the main website of 42, where most commonly used libraries are hosted. To reuse code you 
need an internet connection; but this also means that you will never have to manually import any code. Required code will be transitively downloaded and cached on your machine, so you need not to be aware of the existence of this mechanism.
</p><p>
We do not need to always start from AdamTowel, there are many interesting towels out there, and you may also become skilled in the 
advance technique of towel embroidery.
</p><p>

</p><h2> (2/5)Method declaration and call </h2> <p>
Let's now declare a method and call it.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
MyCode:{
  class method
  S hello(S name){
    return S"hello "++name
    } 
  }
Main:{
  Debug(MyCode.hello(name:S"world"))
  return ExitCode.success()
  }
}
]]></pre>
Here we declare a class to host our <span class="code"><![CDATA[hello(name)]]></span> method.
We write <span class="code"><![CDATA[class method]]></span> to declare a method that can be called on the class object, as in <span class="code"><![CDATA[MyCode.hello(name:S"world")]]></span>. This is roughly equivalent to a static method in languages like Java or C++, or class methods in Python.

</p><p>
Note how the method is called using the parameter name explicitly.
We believe this increases readability.
</p><p>
You can also notice how there are two different usages for curly brackets: if there is at least a return keyword it is a set of statements,
otherwise is a library literal, and can contains methods and nesteds.
A nested (class or interface) is denoted by an upper-case name, and can be obtained by a library literal or an expression producing a library literal.
A library can be a class (default case) or an interface (starts with the <span class="code"><![CDATA[interface]]></span> keyword).
A nested in 42 is similar to a static inner class in Java, or a nested class in C++. It is just a convenient way to divide in a tree shape the various components of our program.
</p><p>
The class <span class="code"><![CDATA[MyCode]]></span> from before offers a single class method, has no fields and you can not create instances of <span class="code"><![CDATA[MyCode]]></span>, since no factory is present; you can think about it as a module.
In 42 we do not have constructors. Objects are created by factory methods. We believe this is a much simpler and more consistent approach to object initialization.

</p><h2> (3/5)Simple class with internal state </h2> <p>
Let's create now a class with state and factory:
<pre class="l42Big"><![CDATA[
Point:Data<<{
  Num x
  Num y
  method
  Point add(Num x)
    Point(x:x+this.x(), y:this.y())
  Point add(Num y)
    this.with(y:y+this.y())
  }
]]></pre>
Here you can see we declare a <span class="code"><![CDATA[Point]]></span> class with <span class="code"><![CDATA[x]]></span> and <span class="code"><![CDATA[y]]></span> <span class="code"><![CDATA[Num]]></span> (unlimited precision rational number) coordinates.
<span class="code"><![CDATA[Data]]></span> is a decorator. Decorators are classes/objects that offer an operator <span class="code"><![CDATA[<<]]></span>, called the babel fish operator,
whose goal is to translate a library into a "better" library.
In this case, <span class="code"><![CDATA[Data]]></span> is translating the class <span class="code"><![CDATA[{Num x, Num y}]]></span> into a much longer class, with
a factory method taking in input the fields and initializing them, but also containing
 boring but useful definitions for
equality, inequality, conversions from and to human readable strings, XML and binary representations for (de)serialization.
</p><p>
Finally, we declare methods to add to a single coordinate.
For very short methods we can omit the curly brackets and return.
Indeed, method bodies are just expressions, and the curly brackets turn statements into expressions. 

In the method <span class="code"><![CDATA[add(x)]]></span> we show a constructor call and getters.
In the method <span class="code"><![CDATA[add(y)]]></span> we show an improved version, using the <span class="code"><![CDATA[with]]></span> method, another gift of Data, that allows us to easily create a clone with a
single field updated.
We can declare two methods, <span class="code"><![CDATA[add(x)]]></span> and <span class="code"><![CDATA[add(y)]]></span> with the same name, if parameter names are different.
</p><p>
Note how we always use getters and we never access fields directly.
In many other languages we can use write <span class="code"><![CDATA[a.fieldName]]></span> and <span class="code"><![CDATA[a.fieldName:newValue]]></span>. Such syntax does not exists in 42. The same goes for object instantiation; in many languages there is a special <span class="code"><![CDATA[new ClassName(..)]]></span> dedicated syntax, while in 42 it is just a method call.
</p><p>
Also, similarly to what happens in Python, we need to use <span class="code"><![CDATA[this.methodName()]]></span> to call methods when the receiver is <span class="code"><![CDATA[this]]></span>.
While this makes some code more verbose, it saves us from the burden of  method hiding.   



</p><h2> Decorators </h2> <p>
Decorators are one of the main concepts used by 42 programmers. We will encounter many decorators in this tutorial.
For now, just get used to the pattern of writing
<span class="code"><![CDATA[<<]]></span> to go from a minimal chunk of code, with method declarations for the important bits, to a fully fledged usable class.
<a href="Decorators.xhtml">More on decorators</a>


</p><h2> (4/5)Vectors </h2> <p>

Vectors can be declared using <span class="code"><![CDATA[Collections.vector(of)]]></span>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums:Collections.vector(of:Num)//declaration for vectors of nums
Points:Collections.vector(of:Point)//same for points
/*..*/
xs=Nums[10Num;20Num;30Num]
ys=Nums[1Num;2Num;3Num]
points=Points[with x in xs.vals(), y in ys.vals() (
  use[Point(x:x, y:y)]
  )]
]]></pre>

Vectors can be initialized with the <span class="code"><![CDATA[[_;_;_]]]></span>
syntax or with the <span class="code"><![CDATA[[with _ ( _ use[ _ ]_ )]]]></span> syntax.
We will discuss all the variation of <span class="code"><![CDATA[with]]></span> later.
Note how to express number literal we need to specify their class.

</p><h2> (5/5)Basis Recall </h2> <p>

<ul><li>
At the start of your program, import a towel using 
"<span class="code"><![CDATA[reuse _]]></span>", as in <span class="code"><![CDATA[reuse L42.is/AdamTowel]]></span>.
</li><li>
To declare a simple class exposing its state and 
some methods working with those, use <span class="code"><![CDATA[Data]]></span>, as in
<span class="code"><![CDATA[Point:Data<<{Num x]]></span>.
</li><li>
You can declare methods in classes with the <span class="code"><![CDATA[method]]></span> keyword,
as in <span class="code"><![CDATA[method ReturnType myName(ParType parName) body]]></span>.
Use <span class="code"><![CDATA[class method]]></span> for methods that can be called on the class object directly.
</li><li>
To define a vector of a type, use 
<span class="code"><![CDATA[Collections.vector(of)]]></span>
as in 
<span class="code"><![CDATA[Points:Collections.vector(of:Point)]]></span>
</li></ul>


</p><h2> Object creation recall </h2> <p>
42 supports many different syntactic forms that are convenient to create objects:
<ul><li>
12Num: from a numeric representation
</li><li>
S"foo": from a string representation
</li><li>
Point(x:_,y:_): from the parameter values
</li><li>
Points[_;_;_]: from a variable length sequence of values; for example <span class="code"><![CDATA[Points]]></span> can be a list of <span class="code"><![CDATA[Point]]></span>. We can instantiate <span class="code"><![CDATA[Points]]></span> by using the square brackets as shown later. 
</li></ul>

Note that in 42 those are all just expressions, and represent methods in the named class.
Sometimes it is convenient to reuse this kind of syntax to get better syntactic support for certain operations; for example, the string class uses square brackets to support string formatting.
<a href="S.xhtml">To understand it better: a guide to the S class</a>
</p><h1> Keep control: Modifiers, kinds of classes/references/objects </h1> <p>

</p><h2> (1/5)Kinds of classes </h2> <p>
<span class="code"><![CDATA[Point]]></span> is an <span style="color:#ff1111; font-weight: bold;"> Immutable class </span>: none of its fields can be updated or mutated.
Immutable classes are very easy to use but may be inadequate when representing real objects, whose state can mutate across time.
A <span style="color:#ff1111; font-weight: bold;"> Mutable class </span> is a class where the state of (some of) its instances may be mutated.

Let's now declare a <span class="code"><![CDATA[Animal]]></span> mutable class, whose location can be updated.
<pre class="l42Big"><![CDATA[
Animal:Data<<{
  var Point location
  mut method
  Void run() 
    this.location(this.location().add(x:20Num))
  }
]]></pre>
There are two new keywords used here:
<ul><li>
the <span class="code"><![CDATA[location]]></span> field is declared <span class="code"><![CDATA[var]]></span>.
  This is called a variable field, and can be updated by calling a setter.
  Non variable fields can not be updated
</li><li>
  the modifier "mut" in front of the method. 
  We have seen "class" already, an we have seen methods with the default modifier ( add(x) and add(y) ).
  mut methods can mutate the "this" object. If you have experience with C++ you can see the similarity with <span class="code"><![CDATA[const]]></span> methods.
  immutable (default) methods works only on immutable "this" objects. We will see later much more about modifiers
</li></ul>

</p><p>
As you see, we are using the <span class="code"><![CDATA[add]]></span> method from before.
Also notice that we are using a setter here, where we are providing the first parameter without the argument name.
While usual in other languages, in 42 parameters are passed
by name.
However, for some methods with a single parameter writing down the parameter name would not improve the readability and just add noise.
In those cases the first parameter is conventionally called <span class="code"><![CDATA[that]]></span>, 
and writing <span class="code"><![CDATA[a.b(that:c)]]></span>
is equivalent to writing <span class="code"><![CDATA[a.b(c)]]></span>.
This works also for methods with multiple parameters, if the first one is called <span class="code"><![CDATA[that]]></span>.
We can use an animal by writing, for example:

<pre class="l42Big"><![CDATA[
  dog=Animal(location:Point(x:0Num, y:0Num))//type of the reference inferred
  mut Animal dogAlias=dog //this is the exact type 
  dog.run()
]]></pre>

</p><h2> (2/5)Interaction between mutable and immutable </h2> <p>

We now explore some interaction between mutable and immutable objects.
<pre class="l42Big"><![CDATA[
Animal:Data<<{
  var Point location
  mut Points path
  mut method
  Void move() 
    this.location(path.first()))
    this.path().removeFirst()
  }
]]></pre>


Here we use <span class="code"><![CDATA[mut Points path]]></span> to denote a mutable list of points. Note the absence of <span class="code"><![CDATA[var]]></span>; this is conceptually similar to a <span class="code"><![CDATA[Points * const path;]]></span> in C++ or <span class="code"><![CDATA[final Points path;]]></span> in Java.
To contrast, the declaration <span class="code"><![CDATA[var Point location]]></span> is similar to
<span class="code"><![CDATA[Point const * location;]]></span> in C++ or <span class="code"><![CDATA[ImmPoint location;]]></span> in Java (for an opportune <span class="code"><![CDATA[ImmPoint]]></span> class).
That is, 
mutable objects can be referred using mutable references,
Immutable objects can be referred using immutable references.

This code models an animal following a path. It can be used like this.
<pre class="l42Big"><![CDATA[
  zero=Point(x:0Num, y:0Num)
  ps1=Points[ Point(x:12Num, y:20Num);Point(x:1Num, y:2Num)]
  ps2=Points[ zero;Point(x:1Num, y:2Num)]
  dog1=Animal(location:zero, path:ps1)
  dog2=Animal(location:zero, path:ps2)
  dog1.move()
  dog2.move()
]]></pre>

In this code the first dog goes to 12:20.
The secon dog goes to 0:0. 

This code involves a mutable animal with a mutable field. This is often
a terrible idea, since its behaviour may depend on aliasing: what happens if two dogs follow the same path?
<pre class="l42Big"><![CDATA[
  zero=Point(x:0Num, y:0Num)
  ps=Points[ Point(x:12Num, y:20Num);Point(x:1Num, y:2Num)]
  dog1=Animal(location:zero, path:ps)
  dog2=Animal(location:zero, path:ps)
  dog1.move()
  dog2.move()
]]></pre>
The first dog moves and consumes the path for the second one as well.
That is, the first goes to 12:20 and the second goes to 1:2.

This is because <span class="code"><![CDATA[Animal]]></span> is now a <span style="color:#ff1111; font-weight: bold;"> Deeply mutable class </span>: a mutable class with mutable fields. 
An amazing amount of bugs are caused by the usage of deeply mutable classes.

</p><h2> (3/5)Capsules: Keep aliasing graphs untangled </h2> <p>

This triky behaviour is correct for a 
deeply mutable class. 
In 42 we can change <span class="code"><![CDATA[Animal]]></span> to prevent this aliasing issue.
<pre class="l42Big"><![CDATA[
Animal:Data<<{
  var Point location
  capsule Points path
  mut method
  Void move() 
    this.location(path.first()))
    this.path().removeFirst()
  }
]]></pre>
Now we use the modifier "capsule", this requires the field to be encapsulated with respect to aliasing.
Immutable objects do not influence aliasing, so they are free from aliasing limitations.

</p><p>
The "capsule" modifier <span style="color:#ff1111; font-weight: bold;"> forces </span> the users to provide well encapsulated values,
 and <span style="color:#ff1111; font-weight: bold;"> ensure </span> 
 the <span class="code"><![CDATA[Animal]]></span> data is well encapsulated.
</p><p>

Now the code of before would not compile. However we can still write the following variant
<pre class="l42Big"><![CDATA[
  zero=Point(x:0Num, y:0Num)
  capsule Points ps=Points[ Point(x:12Num, y:20Num);Point(x:1Num, y:2Num)]
  dog1=Animal(location:zero, path:ps)
  dog2=Animal(location:zero, path:Points[ Point(x:12Num, y:20Num);Point(x:1Num, y:2Num)])
  dog1.move()
  dog2.move()
]]></pre>
Where the <span class="code"><![CDATA[ps]]></span> local binding is declared capsule; 
it can satisfy the Animal.path requirement, but it can be used only once.
<span class="code"><![CDATA[dog2]]></span>
has to use another capsule. It is ok to just write the object creation in place as is done.
Alternatively, most classes offer a <span class="code"><![CDATA[clone()]]></span> method,
so in this case we could write

<span class="code"><![CDATA[dog2=Animal(location:zero, path:dog1.ps().clone())]]></span>



</p><h2> (4/5)Immutable objects of Mutable classes </h2> <p>

How can we get an immutable <span class="code"><![CDATA[Animal]]></span>?
When an <span class="code"><![CDATA[Animal]]></span> is created using <span class="code"><![CDATA[Animal(location:__,path:__)]]></span> we create a <span class="code"><![CDATA[mut Animal]]></span>.

In most cases you can promote such reference to immutable/capsule; just make the type of the local binding explicit.
 The type system will take care of the rest.
If a reference can not be safely promoted to immutable/capsule, you may have to use the <span class="code"><![CDATA[.clone()]]></span> method or to refactor your code.
<pre class="l42Big"><![CDATA[
  mut Animal dog1=Animal(__)//no promotion here
  Animal dog2=Animal(__)//promotion mutable->immutable
  dog1.move()
  //dog2.move() //ill-typed, requires a mut Animal
]]></pre>

We will explain later the exact rules for promotion,
the main idea is that if the initialization expression uses local bindings in a controlled way, then promotion can be applied.
For example, a mutable expression using only capsule or immutable references can be promoted to capsule/immutable.

</p><h2> read </h2> <p>

Use "read" when you do not care what is the mutability of an object.
For example, we could add to <span class="code"><![CDATA[Animal]]></span>

<pre class="l42Big"><![CDATA[
read method
Bool isArrived()
  this.path().isEmpty()
]]></pre>
This method can be called to mutable and immutable animals:

<pre class="l42Big"><![CDATA[
Debug(dog1.isArrived())
Debug(dog2.isArrived())
]]></pre>

</p><h2> (5/5) Recall </h2> <p>
  
</p><h2> Kinds of classes, recall </h2> <p>
  
<ul>
<li>
immutable classes: have only immutable fields.
It is useful to model mathematical concepts.
It is easy to reason about code using immutable classes,
but some properties of real objects can be better modelled with state mutation.
</li><li>
shallow mutable classes: have only (variable) fields of immutable or capsule type (or class, as we will see later). 
Reasoning with shallow mutable classes is near as easy as reasoning with immutable ones, and often more natural.
</li><li>
deep mutable classes: have mutable fields.
Reasoning with deep mutable classes can be very hard.
</li></ul>
  
</p><h2> Modifiers up to now, recall </h2> <p>

<ul>
<li>
immutable: the default. When you omit the modifier,
 you mean immutable. 
An immutable reference points to an object that is never changing. Its whole reachable object graph never change and is immutable as well.

</li><li>
mutable: A mutable reference behaves like a normal reference in Java, C#, C++, Python and many other languages.
Mutable references allow mutating the referred object.
</li><li>
capsule: local capsule references are used only once and they guaranteed that the whole reachable object graph is reachable only thought that
capsule reference. 
Local Capsule references provide a structured way to reason over deep mutable objects.

Fields can be annotate capsule, the meaning is that they need to be initialized/updated with capsule variables.
We will discuss more about capsule fields and how they differs from capsule local binding later.
 
</li><li>
read: A readable reference can not be used to mutate the referred object; but other mutable references pointing to the same object can mutate it.
Read references can point to both mutable and immutable objects.
It is easy to confound between read and immutable references.
As a rule of thumb, if you are in doubt if you should use an immutable or a readable, you probably want an immutable reference.

</li><li>

class: class references denote the class object,
  on methods the meaning is the same of static methods in many languages, but it can consistently be used on parameters/local variables/fields
to encode behaviours similar to dependency injection.


</li><li>
lent: we still need to see the lent modifier; a hygienic mutable reference allowing mutation but not storage (more on lent later).
</li></ul>



</p><h2> Kinds of objects, recall </h2> <p>

<ul>
<li>
immutable: objects 
 can be instances of immutable classes, or promoted instances of mutable classes.
 They
can be referred only by immutable and read references.
</li><li>
mutable: objects are instances of mutable classes.
They can be referred by capsule, mutable, lent and read references.
</li><li>
class: objects are instances of themselves.
They can be referred only by class references, either of their class or of one transitively implemented interface.
</li></ul>
</p><h1> Units of Measure </h1> <p>

</p><h2> (1/5) Num and Size </h2> <p>
<span class="code"><![CDATA[Num]]></span> is a general number type,
implemented as an arbitrary precision rational.
When in doubt of what numeric type to use, <span class="code"><![CDATA[Num]]></span>
is a good first guess.
Some examples of usage:
<pre class="l42Big"><![CDATA[
little=123Num
stillLittle=4567890Num
big=100000000000000000Num
bigger=100000000000000000.0001Num
fraction=Num"123/4567890"
hold= fraction == little/stillLittle
Debug(fraction)
Debug(Num"12/4") //will print "3"
]]></pre>

Another useful numeric type is <span class="code"><![CDATA[Size]]></span>.
It represents sizes and indexes in sequences.
<span class="code"><![CDATA[Size]]></span>s are returned by <span class="code"><![CDATA[size()]]></span> methods
and are expected as parameter by indexing methods.
<span class="code"><![CDATA[Size]]></span> represent 32 bit numbers with the usual 
but triky modulo arithmetic.

</p><h2> Loading other numeric types </h2> <p>

You can import other numeric types by loading libraries.
For example

<pre class="l42Big"><![CDATA[
Int:Load<<{reuse L42.is/Numbers/Int}//not supported yet
//infinite precision positive and negative integer numbers
Double:Load<<{reuse L42.is/Numbers/Double}//not supported yet
//double precision positive and negative floating points numbers
Float:Load<<{reuse L42.is/Numbers/Float}//not supported yet
//single precision positive and negative floating points numbers
Int64:Load<<{reuse L42.is/Numbers/Int64}//not supported yet
//64 bit modulo arithmetic
UInt64:Load<<{reuse L42.is/Numbers/UInt64}//not supported yet
//64 bit modulo arithmetic, unsigned
]]></pre>

The class decorator <span class="code"><![CDATA[Load]]></span> allows to load libraries and embed them in the 
current context, while the
reuse keyword imports the code from the web.

</p><h2> Conversions </h2> <p>
Conversions between various numeric classes must be performed explicitly.
All numeric classes implements 
the <span class="code"><![CDATA[Numeric]]></span> interface and offer the <span class="code"><![CDATA[.from(numeric)]]></span> method.
So, for example 
<pre class="l42Big"><![CDATA[
Double:Load<<{reuse L42.is/Numbers/Double}
size=S"hello".size()
myDouble=Double.from(numeric:size)
]]></pre>
converts from <span class="code"><![CDATA[Size]]></span> to <span class="code"><![CDATA[Double]]></span>.
This avoid precision loss as much as possible.




</p><h2> (2/5) Units </h2> <p>


The class 
<span class="code"><![CDATA[Units]]></span>
offers methods to create units out of numeric supports, like <span class="code"><![CDATA[Num]]></span>
and <span class="code"><![CDATA[Size]]></span>.

For example
<pre class="l42Big"><![CDATA[
Meter:Units.of(Num)
Second:Units.of(Num)
res=(6Meter +4Meter)*2Num //20Meter
//wrong1=6Meter+2Second
//wrong2=6Meter/2Second
]]></pre>
As you can see, we can sum meters together, and we can use the support for multiplication, but we can not mix different units of measure.


Mathematically you can obtain the support out of the unit by
division: <span class="code"><![CDATA[42Meter/2Meter = 21Meter]]></span>.
This do not work directly in 42, since multiplication and division
takes the support and not a unit.
Units provide method <span class="code"><![CDATA[div(that)]]></span> for this aim.
Units also provide method  <span class="code"><![CDATA[#inner()]]></span>,
this is just extracting the value of the support from the unit.
This can be convenient during programming bud 
does not makes a lot of sense mathematically.
Methods like that, require to be used with care, they start with
<span class="code"><![CDATA[#]]></span> to underline that they should be used with care.

<pre class="l42Big"><![CDATA[
Num n1=42Meter.div(2Meter)//=21Num
Num n2=42Meter.#inner()//=42Num
]]></pre>



</p><h2> (3/5) Composite Units </h2> <p>

<span class="code"><![CDATA[Units]]></span> supports composite units:
<pre class="l42Big"><![CDATA[
Speed:Units.of(Meter per:Second)
fast1=Speed(42Meter per:0.1Second)
fast2=Speed"42/0.1"
distance1=fast1.per(60Second)

Acc:Units.of(Speed per:Second)
g=Acc"9.8"
speedAfter=g.per(10Second)//98 m/s
distance2=speedAfter.per(10Second)/2Num //490 m after 10s free fall

Kg:Units.of(Num)
Newton:Units.of(Kg and:Acc)//Kg*m/s2
myRoket=900Newton
gForceOnMe=Newton(78Kg and:g)//little less than 780
myLift=myRoket-gForceOnMe
if myLift>0Newton (Debug(S"I can fly"))
myAcc=myLift.div1(78Kg)//get second component
reachedHeight=myAcc.per(10Second).per(10Second)/2Num //after 10 sec
]]></pre>
Note how we can use <span class="code"><![CDATA[.per()]]></span>,
 <span class="code"><![CDATA[.div1()]]></span> 
 and <span class="code"><![CDATA[.div2()]]></span> to extract the first or the second component
 in a composed unit.
</p><p>
We can also declare aliasing units:

<pre class="l42Big"><![CDATA[
Cm:Units.alias(0.01Meter)//not supported yet
Meter height=178Cm
]]></pre>

Note how height is of type <span class="code"><![CDATA[Meter]]></span>.
Alias units are just shortcut to declare values of
the original unit.




</p><h2> (4/5) Alphanumeric </h2> <p>
In the same way <span class="code"><![CDATA[Units]]></span> allows easy creation of
arithmetic classes,
<span class="code"><![CDATA[Alphanumeric]]></span> allows easy creation of alphanumeric classes:
classes that can be istantiated from a string literal that follow certain 
properties.


<pre class="l42Big"><![CDATA[
Email:Alphanumeric<<{//not supported yet
  S local //fields
  S domain
  class method
  This parse(S that) {
    index=that.indexOf(S"@")//works only for simple emails
    if index==-1 (error this.parseError(S"@ not found"))
    local=that(end:index)//string slicing
    domain=that(start:index+1/ )//string slicing
    if domain.contains(S"@") (error this.parseError(S"multiple @ found"))
    return This(that,local:local,domain:domain)
    }//call the factory with fields plus the original string
}
myEmail=Email"arthur.dent@gmail.com"
Assert.$[// assertions check the truth of some statementes
  myEmail.local() expected:S"arthur.dent";
  myEmail.domain() expected:S"gmail.com";
  myEmail.toS() expected:S"arthur.dent@gmail.com";
  ]
]]></pre>

Note how we can raise an error if the string does not have the shape we expected.
We will see errors/exception in more detail soon.
We can declare fields, and compute their values by parsing the string.
While it is suggested to propagate the original string in the factory,
it is not mandatory, for example you could apply some form of normalization, as shown under:

<pre class="l42Big"><![CDATA[
Email:Alphanumeric<<{/*..*/
  This parse(S that) {/*..google ignore dots anyway..*/
    local=that(end:index).replaceAll(S"." with:S"")
    /*..*/
    return This(local++S"@"+domain,local:local,domain:domain)
    } 
  }
myEmail=Email"arthur.dent@gmail.com"
Assert.$[myEmail.toS() expected:S"arthurdent@gmail.com"]
]]></pre>

</p><h2> (5/5) Recall </h2> <p>

<ul><li>
Use <span class="code"><![CDATA[Num]]></span> as your first guess for numeric types,
if you have special needs, can consider loading a numeric library.
</li><li>
Use <span class="code"><![CDATA[Size]]></span> for indexing linear datastructures like vectors and strings.
Beware of the tricky modulo arithmetic.
</li><li>
Use <span class="code"><![CDATA[Units]]></span> 
and <span class="code"><![CDATA[Alphanumeric]]></span> to give meaning to your constants.
In this way the type system will help you to use values with the semantic you decided.
</li></ul>
</p><h1> Interfaces, Concepts and Data </h1> <p>

</p><h2> (1/5)Interfaces </h2> <p>
In 42 interfaces are quite similar to interfaces in other oo languages.
There are however a couple of important differences:

</p><p>
while implementing an interface method, you have not to repeat the
typing.
For example, in the following code, to implement <span class="code"><![CDATA[Shape.draw(that)]]></span> inside
of <span class="code"><![CDATA[Square]]></span>, we do not repeat the types <span class="code"><![CDATA[Void]]></span> and <span class="code"><![CDATA[mut Canvas]]></span>
<pre class="l42Big"><![CDATA[
Shape:{interface
  method Void draw(mut Canvas that)
  }
Square:{implements Shape
  method draw(that){..}
  }
]]></pre>

In 42, we say that the method <span class="code"><![CDATA[draw(that)]]></span> 
implemented in <span class="code"><![CDATA[Square]]></span>
<span style="color:#ff1111; font-weight: bold;"> is defined by </span>
<span class="code"><![CDATA[Shape]]></span>.
Each method is defined in a single point, either the class itself
or a (transitively) implemented interface.
This means that a class can not implement multiple interfaces defining methods
with the same name.
For example, this code is ill-typed:
<pre class="l42Big"><![CDATA[
Card:{interface
  method N draw()//the value of the drawn card
  }
Gun:{interface
  method N draw()//the time it takes to drawn the gun
  }
Wrong:{implements Card,Gun//not allowed
  }
]]></pre>


Note that that would be bad 42 code anyway, you should define an
enumeration (see later) for your cards and use a <span class="code"><![CDATA[Second]]></span> unit of measure
for the time.

</p><h2> (2/5)Interfaces </h2> <p>
However, interface diamond is allowed, that is, the following code is correct:
<pre class="l42Big"><![CDATA[
Shape:{interface
  method Void draw(mut Canvas that)
  }
Animal:{interface implements Shape
  method Meter run(){..}
  }
Noisy:{interface implements Shape
  method Void play(mut Audio that){..}
  }
LoudCat:{implements Animal, Noisy
  method draw(that){..}
  method run(){..}
  method play(that){..}
  }
]]></pre>

You can further specify the type of an interface method by using the keyword 
<span class="code"><![CDATA[refine]]></span>:
<pre class="l42Big"><![CDATA[
Monster:{interface
  method Monster spawnMinion()
  }
BigMonster:{implements Monster
  refine method BigMonster spawnMinion(){..}
  }
]]></pre>


</p><h2> (3/5)Concepts: ToS, Equals, Classable, ... </h2> <p>
<span class="code"><![CDATA[Concepts]]></span> is a class defined in AdamTowel,
containing interfaces commonly used by many classes.
</p><p>
The most well known one is 
<span class="code"><![CDATA[Concepts.ToS]]></span>, implemented by all objects that can
be converted in human readable strings.

In AdamTowel,
Alphanumeric, Numeric and Units just print
the string or the number as it is.

</p><p>
Other objects prints their fields content in square brackets.
<span class="code"><![CDATA[Data]]></span> generates a reasonable
<span class="code"><![CDATA[Concepts.ToS]]></span> implementation, following this patter. For fields of interface type,
the class name of the stored instance is also produced.
Strings and numbers are enclosed with double quotes.

</p><p>
Another very well known interface is <span class="code"><![CDATA[Concepts.Equals]]></span>
implemented by objects that can be compared with
<span class="code"><![CDATA[read method Bool equals(Concepts.Equals that)]]></span>.
Such objects usually also define methods <span class="code"><![CDATA[==]]></span> and <span class="code"><![CDATA[!=]]></span>
based on <span class="code"><![CDATA[equals]]></span>, but is not required by the interface.

<span class="code"><![CDATA[Data]]></span> will automatically generate a valid <span class="code"><![CDATA[Concepts.Equals]]></span>
implementation, and derived methods <span class="code"><![CDATA[==]]></span> and <span class="code"><![CDATA[!=]]></span>.
The default implementation of 
<span class="code"><![CDATA[Data]]></span> do not takes in account circular object graphs, and will end up in loop in those cases. We will discuss later how to personalize the behaviour of <span class="code"><![CDATA[Data]]></span>.

</p><p>
Finally, an interface that near every class or interface implements is <span class="code"><![CDATA[Concepts.Classable]]></span>.
It allows to get the class object out of an ordinary instance.
This is very useful when wanting to create an instance based on another.
For example, to create another shape of the same kind of a given shape,
we could do the following:
<pre class="l42Big"><![CDATA[
Shape:{implements Concepts.Classable
  class method This newShape(Color that)
  }
Square:{implements Shape
  Color color
  method newShape(that)//implemented from Shape
    This(color:that)
  method clazz()//implemented from Concept.Classable
    This//this implementation can be omitted if "Data<<" is used
  }
/*..*/
Shape s=..
s.clazz().newShape(Color.red())
]]></pre>
Where the interface <span class="code"><![CDATA[Shape]]></span> defines an abstract factory method (that is,
an interface class method returning <span class="code"><![CDATA[This]]></span>)
and class <span class="code"><![CDATA[Square]]></span> implements
 <span class="code"><![CDATA[Shape]]></span> (and thus also <span class="code"><![CDATA[Concepts.Classable]]></span>).
 
 
</p><h2> (4/5)Concepts.Invariant </h2> <p>
 
<span class="code"><![CDATA[Concepts.Invariant]]></span> is another interface implemented very often and
 that can be handled by <span class="code"><![CDATA[Data]]></span>, but in a different way with respect to the former ones:
 An instance of an object is more than just a record storing other objects of various types;
 those values are bond together by an invariant: a property that
 holds for all values of that type.
 AdamTowel and Data use <span class="code"><![CDATA[Concepts.Invariant]]></span> to represent this idea:
 A class that does not implement <span class="code"><![CDATA[Concepts.Invariant]]></span> just have the
 empty invariant enforced by type type of its fields, but the programmer can specify a
 more stringent invariant by implementing <span class="code"><![CDATA[Concepts.Invariant]]></span>, as 
 in the following code:
 
 <pre class="l42Big"><![CDATA[
Margin:Data<<{implements Concepts.Invariant
  var Meter minX
  var Meter minY
  var Meter maxX
  var Meter maxY
  method invariant()
    this.minX()<=this.maxX() & this.minY()<=this.maxY()
  }
]]></pre>

Here we define a class <span class="code"><![CDATA[Margin]]></span> where the invariant
states that the min coordinates have to be smaller that the max ones.

<span class="code"><![CDATA[Data]]></span> will generate code so that the invariant is checked while the object is created
and in any field update.
<span class="code"><![CDATA[Data]]></span> guarantees that no <span class="code"><![CDATA[Margin]]></span> object that does not 
satisfy the invariant will ever be visible outside of the scope of the <span class="code"><![CDATA[invariant()]]></span> method itself.

See more about restrictions of this mechanism in (<a href="dataAndInvariants.xhtml">data and invariants</a>)
(This will go in that link, but need more context to be understood: more explanation of Capsule field vs Capsule bindings, exposers and lent, also, is not implemented in 42 Yet)
The current example shows a class with all immutable fields.
It is possible to enforce the invariant also on classes with immutable
and capsule fields.
Then <span class="code"><![CDATA[Data]]></span> will additionally check that the
lent exposers are all private and not used in internal nested classes,
and that every method using the lent exposer do not return a lent result.
It is unobvious why such requirements suffice: the idea is that the only way a capsule value ...


</p><h2> (5/5)Interfaces and Data, recall </h2> <p>

Interfaces in 42 serves the same role they serve in other languages,
with a little bit of a twist in the details.

The big news is that Decorators (<span class="code"><![CDATA[Data]]></span> in our examples) can
help and provide implementations for free.
This is much more powerful with respect of traits, multiple inheritance or
Java 8 default methods, since the implementation can be generated ad hoc
by examining the class.
 </p><h1> Errors and Exceptions: Messages in AdamTowel </h1> <p>

</p><h2> (1/5)Errors, Messages, Asserts, Guards, .. so much terminology </h2> <p> 
In 42 when something takes an unexpected turn,
you can throw an <span class="code"><![CDATA[error]]></span>
This is similar to Java unchecked exceptions.
Every immutable object can be thrown as an error.
While it is possible to thrown informative strings, they do no offer enough
structure to fully take advantage of the error mechanism.
AdamTowel define the interface <span class="code"><![CDATA[Message]]></span>:
a structured way to provide a certain kind of message to the user.
<span class="code"><![CDATA[Message]]></span>s has <span class="code"><![CDATA[.text()]]></span> ,
<span class="code"><![CDATA[.isResponse()]]></span> and <span class="code"><![CDATA[.responseOf()]]></span>.
The text is the informative string, while if there is
a response (<span class="code"><![CDATA[msg.isResponse()==Bool.true()]]></span> 
then <span class="code"><![CDATA[msg.responseOf()]]></span> will be the 
former message in the chain.

There are two main kinds of <span class="code"><![CDATA[Message]]></span>s:
<span class="code"><![CDATA[Guard]]></span> and <span class="code"><![CDATA[Assert]]></span>.
While Assertions are useful to observe bugs, the application
logic should not depend on them, since they may change
in unpredictable ways during library evolutions, and can be
enabled or disabled.
A guard is guaranteed to be consistent across library evolution
thus program logic can depend on them being thrown.

Assertions are very convenient to check for pre/post conditions.
The following code show usages of <span class="code"><![CDATA[Assert.Pre]]></span> and <span class="code"><![CDATA[Assert.Bug]]></span>

<pre class="l42Big"><![CDATA[
Assert.Pre[ //preconditions
  myVal>0Nat;//simplest form
  myVal>0Nat msg:S"here with personalized message";
  myVal expected:42Nat //call equals and do a better error reporting
  ]//in a bunch of assertions, they are all going to be checked together.
Assert.Bug[ //postconditions/checks in the middle
  res expected: 42Nat msg:S" message"
  ]
if notGoodParameter (Assert.Pre"error message")
if observedBug  (Assert.Bug"error message")
]]></pre>

</p><h2> (2/5) create, throw and capture </h2> <p>

You can create new kinds of messages using the 
service class of the message interface:

<pre class="l42Big"><![CDATA[
AnswerNotUnderstood:Message.$<<{implements Guard}
//this is a new kind of message, implementing Guard.
//you can also add methods to your kind of message.
//you can add fields, we will see this more in detail later.
/*..*/
//throwing an error
if this.ohNoNoNOOO() (error AnswerNotUnderstood"Well, too bad")

if this.iWasDistracted() (
  //throwing an error in response of another
  Guard other=NotListening""//empty message
  error AnswerNotUnderstood"Try again"(other)
  )

]]></pre>

As you can see, since <span class="code"><![CDATA[Message]]></span> is an interface, it can not help us directly
to create messages, however it has a service nested class called <span class="code"><![CDATA[$]]></span>, that
is a class decorator helping us to create valid messages.
As you can see we can create messages with text, and
then we can optionally add a response.
Now, let see how to capture errors:

<pre class="l42Big"><![CDATA[
(myWait=7.5MillionYear
 answer=DeepThought.answer()
 understanding=myBrain.process(answer)
 catch error AnswerNotUnderstood msg (/*handle it*/)
 catch error Guard msg (/*something else gone wrong*/)
 //in the catch bodies, 'understanding' and 'answer' are not defined
 myBrain.accept(understanding)//normal execution if no issue
 )
]]></pre>

As you see, in 42 there is no explicit <span class="code"><![CDATA[try]]></span> statement,
but any block of code can contain <span class="code"><![CDATA[catch]]></span>.
The catch capture errors in the block before the last (group of) catches.
Catches can not see local variables declared in the scope of a possible error.
The following example explain the control flow more in detail:

<pre class="l42Big"><![CDATA[
res=(
 b1=CanGoWrong()
 b2=CanGoWrong()//see b1
 catch error Wrong msg1  1Nat//not see b1,b2
 catch error Guard msg2  2Nat//not see b1,b2
 b3=CanGoWrong()//can see b1, b2
 catch error Wrong msg3  3Nat//see b1,b2, not see b3
 4Nat//see b1,b2,b3
 )
]]></pre>
The following code can assign to <span class="code"><![CDATA[res]]></span> either 1,2,3 or 4.
Note how every catch exits from the whole block.
Errors guarantee a property called strong error safety
(strong exception safety in the Java/C++ terminology)
This means that the body of a catch will observe the same 
state present at the start of the block.
This is enforced by disallowing catching errors if the (portion of the) block before can mutate visible objects.

That is, the following code do not compile
<pre class="l42Big"><![CDATA[
p=Person(name:S"Bill" age:23Year)
res=(
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Guard msg2  (/*could see p with 23 or 24 years*/)
 p
 )
]]></pre>

While the following is accepted.

<pre class="l42Big"><![CDATA[
res=(
 p=Person(name:S"Bill" age:23Year)
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Guard msg2  (/*can not see p*/)
 p
 )
]]></pre>

</p><h2> (3/5) exceptions and errors </h2> <p>

Exceptions are like checked exceptions in java.
As for errors, every immutable object can be thrown as an exception.
just write "exception" instead of "error" while throwing or capturing.
Exceptions represent expected, documented and reliable behaviour,
they are just another way to express control flow.
They are useful to characterize multiple outcomes for an operation,
where is important to prevent the programmer from forgot about
the many possible outcome and focus only on its preferred one.
Exceptions are checked, so methods leaking exceptions have to
declare so in their header, as in the following.
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
method
S promptUser(S text)
exception CancelPressed {
  /*implementation to open a text dialog*/
  }
]]></pre>
Where the programmer using <span class="code"><![CDATA[promptUser]]></span> will have to handle 
the possibility that the cancel button was pressed.

Exceptions does not enforce strong exception safety as error do,
so they can be used more flexibly, and since they are documented in
the types, we can take their existence in account while writing imperative programs.
<span class="code"><![CDATA[Assert]]></span>ions should not be thrown as exceptions, but only as errors.

Often, the programmer wants to just turn exceptions in errors or other exceptions.
This is possible with the following code:


<pre class="l42Big"><![CDATA[
//long version
DoStuff()
catch exception FileNotFound fnf (
  error WTF"I just created it!"(fnf)
  )

//short version
DoStuff()
error on FileNotFound
  WTF"I just created it!"
]]></pre>
The two snippets of code behave identically: the first
show a very common patter; 42 supports syntactic sugar to
ease following that pattern, as you can see in the second snippet.
<span class="code"><![CDATA[WTF]]></span> stands for what a terrible failure
(as in android), and can be used to mark branches of code
that the programmer believe would never be executed.
<span class="code"><![CDATA[WTF]]></span> implements <span class="code"><![CDATA[Assert]]></span>, thus code capturing
<span class="code"><![CDATA[WTF]]></span> is unreliable.





</p><h2> (4/5) return </h2> <p>

Return, as we have seen, can be used to exit from the inner
most level of curly brackets.
Also curly brackets can have catches, let see some examples
<pre class="l42Big"><![CDATA[
{
x=DoStuff()
catch exception Stuff e1
  void//just swallow the exception
catch exception Guard e2
  obj.doSideEffect()//this method return void
catch exception Message e3
  return e3//a result of the curly brackets
y=DoStuff(x)
return y
error on Guard 
  WTF""
}  
]]></pre>

Moreover, curly brackets/return can be used
to provide a different result if some computation fails:

<pre class="l42Big"><![CDATA[
res={return PlanA()
  catch error Guard x
    return PlanB()
  }
]]></pre>

</p><h2> return looks similar to error/exception </h2> <p>
Return is actually another thing that can be thrown and captured.
While only immutable values can be thrown as errors/exceptions,
return can throw any kind of value, but returns can not flow
outside of the scope of a method.
Hold your head before it explodes, but curly brackets are just a syntactic sugar
 to capture returns; those two snippets of code are equivalent

<pre class="l42Big"><![CDATA[
N res={if bla return e1
  return e2}
//---
N res=(
  Void unused=(
    if bla return e1
    return e2
    )
  catch return N x
    x
  error void//this line is never executed
  )
]]></pre>
Depending on how your brain works,
knowing the desugaring of <span class="code"><![CDATA[{..return..}]]></span>
can help you to use return better and understand why you can omit 
<span class="code"><![CDATA[{..return..}]]></span> for simple method bodies, and why you can
write multiple groups of curly brackets and have local returns.
Or can just be very confusing. If you are in the second group, just
never ever write <span class="code"><![CDATA[catch return]]></span> explicitly and continue
your 42 experience ignoring the issue.


</p><h2> (5/5) Errors, exceptions and return, recall </h2> <p>
<ul><li>
Whenever possible, try to detect if your code misbehave, and 
terminate it with an <span class="code"><![CDATA[Assert]]></span>
</li><li>
Whenever something out of your
control happen, Give it a name and throw it as an error, as in
<pre class="l42Big"><![CDATA[
NameOfIssue:Message.$<<{implements Guard}
/*...*/
if /*..*/ error NameOfIssue"more info"
]]></pre>
It just take 2 lines, and will make debugging your code so much 
easier.
</li><li>
Use errors as much as makes sense, 
but use exceptions sparsely: they are needed only in few 
cases, mostly when designing public libraries.
</li><li>
To convert exception into errors or other exceptions, use the convenient short
syntax <span class="code"><![CDATA[error on T1,..,Tn  OtherMessage""]]></span> or 
<span class="code"><![CDATA[exception on T1,..,Tn  OtherMessage""]]></span>
</li><li>
Sometimes it is possible to write elegant and correct code
that is not covered in layers upon layers of error/exception checking,
but often is not possible or is not convenient.
Good 42 code can be composed for half of
its content of just error/exception handling/lifting and management.
Do not be scared of turning your code in it's own policemen.
</li></ul>
</p><h1> Collections and Data classes </h1> <p>

A very large class of practically useful programs can be obtained by
just declaring simple minded classes using Data and Collections.

</p><h2> Libraries </h2> <p>


</p><h1> not ready to read yet Libraries </h1> <p>

</p><h2> Libraries </h2> <p>
42 stands for the primate of libraries, so let see some libraries in action.
We have already see how to chose a towel, and many classes that are likely to be present in such towel, like
<span class="code"><![CDATA[S]]></span> and <span class="code"><![CDATA[Data]]></span>.
Let see now how to load a library from its url:
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Gui: Load<<{reuse L42.is/Gui}
Main:{
  Gui.alert(S"hi!")
  return ExitCode.success()
  }
}
]]></pre>
Load is another decorator, here it modifies the library found in L42.is/Gui so that it can be used easly from AdamTowel.
 <!--
 
 Data invariants
 interface
  
 Sequences
 Strings
 Collections
 iterations 
 
 Exceptions
 Assertions
 
 Units and alphanumerics
 
 
 

 
 Use Extends Refactor
 
    //Meter dx=this.x()-that.x();
    //Meter dy=this.y()-that.y();
    //m2=Meter2[dx;dx]+Meter2[dy;dy]
    //return Meter[root:2Unit of:m2]
    //dx=dx.unit()
    //Meter.fromUnit(((dx*dx)+(dy*dy)).sqrt())
    
    
    
    </p><h2> (2/5) Iteration </h2> <p>

It is possible to iterate over a range of numbers:

<pre class="l42Big"><![CDATA[
with i in 4Size.vals() (
  Debug(i)//prints 4,5,6,7 and so on forever
  )
]]></pre>

<pre class="l42Big"><![CDATA[
with i in 4Size.upTo(42Size) (
  Debug(i)//prints 4,5,6,7 and so on up to 42 excluded
  )
]]></pre>

    
 -->	
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Collections: Load<<{reuse L42.is/Collections}
Point:Data<<{Meter x, Meter y
  method 
  Meter distance(Point from){/*...*/}
  }
Points:Collections.vector(of:Point)
Main:{
  zero=Point(0Meter,0Meter)
  ps=Points[ Point(x=12Meter, y=20Meter);Point(x=1Meter, y=2Meter);]
  var Meter tot=0Meter
  with p in ps.vals() (
    tot+=p.distance(from:zero)
    )
  return ExitCode.success()
  }
}
]]></pre>




</p><h2> Collections </h2> <p>
Declaring and using collections is simple and easy in 42.
For example, we can declare and use a list of  <span class="code"><![CDATA[Point]]></span> by writing
<pre class="l42Big"><![CDATA[
Points:Collections.mutList(Point)

...

zero=Point(x=0Int, y=0Int)
one=Point(x=1Int, y=1Int)
ps0=Points[]//the empty list
ps1=Points[zero;one]//contains zero, one
ps2=Points[zero;one]//contains zero, one

]]></pre>



<!--<pre class="l42Big"><![CDATA[ Library myCode={ method Int foo()} ]]></pre>
A local binding of type Library initialized with a class with a single <span class="code"><![CDATA[foo()]]></span> method. Since there is no body, it is an abstract method.
 -->	 

 <!--</p><h2> Simpler complete program </h2> <p>

Let now starts showing the simplest 42 program: an empty library.

<pre class="l42Big"><![CDATA[ {} ]]></pre>

If we save this valid program in a file <span class="code"><![CDATA[Test.L42]]></span> and we run <span class="code"><![CDATA[L42 Test]]></span>, we get an error.
</p><p>
As you see 42 is very intuitive, as you would expect from your former life experiences, most simple things just does not work.
Note how valid programs can produce errors.
We will soon learn how to produce errors in controlled and elegant ways.
-->
<!--A 42 program execution <span style="color:#ff1111; font-weight: bold;"> is </span> the generation of all its nested classes/interface.
, code is simply executed from top to bottom as in 
Python, Javascript or Php. However, the
top level expression is a Library, and code can go in libraries 
as an initializer for you need to put the code into an expression
-->

<!-- LATER?
<span class="code"><![CDATA[MyCode.hello(..)]]></span> use directly the <span class="code"><![CDATA[MyCode]]></span> class instance as receiver. We can also give it a name 
e se vuoi puoi anche salvarlo su un binding locale, tipo x=MyCode  x.hello(...)
-->
        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <!--<li style='display:inline;'><a href="http://ecs.victoria.ac.nz/Main/MarcoServetto" >Contact Us</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/disclaimer">Mailing list</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/accessibility" >Site Accessibility</a></li>
			-->
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>
