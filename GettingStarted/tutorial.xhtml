<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logo.png' alt='42'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90"> Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="#Basics"> Basic concepts </a></li>
 <li><a href="#ModifiersIntro"> Introduction to modifiers </a></li>
 <li><a href="#BasicClasses"> Basic Classes </a></li>
 <li><a href="#ErrorsAndExceptions"> Errors and Exceptions </a></li>
 <li><a href="#Caching"> Caching </a></li>
 <li><a href="#CachingMut"> Caching on Mutable objects </a></li>
 <li><a href="#InterfacesAndData"> Interfaces and Data </a></li>
 <li><a href="#Sequences"> Collections and Sequences </a></li>
 <li><a href="#InputOutput"> Input Output </a></li>
 <li><a href="#Exercises"> Exercises </a></li>
</ol>
</div></div><div class="finishFloat"></div></div>

 </p><p id="Basics"> </p><h1> Target audience </h1> <p>
This tutorial is design for expert programmers, already knowledgeable in 
at least two or three of the languages Java, C#, C++ and Python.
This tutorial lays out the basic knowledge for programming in 42 using AdamsTowel, but
does not explore the foundational theory behind 42,
or the mathematical rationale for the correctness of 42.
<br/>
The language 42 and many 42 metaphors are inspired by
 The Hitchhiker's Guide to the Galaxy by Douglas Adams.
</p><h1> Basics </h1> <p>
</p><h2> (1/5)Simple hello world program </h2> <p>
Let's look at a simple hello world program: 

<pre class="l42Big"><![CDATA[ 
reuse [L42.is/AdamsTowel]
Main = Debug(S"Hello world")
]]></pre>
<br/>
When we write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse L42.is/AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> we are asking 42 to
reuse the code of the library found in the internet address 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
AdamsTowel is our <it style="font-style: italic;">towel</it>, that is the set of classes and interfaces that we wish to start from.
A <it style="font-style: italic;">towel</it> usually plays the role of "the standard library" of most languages.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is]]></span><it style="font-style: bold; color:green;">&#187;</it> is the main website of 42, where most commonly used libraries are hosted. To reuse code you 
need an internet connection; but this also means that you will never have to manually import any code.
Required code will be downloaded and cached on your machine, so you need not to be aware of the existence of this mechanism.
</p><p>
We do not need to always start from AdamsTowel; there are many interesting towels out there, and you may also become skilled in the 
advanced technique of towel embroidery.
In this tutorial, all of our examples are expressed reusing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>

At the right of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main = ]]></span><it style="font-style: bold; color:green;">&#187;</it> we write the expression that
we wish to execute; in this case we just print out using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug]]></span><it style="font-style: bold; color:green;">&#187;</it> class.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> is not a method, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> is not special name either. You can replace it with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Task]]></span><it style="font-style: bold; color:green;">&#187;</it> or any other valid
upper-case name. In 42 there is no concept of main method as in
Java or C. 
For now you can think of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main = ]]></span><it style="font-style: bold; color:green;">&#187;</it> as a top level command. We will understand later how this fits with the general language design.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a simple class whose most important method print a message on the console.
</p><p>
In 42, when a class has a <span style="color:#ff1111; font-weight: bold;"> most important </span> method, it is conventional to use the empty name, so that can be used with the short syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug(S"Hello world")]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of a more verbose <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug.println(..)]]></span><it style="font-style: bold; color:green;">&#187;</it>. 

<br/>
In 42, Strings and numbers need to be created using their type, as in
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"Hello world"]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[12Num]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[12Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is just a convenience syntax equivalent to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"1"]]></span><it style="font-style: bold; color:green;">&#187;</it>; the syntax with quotes is needed to express negative or fractional number literals, as for example <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"-12"]]></span><it style="font-style: bold; color:green;">&#187;</it>
 or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"53/21"]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>

</p><h2> (2/5)Method declaration and call </h2> <p>
Let's now define a method and call it.
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
MyCode = {
  class method
  S hello(S nickName) = { //we can use usual if/while
    if nickName.isEmpty() (return S"Hello!")
    return S"Hello %nickName!"
    } 
  }
Main = Debug(MyCode.hello(nickName=S"Marvin"))
//will print "Hello Marvin!"
]]></pre>
<br/>
Here we define a class to host our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hello(nickName)]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
We write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it> to define a method that can be called on the class object, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode.hello(nickName=S"Marvin")]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is roughly equivalent to a static method in languages like Java or C++ , or class methods in Python.

</p><p>
Note how the method is called using the parameter name explicitly.
We believe this increases readability.
</p><p>
You may also notice how there are two different usages for curly brackets:  if there is at least one <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword then the expression is a block of statements,
otherwise the expression is a library literal, which can contains methods and nested libraries.
A <span style="color:#ff1111; font-weight: bold;"> nested library </span>
is denoted by an upper-case name, and can be created from a library literal or from an expression producing a library literal.
A library literal can be a class (default case) or an interface (starts with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword).
A nested library in 42 is similar to a static inner class in Java, or a nested class in C++. It is just a convenient way to separate the various components of our program and organize them into a tree shape.
</p><p>
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode]]></span><it style="font-style: bold; color:green;">&#187;</it> from before offers a single class method, has no fields and you can not create instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode]]></span><it style="font-style: bold; color:green;">&#187;</it>, since no factory is present; you can think about it as a module.
In 42 we do not have constructors. Objects are created by <it style="font-style: italic;">factory methods</it>, that are just normal methods that happen to return an instance of their class. We believe this is a much simpler and more consistent approach to object initialization than having special syntax that encourages programmers to make assumptions about the behaviour of the operations.

</p><h2> (3/5)Simple class with internal state </h2> <p>
Now we show a class with state and a factory method: 
<pre class="l42Big"><![CDATA[
Point = Data:{
  Num x
  Num y
  method
  Point add(Num x) = //long version
    Point(x=x+this.x(), y=this.y())
  method
  Point add(Num y) = //shorter
    this.with(y=y+this.y())
  method
  Point sum(Point that) =
    Point(x=this.x()+that.x(), y=this.y()+that.y())
  }
]]></pre>
<br/>
Here you can see we define a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> class with coordinates <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
unlimited precision rational number.

In addition of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it>
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> will offer many other useful methods since it has been declared using
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.
 </p><p>
Indeed, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is a decorator. Decorators are classes/objects that offer an operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it>, called the decorator operator,
whose goal is to translate a library into a <span style="color:#ff1111; font-weight: bold;"> better </span> library.
In this case, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is translating the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{Num x, Num y .....}]]></span><it style="font-style: bold; color:green;">&#187;</it>
 into a much longer class, with
a factory method taking in input the fields and initializing them; but also containing
 boring but useful definitions for
equality, inequality, conversion to string and many others.
<!--from and to human readable strings, XML and binary representations for (de)serialization.-->
</p><p>
Finally, we define a methods to add to each of the coordinates.
For very short methods we can omit the curly brackets and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Indeed, method bodies are just expressions, and the curly brackets turn a block of statements into one expression. 

In the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> we show how to create a new 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> instance and how to call <it style="font-style: italic;">getter methods</it>.
In the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it> we show an improved version, using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with]]></span><it style="font-style: bold; color:green;">&#187;</it> method, another gift of Data, that allows us to easily create a clone with one or more fields updated.
We can define two methods, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it> with the same method name, if parameter names are different.
</p><p>
Note that we always use getters and we never access fields directly.
In many other languages we can use write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.fieldName]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.fieldName= newValue]]></span><it style="font-style: bold; color:green;">&#187;</it>. Such syntax does not exists in 42. The same goes for object instantiation; in many languages there is a special <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[new ClassName(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> dedicated syntax, while in 42 it is just a method call.
</p><p>
Also, similarly to what happens in Python, we need to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.methodName()]]></span><it style="font-style: bold; color:green;">&#187;</it> to call methods when the receiver is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While it makes some code more verbose, naming the receiver avoids ambiguities about scoping and nesting for method resolution.


</p><h2> Decorators </h2> <p>
Decorators, such as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, are one of the main concepts used by 42 programmers. We will encounter many decorators in this tutorial.
For now, just get used to the pattern of writing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> to go from a minimal chunk of code, with method declarations for the application specific bits, to a fully fledged usable class.

</p><h2> The backslash <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> </h2> <p>
In 42, we can use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> character as a shortcut.
There are two different ways to use the backslash:
as a keyword or immediately followed by a lowercase identifier.
</p><p>
As a keyword, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> represents the expected type of the surrunded expression.
The slash search outwards on super expressions until it finds a place with an easily guessable type:
the return type of the method, a method parameter or a local binding with an explicit type.
For example:
<pre class="l42Big"><![CDATA[
method Point add(Num x) = Point(x=x+this.x(), y=this.y())
]]></pre>
could be shortened as 
<pre class="l42Big"><![CDATA[
method Point add(Num x) = \(x=x+this.x(), y=this.y())
]]></pre>
Consider these other examples:
<pre class="l42Big"><![CDATA[
method Num foo() = 1\+2\ // \ is Num
method class Num bar() = \ // \ is Num
method Num baz() = \.zero().toS().size() // \ is Num
]]></pre>
</p><p>
Followed by a method name (and method parameters if any)
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> represents the receiver of the innermost method invocation.
Thus, for example
<pre class="l42Big"><![CDATA[
method Point add(Num y) = this.with(y=y+this.y())
]]></pre>
could be shortened as 
<pre class="l42Big"><![CDATA[
method Point add(Num y) = this.with(y=y+\y)
]]></pre>
Consider this other example:
<pre class="l42Big"><![CDATA[
method Point bar(Point that) = that.with(y=\sum(that).y())
method Point bar(Point that) = that.with(y=that.sum(that).y())//equivalent
]]></pre>

</p><p>
In the rest of the tutorial, we will use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> when it saves space. This shortcut seems unusual at first, but with a little of experience becomes very clear. 42 is a pure OO language, where the method call is the central operation. 
This syntax allows for the expressions of the method parameters to depend on the method receiver. We will see that this enables many interesting micropatterns.

</p><h2> (4/5)Collection.list </h2> <p>

Lists can be defined using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(_)]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the example below,

<pre class="l42Big"><![CDATA[
Nums = Collection.list(Num) //declaration for vectors of nums

Points = Collection.list(Point) //same for points

Main1 = Debug(Nums[ 10\; 20\; 30\ ]) //here \ is Num
Main2 = Debug(Points[\(x=10\ y=20\);\(x=1\ y=2\)]) //here the outer \ is Point
]]></pre>
where we define new classes <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points]]></span><it style="font-style: bold; color:green;">&#187;</it>. Note that those are new classes in a nominal type system, so in
<pre class="l42Big"><![CDATA[
Nums1 = Collection.list(Num)
Nums2 = Collection.list(Num)
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums1]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums2]]></span><it style="font-style: bold; color:green;">&#187;</it> denote different classes, with different types.
As you can see, lists can be initialized with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_;_;_]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this case, this syntax is equivalent to creating a new empty list and then calling the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method
one time for each of the expressions separated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[;]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Of course, the parameter type of that method is the element type of the list, so
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> finds it as an easily guessable type.

</p><p>

Consider now the following code:
<pre class="l42Big"><![CDATA[
xs = Nums[ 10\; 20\; 30\ ]
ys = Nums[ \"-1"; \"2/3"; 3\ ]
points = Points[]
for x in xs, y in ys (
  points.add(\(x=x, y=y))// here \ is Point
  )
Debug(points) //prints
//[Point(x=10, y="-1"); Point(x=20, y="2/3"); Point(x=30, y=3)]
]]></pre>
As you can see, we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> to iterate on multiple collections at once.
<br/>
In 42 as in most other languages you can have blocks of code where multiple
<it style="font-style: italic;">local bindings</it> are introduced by associating a lowercase name with an initialization expression.
Similarly, the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> introduces local bindings whose values will range over collection elements by associating them with initialization expressions for iterators.


</p><h2> (5/5)First summary </h2> <p>

<ul><li>
At the start of your program, import a towel using 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse _]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse [L42.is/AdamsTowel]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
To define a simple class exposing its state and 
some methods working with those, use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point = Data:{Num x, Num y}]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
You can define methods in classes with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[method]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword.
Use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it> for methods that can be called on the class object directly.
</li><li>
To introduce the concept of list for a certain type, use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(_)]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/> as in the class declaration
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points = Collection.list(Point)]]></span><it style="font-style: bold; color:green;">&#187;</it>
</li></ul>


</p><h2> Object creation summary </h2> <p>
42 supports many different syntactic forms that are convenient for creating objects: 
<ul><li>
12Num:  from a numeric representation
</li><li>
S"foo":  from a string representation
</li><li>
Point(x=_,y=_):  from the parameter values
</li><li>
Points[_;_;_]:  from a variable length sequence of values.
</li></ul>

Note that in 42 these are all just expressions, and represent one or more methods in the named class.
This means that even concepts quite different from numbers, strings and collections may benefit from this syntactic support.
 </p><p id="ModifiersIntro"> </p><h1> Keep control:  Modifiers, kinds of references and objects </h1> <p>

</p><h2> (1/5)Kinds of objects </h2> <p>
In object oriented languages, objects can form complex networks of dependencies by referring to each other using their fields.
The Reachable Object Graph (ROG) of a given object is the set of all objects reachable from it. This also includes the given object.
</p><p>
An object is <span style="color:#ff1111; font-weight: bold;"> mutated </span> if a field in an object in its ROG is <span style="color:#ff1111; font-weight: bold;"> updated </span>.
A <it style="font-style: italic;">mutable object</it> is an object that can be mutated.
The 42 type system is able to ensure that some objects can not be mutated. We call those <it style="font-style: italic;">immutable objects</it>.

All instance of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> are immutable: 
 none of their fields can be updated
or mutated.

Immutable objects are very easy to use but may be inadequate when representing entities whose state can change across time.
</p><p>
Let's now define a mutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>, whose location can be updated:
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location

  mut method
  Void run() 
    this.location(\.add(x=20Num))
  //here \ == this.location()
  }
]]></pre>
There are two new keywords used here: 
<ul><li>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> field is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>.
  This is called a <it style="font-style: italic;">variable field</it>: a field that can be <span style="color:#ff1111; font-weight: bold;"> updated </span> by calling a setter.
  Non-variable fields can not be updated.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[run()]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut method]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
  We have seen <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it>s already, and we have seen methods 
such as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it>
showing no modifier;
they implicitly have the default modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Similarly, whenever a typed does not specify a modifier,
it has the default modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
  <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> methods can mutate the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> object. If you have experience with C++
  you can see the contrast with const methods.
  Immutable (default) methods works only on immutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> objects.
  Later, we will see much more about modifiers.
</li></ul>

</p><p>
As you see, we are using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add]]></span><it style="font-style: bold; color:green;">&#187;</it> method from before.
Also notice that we are using a setter here, where we are providing the first parameter without the argument name.
While this is usual in other languages, in 42 parameters are selected by name.
Sometimes writing down all the parameter names can get tedious.

If the first parameter is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can omit it:
Writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(that=c)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(c)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This works also for methods with multiple parameters, if the first one is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(that=c, x=d)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(c, x=d)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
We can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> by writing, for example: 

<pre class="l42Big"><![CDATA[
mut Animal dog1 = Animal(location=\(x=0\, y=0\))
dog2 = Animal(location=\(x=0\, y=0\)) //type 'mut Animal' inferred for dog2
dog1.run()
]]></pre>

</p><h2> (2/5)Interaction between mutable and immutable </h2> <p>

We now explore some interaction between mutable and immutable objects.
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  mut Points path
  mut method
  Void move() = (
    this.location(\path.left())
    this.#path().removeLeft()
    )
  }
]]></pre>


Here we use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Points path]]></span><it style="font-style: bold; color:green;">&#187;</it> to denote a mutable list of points. Note the absence of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>; this is conceptually similar to a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points * const path;]]></span><it style="font-style: bold; color:green;">&#187;</it> in C++  or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[final Points path;]]></span><it style="font-style: bold; color:green;">&#187;</it> in Java.
To contrast, the declaration <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var Point location]]></span><it style="font-style: bold; color:green;">&#187;</it> is similar to
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point const * location;]]></span><it style="font-style: bold; color:green;">&#187;</it> in C++  or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ImmPoint location;]]></span><it style="font-style: bold; color:green;">&#187;</it> in Java, for an opportune <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ImmPoint]]></span><it style="font-style: bold; color:green;">&#187;</it> class.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> references always refer to mutable objects.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> references always refer to immutable objects.

Fields can be declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> independently from their modifier:
In the code above, you can see that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var Point location]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> field of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> type.
On the other hand, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Points path]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a non-<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> field of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> type.

</p><p>
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move]]></span><it style="font-style: bold; color:green;">&#187;</it>
first use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> setter method to update the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> field,
then uses the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#path()]]></span><it style="font-style: bold; color:green;">&#187;</it>
 <span style="color:#ff1111; font-weight: bold;"> exposer </span> method and 
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[removeLeft()]]></span><it style="font-style: bold; color:green;">&#187;</it> method to mutate the list of points.
Both exposers and getters provide access to the value of a field;
Exposer are used to access the value of mutable fields.
Exposers should be used with care: taking access to parts of a mutable 
state of an object could cause 
spooky action at a distance effects by aliasing.

In general, a programming convention in 42 is that methods starting with # should be used with care.
</p><p>
This code models an animal following a path. It can be used like this.
<pre class="l42Big"><![CDATA[
zero= Point(x=0\, y=0\)
ps1= Points[ \(x=12\, y=20\);\(x=1\, y=2\)]
ps2= Points[ zero;\(x=1\, y=2\)]
dog1= Animal(location=zero, path=ps1)
dog2= Animal(location=zero, path=ps2)
dog1.move()
dog2.move()
]]></pre>

In this code the first dog goes to 12: 20.
The second dog goes to 0: 0. 

This code involves a mutable animal with a mutable field. This is often
a terrible idea, since its behaviour may depend on aliasing:  what happens if two dogs follow the same path?
<pre class="l42Big"><![CDATA[
zero= Point(x=0\, y=0\)
ps= Points[ \(x=12\, y=20\);\(x=1\, y=2\) ]
dog1= Animal(location=zero, path=ps)
dog2= Animal(location=zero, path=ps)
dog1.move()
dog2.move()
]]></pre>
The first dog moves and consumes the path for the second one as well.
That is, the first goes to 12: 20 and the second goes to 1: 2.

This is because <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> is <span style="color:#ff1111; font-weight: bold;"> deeply mutable </span>: a mutable object with mutable fields. 
An amazing amount of bugs are caused by the usage of deep mutability.

Note how we are using the exposer <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#path()]]></span><it style="font-style: bold; color:green;">&#187;</it>
in a safe pattern: only called over the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> receiver, and the reference does not leak out of the method.
The problem here arise since the object was shared to begin with. 

</p><h2> (3/5)Capsules:  Keep aliasing graphs untangled </h2> <p>

In 42 we can change <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> to prevent this aliasing issue.
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  capsule Points path
  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )
  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  }
]]></pre>
Now we use the modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>, this requires the field to be encapsulated with respect to aliasing.
Immutable objects do not influence aliasing, so they are free from aliasing limitations.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>
 modifier <span style="color:#ff1111; font-weight: bold;"> forces </span> the users to provide well encapsulated values,
 and <span style="color:#ff1111; font-weight: bold;"> ensure </span> 
 the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> data is well encapsulated.
</p><p>
To ensure that the mutable path is not exposed, we must use
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation to define a Wemph(capsule mutator): a class method taking in input the value of the capsule field as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This method can then be safely accessed as an instance method with the same name.
The annotation is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> because
capsule mutators also clear all the object based caches. Automatic caching is one of the coolest features of 42 and we will explore it in the next chapter.
</p><p>
With <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule Points path]]></span><it style="font-style: bold; color:green;">&#187;</it>, we are forced to initialize two animals using different paths:
<pre class="l42Big"><![CDATA[
zero= Point(x: 0Num, y: 0Num)
capsule Points ps= Points[\(x=12\, y=20\);\(x=1\, y= 2\)]
dog1= Animal(location=zero, path=ps)
//dog2= Animal(location=zero, path=ps) Does not compile
dog2= Animal(location=zero, path=\[ \(x=12\, y=20\);\(x= 1\, y=2\)])
dog1.move()
dog2.move()
]]></pre>
Where the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ps]]></span><it style="font-style: bold; color:green;">&#187;</it> local binding is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>; 
it can satisfy the Animal.path requirement, but it can be used only once.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[dog2]]></span><it style="font-style: bold; color:green;">&#187;</it>
has to use another capsule. It is okay to just write the object creation in place as is done.
Alternatively, most classes offer a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clone()]]></span><it style="font-style: bold; color:green;">&#187;</it> method,
so in this case we could write

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[dog2= Animal(location: zero, path: dog1.path().clone())]]></span><it style="font-style: bold; color:green;">&#187;</it>


</p><h2> (4/5)Handle mutability </h2> <p>

</p><h2> Immutable objects of any class </h2> <p>

How can we get an immutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>?
When an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> is created using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal(location=_,path=_)]]></span><it style="font-style: bold; color:green;">&#187;</it> we create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>.

In most cases you can promote such reference to immutable/capsule; just make the type of the local binding explicit.
 The type system will take care of the rest.
If a reference can not be safely promoted to immutable/capsule, you may have to use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.clone()]]></span><it style="font-style: bold; color:green;">&#187;</it> method or to refactor your code.
<pre class="l42Big"><![CDATA[
mut Animal dog1= Animal(__) //no promotion here
Animal dog2= Animal(__) //promotion mutable->immutable
dog1.move()
//dog2.move()  //ill-typed, requires a mut Animal
]]></pre>

We will not explain in this tutorial the exact rules for promotion, but the main idea is that if the initialization expression uses local bindings in a controlled/safe way, then promotion can be applied.
For example, a mutable expression using only capsule or immutable references can be promoted to capsule or immutable, as we prefer.

</p><h2> lent and read </h2> <p>
We have seen immutable, mutable, capsule and class.
The are still two modifiers: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
They are hygienic references: they can be read but can not be stored in mutable/capsule/immutable fields.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> is an hygienic mutable reference, allowing mutation but not long term storage.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> is an hygienic read-only reference.
</p><p>
A method with a single mut parameter can still be called using a lent reference in place of it.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> is the common supertype of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>,<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In general, we can 
use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> when we not care about the mutability of an object.
For example, we could add to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>

<pre class="l42Big"><![CDATA[
read method
Bool hasArrived()
  this.path().isEmpty()
]]></pre>
This method can be called on both mutable and immutable animals: 

<pre class="l42Big"><![CDATA[
Debug(dog1.hasArrived())
Debug(dog2.hasArrived())
]]></pre>

</p><h2> (5/5) Summary </h2> <p>
  
</p><h2> Kinds of classes, summary </h2> <p>
  
<ul>
<li>
immutable classes:  have only immutable fields.
It is useful to model mathematical concepts.
It is easy to reason about code using immutable classes,
but some properties of real objects can be better modelled with state mutation.
</li><li>
shallow mutable classes:  have only (variable) fields of immutable or capsule type (or class, as we will see later). 
Reasoning with shallow mutable classes is near as easy as reasoning with immutable ones, and often more natural.
</li><li>
deep mutable classes:  have mutable fields.
Reasoning with deep mutable classes can be very hard.
</li></ul>
  
</p><h2> Modifiers: summary </h2> <p>

<ul>
<li>
immutable:  the default. When you omit the modifier,
 you mean immutable. 
An immutable reference points to an object that is never changing. Its whole reachable object graph never changes and is immutable as well.

</li><li>
mutable:  A mutable reference behaves like a normal reference in Java, C#, C++ , Python and many other languages.
Mutable references require mutable objects and allow mutating the referred object.
</li><li>
capsule:  capsule references are used only once and they guarantee that the whole reachable object graph is reachable only thought that
capsule reference. 
Capsule references provide a structured way to reason over deep mutable objects.

Fields can be annotated capsule, the meaning is that they need to be initialized/updated with capsule variables.
We will discuss more about capsule fields and how they differs from capsule references later.
 
</li><li>
read:  A readable reference can not be used to mutate the referred object; but other mutable references pointing to the same object can mutate it.
Read references can point to both mutable and immutable objects.
It is easy to be confused between read and immutable references.
As a rule of thumb, if you are in doubt about whether to use an immutable or a readable reference,
you probably want an immutable reference.

</li><li>
lent:  a hygienic mutable reference allowing mutation but not storage.
Lent and read are useful to handle in controlled way the state of deep mutable classes;
moreover using lent and read on method parameters 
allows to make explicit what are the method intentions and requirements.
</li><li>

class:  class references denote the class object,
  on methods the meaning is the same of static methods in many languages, but it can consistently be used on parameters/local variables/fields
to encode behaviours similar to dependency injection.


</li></ul>



</p><h2> Keep control, summary </h2> <p>

<ul>
<li>
mutable:  mutable objects can be freely aliased and mutated. They allows for a liberal programming style like we can find in Java/C++/C# or Python.
They can be referred to by capsule, mutable, lent and read references.
</li><li>
immutable: immutable objects 
 can be obtained by promoting instances of mutable classes.
 They
can be referred to only by immutable and read references.

</li><li>
class:  class objects can be accessed from anywhere by using the corresponding class name;
It is also possible to 
store them into (class) local binding.
Some programmers found the fact that class objects are instances of themselves deeply concerning
or disturbing, while for others it is just a good story to tell to break the ice at parties.
</li></ul>
 </p><p id="BasicClasses"> </p><h1> Basic classes </h1> <p>

</p><h2> (1/5) Num </h2> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is a general number type,
implemented as an arbitrary precision rational.
When in doubt of what numeric type to use, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a good first guess.
Some examples of usage: 
<pre class="l42Big"><![CDATA[
little= 123Num
stillLittle= 4567890Num
big= 100000000000000000Num
bigger= 100000000000000000.0001Num
fraction1= Num"1234567/890"
fraction2 == little/stillLittle //holds
Debug(fraction1) //will print '1234567/890'
Debug(Num"12/4") //will print '3'
]]></pre>

Another useful numeric type is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>, for index and index offsets.
It corresponds to sizes and indexes in sequences.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>s are returned by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> methods
and are expected as parameter by indexing methods.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it> represent 32 bit integers with the usual 
but triky modulo arithmetic.

</p><h2> Other numeric types </h2> <p>

AdamTowel offers two other numeric types:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Double]]></span><it style="font-style: bold; color:green;">&#187;</it> (64 bits floating point) and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Math.Long]]></span><it style="font-style: bold; color:green;">&#187;</it> (64 bits integers, rarelly used).


</p><h2> Conversions </h2> <p>
Conversions between various numeric classes must be performed explicitly.

AdamsTowel offers a simple way to convert between numeric classes; all numeric  classes implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Math.Numeric]]></span><it style="font-style: bold; color:green;">&#187;</it>
so that they can be converted in to each other using the the unnamed method. For example we can convert indexes into doubles by writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Double(12I)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This will avoid precision loss as much as possible.

</p><h2> (2/5) Units: An example library </h2> <p>

We now see how to load and use an interesting 42 Library:<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Consider the following code, where the class decorator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to load libraries and embed them in the 
current context, while the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword imports the code from the web. 
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamTowel]
Unit = Load:{reuse [L42.is/Unit]}
Year = Unit(I)
Person = Data:{S name, Year age}
]]></pre>

The library
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>
offers methods to create units out of numeric supports, like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The code above shows how to create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Year]]></span><it style="font-style: bold; color:green;">&#187;</it> unit and use it to represent a person age.

Units can be sum with themselves and multiplied by constants; for example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year+2Year == 5Year]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year *2I == 6Year]]></span><it style="font-style: bold; color:green;">&#187;</it> would hold, but <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year * 2Year]]></span><it style="font-style: bold; color:green;">&#187;</it> would not compile.

Unit could be used to manually define all the units of SI; and a pre-build unit of such reusable code is already provided in the library; we simply need to specify the desired support:

<pre class="l42Big"><![CDATA[
SI = Class:Unit.TraitSI['Support=>Num]
..
res= (6SI.Meter +4SI.Meter)*2Num //20Meter
//wrong1= 6Meter+2Second
//wrong2= 6Meter/2Second
]]></pre>
As you can see, we can sum meters together, and we can use the support for multiplication, but we can not mix different units of measure.

Mathematically you can obtain the support out of the unit by
division; that is, 42 meters divided by 2 meters is  21.
Units also provide method  <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#inner()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
this is just extracting the value of the support from the unit.
This can be convenient during programming but 
does not make a lot of sense mathematically.
Methods like that are required to be used with care, so they start with
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it> to underline that.

The syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[['Support=>Num]]]></span><it style="font-style: bold; color:green;">&#187;</it> maps the class called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Support]]></span><it style="font-style: bold; color:green;">&#187;</it> inside of the library onto the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> defined outse of the library. We will explain later the precise use of such mappings.

<pre class="l42Big"><![CDATA[
Num n1= 42SI.Meter / 2SI.Meter //= 21Num
Num n2= 42SI.Meter.#inner() //= 42Num
]]></pre>

Below you can find some code using units in interesting ways

<pre class="l42Big"><![CDATA[
SI.Meter res1 = (6SI.Meter+4SI.Meter)*2Num //20M

Num res2 = 42SI.Meter/2SI.Meter

Num res3 = (42SI.Meter).#inner()

SI.Velocity fast1 =  42SI.Meter/0.1SI.Second

fast2 = SI.Velocity"420" //equivalent ways to initialize it
fast3 = SI.Velocity"840/2"

distance1 = 60SI.Second * fast1

g = 9.8SI.Acceleration

speedAfter = 10SI.Second * g //98 m/s

t = 10SI.Second

//free fall distance d=(gt^2)/2
distance2 = (g*t*t)/2Num//490 m after 10s free fall

//Newton=Kg*m/s2 = Kg*Acceleration
myRoket = 900SI.Newton
gForceOnMe = 80SI.Kg*g //little less than 800
myLift = myRoket-gForceOnMe
if myLift>0SI.Newton (Debug(S"I can fly"))
myAcc = myLift / 80SI.Kg
reachedHeight = (myAcc*t*t) / 2Num //after 10 sec
]]></pre>


</p><h2> (3/5) Alphanumeric </h2> <p>
In the same way <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Units]]></span><it style="font-style: bold; color:green;">&#187;</it> allows easy creation of
arithmetic classes,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Alphanumeric]]></span><it style="font-style: bold; color:green;">&#187;</it> allows easy creation of alphanumeric classes: 
classes that can be instantiated from a string literal that follow certain 
properties.


<pre class="l42Big"><![CDATA[
Email = S.Alphanumeric:{
  S local //fields
  S domain
  
  class method
  This from(S string)={
    index= string.indexOf(S"@") //works only for simple emails
    if index==I"-1" (error S.ParseError"@ not found")
    local= string.subString(0I to=index) //string slicing
    domain= string.subString(index+1I to=\size) //string slicing
    if domain.contains(S"@") (error S.ParseError"multiple @ found")
    return This(string,local=local,domain=domain)
    } //call the factory with fields plus the original string
  }
...
myEmail = Email"arthur.dent@gmail.com"
myEmail.local()==S"arthur.dent" //holds
myEmail.domain()==S"gmail.com" //holds
myEmail.toS()==S"arthur.dent@gmail.com" //holds
]]></pre>

Note how we can raise an error if the string does not have the shape we expected.
We will see errors/exception in more detail soon.
We can define fields, and compute their values by parsing the string.
While it is suggested to propagate the original string in the factory,
it is not mandatory, for example you could apply some form of normalization, as shown under: 

<pre class="l42Big"><![CDATA[
Email = S.Alphanumeric:{
  S local //fields
  S domain
  
  class method
  This from(S string)={ //google ignore dots anyway
    /*..*/
    local = string.subString(0\ to=index)
      .replace(S"." with=S"")
    /*..*/
    return This(S"%local@%domain", local=local, domain=domain)
    } 
  }
/*..*/
myEmail= Email"arthur.dent@gmail.com"
myEmail.toS()==S"arthurdent@gmail.com" //holds
]]></pre>


</p><h2> (4/5) Enumerations </h2> <p>

Enumerations can be obtained with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Enum]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the following code.

<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{
  North={} East={} South={} Weast={}
  }
/*..*/
Debug(Direction.Vals()) // [North; East; South; Weast]
n = Direction.North()
s = Direction.South()
if n==s (/*..*/)
Debug(n) //North
for d in Direction.Vals() (
  Debug(d) //prints all the directions in order.
  )
n==Direction.Vals(S"North") //holds
]]></pre>

</p><h2> (5/5) Summary </h2> <p>

<ul><li>
We gave a look at the most basic features of 42.
There is rich support to define your own specialized datastructures instead of having to rely on the ones provided by default.
</li><li>
Use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Units]]></span><it style="font-style: bold; color:green;">&#187;</it> 
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.Alphanumeric]]></span><it style="font-style: bold; color:green;">&#187;</it> to give meaning to your constants.
In this way, the type system will help you to use values with the semantics you decided.
Be sure to define all the right base classes to establish a convenient vocabulary
to talk about your problem domain.
</li></ul>
 </p><p id="ErrorsAndExceptions"> </p><h1> Errors and Exceptions: Messages in AdamsTowel </h1> <p>

</p><h2> (1/5)Errors, Messages, Asserts, Guards, .. so much terminology </h2> <p> 
In 42 when something takes an unexpected turn,
you can throw an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it>
This is similar to Java unchecked exceptions.
Every immutable object can be thrown as an error.
While it is possible to thrown informative strings, they do no offer enough
structure to fully take advantage of the error mechanism.
AdamsTowel defines the interface <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>: 
a structured way to provide a certain kind of message to the user.
There are two main kinds of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>s: 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Guard]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While Assertions are useful to observe bugs, the application
logic should not depend on them, since they may change
in unpredictable ways during library evolutions, and can be enabled or disabled.
A guard is guaranteed to be consistent across library evolution thus program logic can depend on them being thrown.

Assertions are the right tool to prevent the code from proceding
out of our designed space. The assertion class called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> 
looks like a road sign
and represent this 
"NO/PROHIBITED/FORBIDDEN" 
feeling.

Assertions are also very convenient to check for pre/post conditions.
The following code show usages of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Pre]]></span><it style="font-style: bold; color:green;">&#187;</it> (for preconditions and, in general, blaming the client of a function)
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> (for postconditions checks in the middle and, in general, blaming the function implementation).

<pre class="l42Big"><![CDATA[
method Nat confirmAnswer(Nat answer) (
  X.Pre[ //preconditions
    answer>0Num; //simplest form
    answer<10000Num msg=S"here with personalized message answer= %answer";
    actual=answer, expected=42Num //do a better error reporting
    ] //in a bunch of assertions, they are all going to be checked/reported together.
  recomputedAnswer=6Num*7Num
  X[//postconditions/checks in the middle
    actual=recomputedAnswer
    expected=42Num
    ]
  X[answer==recomputedAnswer]
  if answer>50Num (//how to just throw error X
    error X""
    )
]]></pre>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> is often used as last case in a sequence of if-return:

<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{
  North={} East={} South={} Weast={}
  }
/*..*/
Direction opposite={
  if d==Direction.North() return Direction.South()
  if d==Direction.South() return Direction.North()
  if d==Direction.East() return Direction.West()
  X[d==Direction.West()] return Direction.East()
  }
]]></pre>
As you can see, since there are only 4 directions, we believe by exclusion that the last case must hold. However, we prefer to
make our assumptions clear and have them checked.


</p><h2> (2/5) Create, throw and capture </h2> <p>

</p><h2> Create and throw </h2> <p>

You can create new kinds of messages using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>
as a decorator:

<pre class="l42Big"><![CDATA[
AnswerNotUnderstood = Message:{[Message.Guard]}
//this is a new kind of message, implementing Guard.
//you can also add methods to your kind of message.
//you can add fields, we will see this more in detail later.
/*..*/
//throwing an error
if this.ohNoNoNOOO() (error AnswerNotUnderstood"Well, too bad")
]]></pre>

You may be surprised that we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it> as a decorator, since it is an interface.
When operators are called on class names directly, they are desugared as a method on one of the class nested classes. For example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message:{..}]]></span><it style="font-style: bold; color:green;">&#187;</it> becomes
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message.ClassOperators.#colon0({..})]]></span><it style="font-style: bold; color:green;">&#187;</it>.
It is very common for interfaces to be usable as decorator creating new code with a meaningful default implelemtation for such an interface.

</p><h2> Capturing errors and exceptions </h2> <p>

In 42 there is no explicit <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[try]]></span><it style="font-style: bold; color:green;">&#187;</it> statement,
but any block of code delimited by round or curly brackets can contain <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<pre class="l42Big"><![CDATA[
res = (
 b1 = CanGoWrong()
 b2 = CanGoWrong() //see b1
 catch error Wrong msg1  S"hi 1" //not see b1, b2
 catch error Message.Guard msg2  S"hi 2" //not see b1, b2
 b3 = CanGoWrong() //can see b1, b2
 b4 = CanGoWrong() //can see b1, b2, b3
 S"hi 3" //can see b1, b2, b3, b4
 )
]]></pre>
The catches above do not see local variables <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b1]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b2]]></span><it style="font-style: bold; color:green;">&#187;</it> because they may be capturing an error raised by the execution of the initialization of such variable.
L42 never exposes uninitialized data.
If a catch is successful, then the result of its catch expression
will be the result of the whole code block.
In this way, blocks with catches behave like conditionals.
That is, The code above can assign to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[res]]></span><it style="font-style: bold; color:green;">&#187;</it> either 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 1"]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 2"]]></span><it style="font-style: bold; color:green;">&#187;</it> or
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 3"]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> Strong error safety </h2> <p>

Errors guarantee a property called strong error safety
(strong exception safety in the Java/C++ terminology)
This means that the body of a catch will observe the same 
state present at the start of the paragraph before.
This is enforced by disallowing catching errors if the paragraph can mutate objects visible in the catch expression.
<br/>
That is, the following code do not compile
<pre class="l42Big"><![CDATA[
p = Person(name=S"Bill" age=23Year)
res = (
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Message.Guard msg2 (
   /*could see p with 23 or 24 years*/)
 p
 )
]]></pre>

While the following is accepted.

<pre class="l42Big"><![CDATA[
res = (
 p = Person(name=S"Bill" age=23Year)
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Message.Guard msg2 (/*can not see p*/)
 p
 )
]]></pre>

</p><h2> (3/5) Exceptions and errors </h2> <p>

Exceptions are like checked exceptions in java.
As with errors, every immutable object can be thrown as an exception.
You can just write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it> while throwing or capturing. When capturing, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it> is the default, so you can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch Foo x]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch exception Foo x]]></span><it style="font-style: bold; color:green;">&#187;</it>
Exceptions represent expected, documented and reliable behaviour,
they are just another way to express control flow.
They are useful to characterize multiple outcomes of an operation,
where is important to prevent the programmer from forgetting about
the many possible outcome and focusing only on their preferred one.
Exceptions are checked, so methods leaking exceptions have to
mention it in their header, as in the following.
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
method
S promptUser(S text)[CancelPressed] = {
  /*implementation to open a text dialog*/
  }
]]></pre>
The programmer using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[promptUser]]></span><it style="font-style: bold; color:green;">&#187;</it> has to handle 
the possibility that the cancel button was pressed.
However, L42 supports exception inference; to simply propagate all the exceptions leaked out by the other methods called in a method body, you can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[_]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown below:
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
method
S promptUser(S text)[_] = {
  /*implementation to open a text dialog*/
  }
]]></pre>
Exceptions does not enforce strong exception safety as errors do,
so they can be used more flexibly, and since they are documented in
the types, we can take their existence in account while writing imperative programs.
</p><p>
Often, the programmer wants to just turn exceptions into errors.
While this can be done manually, L42 offers a convenient syntax: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoops]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<pre class="l42Big"><![CDATA[
//long version
Res foo = {
  return DoStuff()
  catch FileNotFound fnf 
    error fnf
  catch FileCorrupted fc
    error fc
  }

//short version
Res foo = {
  return DoStuff()
  whoops FileNotFound, FileCorrupted
  }
]]></pre>

The two snippets of code behave near identically: 
in the second the exceptions are also notified of the 
position in the code where they are <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoopsed]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is conceptually similar to the very common Java patten to wrap checked exceptions into uncheced ones.
<br/>

As we shown before,  we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> to mark branches of code
that the programmer believes would never be executed.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>, thus code capturing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> is unreliable: as explained before, AdamTowel programmers are free
to change when and how assertion violations are detected.
In particular, the programmer may recognize that
such branch could be actually executed, and thus replace the error with correct behaviour.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>ions should not be thrown as exceptions, but only as errors.


</p><h2> (4/5) Return </h2> <p>

Return, as we have seen, can be used to exit from the inner
most level of curly brackets.
Also curly brackets can have catches.
In this case, all catch bodies must ends with
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it> or
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/> Let's see some examples: 
<pre class="l42Big"><![CDATA[
{
  x = DoStuff()
  catch Stuff e1
    return void //just swallow the exception (this block return 'Void')
  catch Message.Guard e2 (
    obj.doSideEffect()
    return void //do something and return
    )
  catch error Message e3
    error X"not supposed to happen"
  (//example of a nested block
    y = DoStuff(x)
    return y
    whoops Message.Guard
    )
  }  
]]></pre>

Moreover, curly brackets/return can be used
to provide a different result if some computation fails: 

<pre class="l42Big"><![CDATA[
res = {
  return PlanA()
  catch error Message.Guard x
    return PlanB()
  }
]]></pre>

</p><h2> Return looks similar to error/exception </h2> <p>
Return is actually another thing that can be thrown and captured.
While only immutable values can be thrown as errors/exceptions,
return can throw any kind of value, but returns can not flow
outside of the scope of a method.
Hold your head before it explodes, but curly brackets are just a syntactic sugar
 to capture returns; these two snippets of code are equivalent: 
<div class= "compare">
<pre class="l42Big"><![CDATA[
N res = {
  
  if bla (return e1)
  return e2
  


  
  }
]]></pre>
<pre class="l42Big"><![CDATA[
N res = (
  Void unused= (
    if bla ( return e1 )
    return e2
    )
  catch return N x ( x )
  error void //this line is never executed
  )
]]></pre>
</div>
</p><p>
Depending on how your brain works,
knowing the desugaring of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{..return..}]]></span><it style="font-style: bold; color:green;">&#187;</it>
can help you to use return better and understand why you can omit 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{..return..}]]></span><it style="font-style: bold; color:green;">&#187;</it> for simple method bodies, and why you can
write multiple groups of curly brackets and have local returns.
Or it may just be very confusing. If you are in the second group, just
never ever write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch return]]></span><it style="font-style: bold; color:green;">&#187;</it> explicitly and continue
your 42 experience ignoring the issue.


</p><h2> (5/5) Errors, exceptions and return, summary </h2> <p>
<ul><li>
Always detect if your code misbehaves, and 
terminate it with an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>
</li><li>
Whenever something out of your
control happen, Give it a name and throw it as an error, as in
<pre class="l42Big"><![CDATA[
NameOfIssue = Message:{[Message.Guard]}
/*...*/
if /*..*/ ( error NameOfIssue"more info" )
]]></pre>
It just take 2 lines, and will make debugging your code so much 
easier.
</li><li>
Use errors intensivelly, 
but use exceptions sparsely: they are needed only in few 
cases, mostly when designing public libraries.
</li><li>
To convert exception into errors or other exceptions, use the convenient short
syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoops T1,..,Tn""]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
Instead of manually writing long lists of leaked exceptions, just use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
It is sometimes possible to write elegant and correct code
that is not covered in layers upon layers of error/exception checking,
but often is not possible or not convenient.
Up to half of good 42 code will be composed of
just error/exception handling/lifting and management.
Do not be scared of turning your code in it's own policemen.
</li></ul>
 </p><p id="Caching"> </p><h1> Caching </h1> <p>
</p><h2> (1/5) Normalization </h2> <p>
One of the big advantages of deeply immutable objects is that two structurally identical objects are referentially transparent, that is, you can not distinguish if they are represented in memory by a single object or two.
This means that it is possible to reuse the same objects to save memory. While in other languages the programmer would have to implement some ad. hoc. support to reuse objects, in L42 this is supported directly by the language, in a process called <span style="color:#ff1111; font-weight: bold;"> normalization </span>.
An immutable object can be turned into its normalized version using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.norm()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Person = Data:{S name}
..
var bob1 = Person(S"Bob")//one bob in memory
var bob2 = Person(S"Bob")//two bobs in memory
bob1:=bob1.norm()
bob2:=bob2.norm()//most likely now bob2 referes to
//the same object of bob1.
//The object originally pointed by bob2 can now be
//garbage collected.
bob2:=bob2.norm()//repeating normalization has no effect.
//The second calls to norm is as fast as a field access.
]]></pre>
As you can see, objects are born not normalized and can be normalized manually by the programmer.
Normalization is cheap but it is not free, so it is not convenient to apply it on short lived objects.
The programmer can express that all objects of a class are normalized during creation by passing parameters to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
Person = Data('This,autoNorm=\.true()):{S name}
..
var bob1 = Person(S"Bob")//one bob in memory
var bob2 = Person(S"Bob")//two bobs in memory
bob2:=bob2.norm()//no-op, bob2 was already normalized
]]></pre>
Normalizing requires to check if another structurally equivalent object has ever been normalized. This also support circular objects and normalizes all the sub objects.
Consider the following richer example:
<pre class="l42Big"><![CDATA[
Person = Data:{S name}
Dog = Data:{S name, Person owner}
..
bob1 = Person(S"Bob")//one bob in memory
bob2 = Person(S"Bob")//two bobs in memory
dog1 = Dog(S"Grunthos", bob1)
dog2 = Dog(S"Agrajag", bob2)
//dog1.owner() is a different object of dog2.owner()
//abait there are structurally identical and we can
//not tell them apart using L42.
dog1.norm()//note: we do not reassign dog1
dog2.norm()
//dog1 and dog 2 are different objects, but
//dog1.owner() is now the same object of dog2.owner()
//bob1 and bob2 are still two different objects.
]]></pre>
The logic needed for normalization is the same needed to check if two arbitrary objects are structurally equal, to print an object to a readable string and to clone objects.
Thus data allows for all of those operations indirectly relying on normalization.
Those are all operations requiring to scan the whole ROG of the object, so the cost of normalization is acceptable in context.

</p><h2> (2/5) Lazy Caching </h2> <p>

Some methods may take a long time to compute, but the are deterministic, and thus we could cache the result and reuse it many times.
A typical example is fibonacci:
<pre class="l42Big"><![CDATA[
class method Num slowFibo(Num n) = {
  if n==0Num || n==1Num (return n)
  return This.slowFibo(n=n-1\)+This.slowFibo(n=n-2\)
  }
]]></pre>
This fibonacci implementation would take a very long time to run, since it would require recomputing the same
results an exponential amount of times.

This tweaked implementation relying on caching is much faster.
<pre class="l42Big"><![CDATA[
ComputeFibo=Data:{
  Num that
  @Cache.Lazy method Num () = {
    n=this.that()
    if n==0Num ||n==1Num ( return n )
    This fibo1=This(n-1Num)//a 'computation object'
    return fibo1()+This(n-2Num)()
    }
  }
//...
//usage example
ComputeFibo(42\)() == 267914296Num
]]></pre>
As you can see, instead of a method with parameters we can declare a class with fields and an unnamed method doing the actual computation.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> is an annotation recognized by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> that works only on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> methods with no arguments and with an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> result.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ComputeFibo fibo1]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <span style="color:#ff1111; font-weight: bold;"> computation object </span>: an imm object whose only goal is to support one (or more) computationally intense methods.
Thanks to normalization, the cache of computation objects is centrally stored, and thus recursive calls computing fibonacci will be able to reuse the cache from other objects.
That is, the method result is cached on the normalized version of the receiver. In this way, 
all the redundant fibonacci calls are avoided.

</p><p>
As you can see, the caching is is completely handled by the language and is not connected with the specific algorithm. This pattern is general enough to support any method from immutable data to an immutable result.

</p><h2> (3/5) Automatic parallelism </h2> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to cache the result of methods after they have been called the first time.
However, why wait for the method to be called?
once the receiver object is created, the method could be computed <span style="color:#ff1111; font-weight: bold;"> eagerly </span> in a separed worker, so that when we call the method, we get the result without any wait at all.
That is, if we use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> we can get automatic parallelism: the language will handle a set of parallel workers to execute such method bodies.

</p><p>
An important consideration here is that both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> are unobservable; that is, the observed result of the code is not impacted by lazy or eager cache.

Consider the following code:

<pre class="l42Big"><![CDATA[
Task = Data:{ //Tasks are also computation objects
  S text
  @Cache.Eager method Bool isPolite() = ( .. )
  @Cache.Eager method Bool isGrammatical() = ( .. )
  }
Tasks = Collection.list(Task)

Main=(
  tasks=Tasks[
    \(text=S"..");
    ..
    \(text=S"..");
    ]
  for t in tasks (
    Debug( t.isPolite() )
    )
  )
]]></pre>
Here we declare a Task object with a string field and two eager methods: one will check if the text in the string is polite and another will check if the string is grammatically correct.
This can take quite a while. By using eager methods, it is sufficient to just create the objects to start those computations in parallel.
When we need the results, we can just iterate on those task objects and call the methods.
Objects with eager methods are automatically normed during creation, as if we used 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data('This,autoNorm=\.true())]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.

As you can see, parallelism and caching are just two sides of the same coin.

</p><h2> (4/5) Invariants and derived fields </h2> <p>
We have seen that cached behaviour can be computed lazily or eagerly on immutable objects.
But we can bring caching even earlier and compute some behaviour <span style="color:#ff1111; font-weight: bold;"> at the same time </span> of the object creation.
This allows to encode derived fields: fields whose value must depend from the other object fields.
Consider the following example:
<pre class="l42Big"><![CDATA[
Point = Data:{//not ok, the tree arg factory still exists
  Double x
  Double y
  Double distanceFromOrigin
  //should always be (x^2+y^2)^0.5
  class method This (Double x, Double y) = \(
    x=x
    y=y
    distanceFromOrigin=((x*x)+(y*y)).pow(exp=\"0.5")
    )
  }
]]></pre>
Where the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> has 3 fields, but the value of the third one should depend from the other two.
In 42 the code above would simply define a class with three unrelated fields, and while we are offering a factory that conveniently takes x and y and initialize the third field with 
the computed value, the user could easy create invalid instances by calling the factory method with three arguments.
As we will see later, in 42 we can prevent this from happening by making such method private.
However, we would still be able to create an invalid <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> inside of other <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
Ideally, we would like to truly have only two fields, and have the third one as a precomputed derived data.

In 42, we can encode such concept using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
Point = Data:{
  Double x
  Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  }
]]></pre>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> class defined above has a single factory method taking just <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it>. In this way there is no need to have multiple ways to build the object and then hide the dangerous ones after the fact.

The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distanceFromOrigin(x,y)]]></span><it style="font-style: bold; color:green;">&#187;</it> is computed when a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> object is created.
Moreover, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> adds a method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read method Double distanceFromOrigin()]]></span><it style="font-style: bold; color:green;">&#187;</it>, allowing to read the computed/cached value as if it were a field. Note how the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it>
method is turned into a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> method.

If the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distanceFromOrigin(x,y)]]></span><it style="font-style: bold; color:green;">&#187;</it> where to leak an error, such error would be propagated out as it would happen if the method were manually called during object construction.

This means that any time you receive a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>, it has a valid distance.
We can leverage on this behaviour to encode class invariants:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> return type
designed to simply throw error if the state is incorrect.
For example, consider this updated version of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
Point = Data:{
  Double x
  Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  @Cache.Now class method Void invariant(Double x, Double y) = 
    if x<0Double || y<0Double error X"""%
      | Invalid state:
      | x = %x
      | y = %y
      """
  }
]]></pre>

Now, every time user code receives a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>, they can rely on the fact that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> are positive.

</p><h2> (5/5) Summary </h2> <p>
In 42 immutable objects can be normalized in order to save memory space.
This works also on circular object graphs and relies on a variation of DFA normalization.
As a special case, objects without fields (immutable or not) are always represented in memory as a single object.
Cached informations are attached to the normalized version of objects, thus making it possible to recover the cache simply by rebuilding a structurally identical object.

There are tree kinds of caching, depending on the time the caching behaviour activates:

<ul><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value when the annotated method is first called.
It works on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> no-args methods.
An obvious workaround for the no-args limitation is to define computation objects; this also works well with normalization: computation objects will remember the cache of any structurally equivalent object.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value in a separate parallel worker, starting when the object is created. It only works on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> no-args methods of classes whose objects are all deeply immutable.
Those classes will automatically normalize their instances upon creation.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value during object construction.
Since the object does not exists yet, the annotation is not placed on an instance method, but on a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> method whose parameters represent the needed object fields.
This annotation does influence the observable behaviour: if an error is raised computing the cache, the error is leaked during object construction and not while trying to observe the cached value.
This, in turn, allows to encode class invariants and to provide a static guarantee that users of a class can rely upon.
</li></ul>
 </p><p id="CachingMut"> </p><h1> Caching on Mutable objects </h1> <p>
</p><h2> (1/5) Cache invalidation </h2> <p>
The main advantage of caching method of immutable objects is that the cache is always valid.
L42 allows to cache also methods of mutable objects, and discovers on its own when the cache needs to be invalidated.
Consider this trivial variation of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> example above where the fields can be updated:

<pre class="l42Big"><![CDATA[
Point = Data:{
  var Double x
  var Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  @Cache.Now class method Void invariant(Double x, Double y) = 
    if x<0Double || y<0Double error X".."
  }
]]></pre>
When a setter for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> is invoked, then two <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods are recomputed.

In other programming languages, this behaviour can be encoded by
making the fields private and customizing the implementations of the setters to recompute the distance when needed. This pattern can grow very complex very fast.
L42 guarantees that a cached value is always structurally equivalent to the value that would be returned by calling the method again.
Moreover, for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> L42 also guarantees that such computation would terminate without errors.
Thus, when <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> is used to emulate invariants, those invariants are guaranteed to hold for all observable objects, that is, all objects where the annotated method could possibly be called.

This is possible thanks to the strong L42 type system, and we believe this property can not be broken.
That is, we believe this property to hold even in the presence of exceptions, errors, aliasing, input output and non deterministic behaviour.
It is possible to make L42 work together with Java or even (possibly broken) native code, and we believe our property will hold also in those cases.

</p><h2> (2/5) Deeply mutable objects </h2> <p>
As discussed above, a deeply mutable object is a mutable object with some mutable fields.
Also deeply mutable objects can support <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, but such mutable state needs to be <span style="color:#ff1111; font-weight: bold;"> encapsulated </span>, as we have seen before for the class
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  capsule Points path

  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )

  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  }
]]></pre>

The field <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule Points path]]></span><it style="font-style: bold; color:green;">&#187;</it> is an encapsulated mutable field.
It can be accessed as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> by doing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.path()]]></span><it style="font-style: bold; color:green;">&#187;</it>, but can not be directly accessed as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
However, we can write <span style="color:#ff1111; font-weight: bold;"> capsule mutator </span> methods by using 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Similarly to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, a class method can be annotated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> and can
take parameters representing the object fields.
In addition, more parameters can be present encoding extra arguments.
To clarify, consider this richer example, where our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> has an invariant and another capsule mutator method:

<pre class="l42Big"><![CDATA[
Point = Data:{ Double x, Double y
  method Double distance(Point that) = 3Double
  }

Points = Collection.list(Point)

Animal = Data:{
  var Point location
  capsule Points path

  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )

  mut method
  Void trim() = 
    this.removeFarthest(location=\location, distance=3Double)

  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  
  @Cache.Clear class method
  Void removeFarthest(mut Points path, Point location, Double distance) = (
    var maxD=distance
    var maxI=I"-1"
    for p in path, i in Range(path.size()) (
      currentD = location.distance(p)
      if currentD>maxD (
        maxI:=i
        maxD:=currentD
        )
      )
    if maxI!=I"-1" path.remove(maxI)
    )

  @Cache.Now class method
  Void invariant(read Points path, Point location) = 
    if path.contains(location) error X"..."
  }
]]></pre>
We added a method to remove the farthest away point if it is over a certain distance.
As you can see, the parameters <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[path]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> corresponds to fields, while
the parameter <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distance]]></span><it style="font-style: bold; color:green;">&#187;</it> is extra needed information.
When we call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.removeFarthest(distance=3\)]]></span><it style="font-style: bold; color:green;">&#187;</it> we pass only <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distance]]></span><it style="font-style: bold; color:green;">&#187;</it>; the other parameters are passed automatically.
As an invariant, here we require that the current location is not in the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[path]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This code, in the current form, has a bug; can you spot it?
Look carefully to the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move()]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )
]]></pre>
Here we first set up the location, then we remove it from the path.
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move()]]></span><it style="font-style: bold; color:green;">&#187;</it> recomputes the invariant twice: one after the field setter 
and one after the call to the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
This first check is going to fail, since the leftmost element of the path has not being removed yet.
In this case we can solve the problem by swapping the lines:

<pre class="l42Big"><![CDATA[
  mut method
  Void move() = (
    left=this.path().left()
    this.removeLeftPath()
    this.location(left)
    )
]]></pre>

However, this kind of solution does not scales in the general case; next we will see a programming pattern allowing to delay in a controlled way the invariant checks, or more in general, the recomputation of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Every method annotated as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> can instead be annotated as 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to encode conventional caching on mutable datastructures and automatic cache invalidation:
The operations are computed when they are first asked, and the cache is automatically invalidated when a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> method terminates.
Again, we think that at all times <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> has the same semantic as recomputing the value, but with a different performance.
This annotation is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> because it produces a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> method, while 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> works on immutable ones.

Cache invalidation is considered one of the great challenges in writing correct programs; L42 can handle it correctly and automatically.
However, there is a cost: you have to encode the algorithm so that the type system accepts your code and that the caching annotations can be applied.

</p><h2> (3/5) Box patten </h2> <p>

As we have seen, in order to write well encapsulated mutable objects we need to designed them well, using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> to initialize the mutable data, using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> to mutate such state and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> for the invariant.
However, we can also program a naive deeply mutable object and boxit up as a second step.
This can require a little more code, but it is more intuitive, and works very well for arbitrarly complex cases.
Consider the following code:

<pre class="l42Big"><![CDATA[
Bike = Data:{
  var mut Wheel front
  var mut Wheel back
  var mut Seat seat
  var mut Chain chain
  mut method Void nail() = this.#front().addHole()
  mut method Void rain(Second time) = this.#chain().addRust(time)
  read method Void invariant() = X[
    this.front().size()==this.back().size();
    this.seat().isConfortable();
    ]    
  }
//components can mutate (get damaged)
//and be updated (replaced with new ones)
]]></pre>
As you can see, the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> is a deeply mutable class, design with no attention to
correctness: if the programmer is not carefully, the same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Weel]]></span><it style="font-style: bold; color:green;">&#187;</it> 
may end up used for multiple bikes at the same time.
Also, the method called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[invariant]]></span><it style="font-style: bold; color:green;">&#187;</it> only represents a programmer intention, but it is not enforced in any way and thus it could be silently broken.

We can easly create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it> class containing and encapsulating, such a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
BikeBox = Data:{
  capsule Bike box
  
  @Cache.Now class method
  Void invariant(read Bike box) = box.invariant()
  
  @Cache.Clear class method
  Void nail(mut Bike box) = box.nail()
  
  @Cache.Clear class method
  Void nail(mut Bike box, Second time) = box.nail(time=time)

  @Cache.Clear class method
  Void front(mut Bike box, capsule Wheel that) = box.front(that)
  }
..
//user code
b = BikeBox(box=\(front=\(..) back=\(..) seat=\(..) chain=\(..)))
b.nail()
//b.box().nail()/ ill-typed
Debug(b.box().front())//will display the unfortunate wheel
b.front(\(..)) //looks just like a normal setter, but acts on the internal object
]]></pre>

As you can see, no matter how complex some class code is, we can simply wrap it into a box and apply <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> on top of it.
In this way we end up with two types:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>, that does not offers any guarantee,
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it>, ensuring the invariant and that the state is well encapsulated.
The methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.nail()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.rail(time)]]></span><it style="font-style: bold; color:green;">&#187;</it>
and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.front(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>
 will check for the invariant exactly one time, at the end of their execution.
Following this pattern, the programmer can perform an arbitrary long computation before the checks are triggered.

When writing other classes we can chose to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>
or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it> depending on the specific details of our code.
If we chose to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> as a field of another class, we can still check 
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> invariant inside the invariant of the composite class:
<pre class="l42Big"><![CDATA[
FamilyGarage = Data:{
  mut Bike daddyBike
  mut Bike mummyBike
  mut Trike timmyBike  
  ..
  read method Void invariant() = X[
    this.daddyBike().invariant();
    this.mummyBike().invariant();
    this.timmyBike().invariant();
    ]
  }
FamilyGarageBox = Data:{
  capsule FamiliyGarage box

  @Cache.Now class method
  Void invariant(read FamilyGarage box) = box.invariant()  
  }
]]></pre>

</p><h2> (4/5) Controlling the ROG shape </h2> <p>

An attentive reader may have notice that we would allow for fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right]]></span><it style="font-style: bold; color:green;">&#187;</it> to point to the
 same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Wheel]]></span><it style="font-style: bold; color:green;">&#187;</it> object.
A Java programmer may be tempted to just add 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.front()!=this.back();]]></span><it style="font-style: bold; color:green;">&#187;</it> in the invariant,
but this would just use the user defined <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[!=]]></span><it style="font-style: bold; color:green;">&#187;</it> operator, that
on classes created using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is likely to check for structural equality instead of pointer equality.
AdamTowel offers <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[System.mutReferenceEquality(a and=b)]]></span><it style="font-style: bold; color:green;">&#187;</it> to check for reference equality, but 
this method only works for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> objects.
The wheels are mut objects indeed, but the invariant method takes a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> receiver, thus we can only see the wheels as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this case, the inability of using pointer equality is actully a good thing, since it does not correspond to what we really wanted to express: What if the two weels are different objects but they share the same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Tire]]></span><it style="font-style: bold; color:green;">&#187;</it> object?
What we want is to check that the mutable objects are not aliased in phisically unreasonable ways.
More in general, we want to ensure a tree shape of the mutable part of the object graph.

In 42 we can create classes where all the instances are guaranteed to follow this property, by making all fields either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> of a class recursvelly respecting this property.
However, according to what we have seen up to now, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> fields can only be mutated by defining <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> methods, and those methods will be unable to mutate any other 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> field.
Consider the following code:

<pre class="l42Big"><![CDATA[
Tire = Data:{var Num pressure}
Wheel = Data:{var mut Tire tire}
Seat = Data:{var S description}
Chain = Data:{ var Num damage 
  mut method Void onWheel(lent Wheel that) = (
    lent Tire t=that.#tire()
    t.pressure(\pressure-1\)
    this.damage(\damage+1\)
    )
  }
]]></pre>

Here the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Chain]]></span><it style="font-style: bold; color:green;">&#187;</it> can rub onto the wheel damaging it.
The parameter of method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it> is
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it>. This guarantees that the object graphs of the chain and the wheel will 
not be mangled together by the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Can we assemble a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> while being able to both use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it> and guaranteeing the tree structure?
The trick is to declare <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> exposers manually:
<pre class="l42Big"><![CDATA[
Bike = Data:{
  var capsule Wheel front
  var capsule Wheel back
  lent method lent Wheel #back() //lent exposer
  var capsule Seat seat
  var capsule Chain chain
  lent method lent Chain #chain()//lent exposer
  mut method Void chainOnWheel() = 
    this.#chain().onWheel(this.#back())
    
  }
BikeBox = Data:{..}//as before
]]></pre>
That is, by declaring lent exposers manually we gain the possibility of writing methos mutating the capsule fields without using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> pattern.
In exchange for this extra flexibility, the class can not use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> directly.
However, we can still use through the box pattern, as show before.

</p><h2> (5/5) Summary </h2> <p>

Caching and representation invariants can be applied also to mutable objects.
Proving properties on mutable objects requieres to know and apply varius patterns.
Historically, in softwere verification, representation invariants where small 
units of code, mostly focusing on the direct content of the fields and mostly relying on either pointer equality or the binary value of primitive datatypes, where the invariants could be purposly broken while still being able to observe the broken object.
Nothing of this is possible in 42; in particular, 42 guarantees that broken object can not be observed.
The box patterns allows to divide the value in two types: the one with an enforced invariant and the raw object state, recovering the flexibility of temporarelly open invariants wihtout any of the drawbacks.

Note how avoiding pointer equality tests is required when normalization is took into account.
Consider the example of a list whose invariant requires all object to  pointer unique.
A valid list of such type may contain two structurally equal but not pointer equal objects.
If such a list becomed immutable and was normalized, those two objects would become point equals, and the invariant would be broken by normalization.
 </p><p id="InterfacesAndData"> </p><h1> Interfaces, subtypes and matching </h1> <p>

</p><h2> (1/5)Interfaces, Basis and Details </h2> <p>
</p><h2> Interfaces Basis </h2> <p>
In 42 interfaces are quite similar to interfaces in other OO languages.
There are however a couple of important differences.

</p><p>

While implementing an interface method, you can avoid the
type signature.
For example, in the following code, to implement <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape.draw(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> inside
of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it>, the types <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Canvas]]></span><it style="font-style: bold; color:green;">&#187;</it> are not repeated.
<pre class="l42Big"><![CDATA[
Shape = {interface
  method Void draw(mut Canvas that)
  }
Square = {[Shape]
  method draw(that) = /*..*/
  }
]]></pre>

In 42, we say that the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[draw(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> 
implemented in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it>
<span style="color:#ff1111; font-weight: bold;"> is declared by </span>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Each method is declared in a single point. 
Methods can be 
defined (that is, declared and implemented)
in the class itself;
or declared in a (transitively) implemented interface and
then just implemented.
This means that a class can not 
satisfy multiple interfaces declaring methods
with the same name.
For example, this code is ill-typed: 
<pre class="l42Big"><![CDATA[
Card = {interface
  method Num draw() //the value of the drawn card
  }
Gun = {interface
  method Num draw() //the time it takes to drawn the gun
  }
Wrong = {[Card,Gun] //not allowed
  }
]]></pre>


Note that would be bad 42 code anyway, you should define an enumeration (or an alphanumeric)
for your cards and use a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Second]]></span><it style="font-style: bold; color:green;">&#187;</it> unit of measure
for the time.

</p><p>

However, interface diamond is allowed, that is, the following code is correct: 
<pre class="l42Big"><![CDATA[
Shape = {interface
  method Void draw(mut Canvas that)
  }
Animal = {interface [Shape]
  method Meter run()
  }
Noisy = {interface [Shape]
  method Void play(mut Audio that)
  }
LoudCat = {[Animal, Noisy]
  method draw(that) = /*..*/
  method run() = /*..*/
  method play(that) = /*..*/
  }
]]></pre>

</p><p>

You can refine the return type of an interface method, by repeating the full type signature with the desired return type.
<pre class="l42Big"><![CDATA[
Monster = {interface
  method Monster spawnMinion()
  }
BigMonster = {[Monster]
  method BigMonster spawnMinion() = /*..*/
  }
]]></pre>

However, the parameter types can not be refined.

</p><h2> (2/5) Interfaces and class methods </h2> <p>

Interface methods in 42 are all abstract, that is, without bodies.
A version of the body will be provided by all classes implementing the interface.
<span style="color:#ff1111; font-weight: bold;"> This also include class methods. </span>
<br/>
For example, consider the following code: 
<pre class="l42Big"><![CDATA[
Shape = {interface
  class method 
  Num numberOfSides()
  class method
  This newShape(Color that)
  method
  Void draw(Canvas that)
  }

Square = {[Shape]
  Color color
  method numberOfSides() = //class method implemented
    4Num
  method newShape(that) //class method implemented
    This(color=that)
  method draw(that) = //immutable method implemented
    /*..*/
  }
/*..*/
class Shape kindOfShape= Square
kindOfShape.numberOfSides()==4Num //holds
Shape s= kindOfShape.newShape(Color.red())
]]></pre>

The pattern in the code above allows to encode the abstract factory 
pattern in a much simpler way: 
the binding <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[kindOfShape]]></span><it style="font-style: bold; color:green;">&#187;</it> serve the role of
an instance of an abstract factory, and can create instances of
a specific kind of shape.
</p><p>

In 42 interfaces can not have 
implemented class methods.
Sometimes there is the need of semantically associate some behaviour with an interface.
For example we could check intersections between shapes using
the draw method.
What we would need, is a traditional (non dynamically dispatched) static method.
In 42, static methods are just nested classes with a single class method with the empty name. In 42 adding new classes is very common, so do not be scared of adding a new class just to host a method.

<br/>
For example
<pre class="l42Big"><![CDATA[
Shape = {interface
  /*..*/
  Intersect = {class method
    Bool (Shape left, Shape right) = 
      /*..*/
    }
  }
]]></pre>

</p><h2> (3/5)Subtyping </h2> <p>
Dynamic dispatch is the most important feature of Object oriented languages.
Subtiping is the main feature supporting dynamic dispach; for example 
we can iterate over a list of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[draw]]></span><it style="font-style: bold; color:green;">&#187;</it> them without the need to consider case by case all the possible kinds of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it>.
 
Note how modifiers (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>,..)) offers subtyping but not dynamic dispatch.

There is a fundamental compromise between interfaces and classes:
<ul><li>
Interfaces allows client code to be implicitly parametric on the behaviour of individual objects.
The client code can take no assumption on the specific implementation of the interface.
</li><li>
Classes allows client code to rely on their invariant.
The user code is forced to pass only a specific kind of implementation.
</li></ul>


</p><h2> (4/5)Matching </h2> <p>

It is possible to inspect the runtime type of object by using matching.
We will now provide varius examples of matching and explain the behaviour.

<pre class="l42Big"><![CDATA[
method Square example1(Shape s1, Shape s2) = {
  if s1 <: Square ( return x )//s1 is of type Square in the if body
  if Square y = s1.bar() ( return y ) //if bar returns a Square, we call it y
  if x<: HasToS, z<:Triangle ( return z.with(x.toS()) )
  error X""
  }
]]></pre> 
We can use an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if]]></span><it style="font-style: bold; color:green;">&#187;</it> to check for the type of a local binding or an expression.
We can also check for more then one local binding at a time.
This <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if-return]]></span><it style="font-style: bold; color:green;">&#187;</it> pattern allows to write complex dispatch in a compact way.
The syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[<:]]></span><it style="font-style: bold; color:green;">&#187;</it> can also be used in expressions when the type system is unable to figure out
the type, usually because some information will be generated by a decorator on a later stage, thus sometimes we may have to write code like the following
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.bla()<:mut Foo.baz()]]></span><it style="font-style: bold; color:green;">&#187;</it>: the method 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[baz()]]></span><it style="font-style: bold; color:green;">&#187;</it> is called on the result of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.bla()]]></span><it style="font-style: bold; color:green;">&#187;</it>, that we expect to return a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Foo]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if _ <: _]]></span><it style="font-style: bold; color:green;">&#187;</it> will run the check at run time,
the cast is checked at compile time, as if we wrote 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(mut Foo tmp = a.bla(), tmp.baz())]]></span><it style="font-style: bold; color:green;">&#187;</it>

<br/>
The code below
<pre class="l42Big"><![CDATA[
method Point example2(Point left,Point right) = {
  (x1,y1) = left
  (x2,y2) = right
  return Point(x=x1+x2,y=y1+y2)  
  }
]]></pre>
is equivalent to
<pre class="l42Big"><![CDATA[
method Point example2(Point left,Point right) = {
  x1=left.x()
  y1=left.y()
  x2=right.x()
  y2=right.y()
  return Point(x=x1+x2,y=y1+y2)  
  }
]]></pre>
That is: we can match out the result of any no-arg method into a variable with the same name, plus an optional numeric index.
This syntax can also be used inside of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is often done for fields. Of course it works also to extract a sigle field:

<pre class="l42Big"><![CDATA[
method Square example3(Shapes ss) = {
  (size) = ss //extracts the 'size' from ss
  (I size1) = ss//same but with explicit type
  if (Square left) = ss ( return left )//matches if the leftmost element of the list is a Square
  if (Triangle left, Square right) = ss ( return right )//matches if the leftmost and the
    //rightmost elements are a Triangle and a Square.
  if Circle(Point center) = ss.left() ( return center.squareAround() ) //matches if the leftmost
    //is a Circle and the method center() returns a Point. Both checks are dynamic.
  error X""
  }
]]></pre>

As we have seen, matches are a form of syntactic sugar allowing to be more compact when extracting subcomponents and taking decisions about their dynamic types.

</p><h2> (5/5)Interfaces, subtypes and matching, summary </h2> <p>

Interfaces in 42 serves the same role that they serve in other languages,
with a little bit of a twist in the details.

The big news is that Decorators (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> in our examples) can
provide the boilerplate implementations for free.
This is much more powerful than traits, multiple inheritance or
Java 8 default methods, since the implementation can be generated by examining the class.
 
<br/>
In the right conditions, matching is a useful tool to reduce code size and complexity.
However, dynamic dispach is still the preferred option in the general case: we can only match on a finite
amount of pre-defined cases, thus matching is fragile with respect to code evolution.
 </p><p id="Sequences"> </p><h1> Collection: list, map, set, optional and their operations </h1> <p>

</p><h2> (1/5)lists manipulation </h2> <p>

As we have seen before, lists can be defined using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums: Collection.list(Num) //declaration for a list of nums
/*..*/
xs0 = Nums[10\;20\;30\] //xs0 <: mut Nums
Nums xs1 = Nums[10\;20\;30\] //xs1 <: imm Nums == //xs1 <: Nums
imm xs2 = Nums[10\;20\;30\] //xs2 <: imm Nums == //xs2 <: Nums
xs3 = Num.List[10\;20\;30\] //xs3 is another kind of list of nums
]]></pre>
As you can see above, many of the most common <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> classes have a nested class
called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.List]]></span><it style="font-style: bold; color:green;">&#187;</it> as a convenience feature, to avoid having to define your own in most programs.

<br/>

Lists can be created with square brackets; they are born mutable but can become immutable 
if they are directly assigned to an immutable local binding or parameter, or by other forms of promotion; for example,
a method without <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters returning a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference
can be used to initialize an immutable binding.
You need to specify the type of the local binding to force the promotion.
<br/>
For example: 

<pre class="l42Big"><![CDATA[
Nums myNums= DoIt.getMutableNums() //ok promotions happens, myNums is immutable

myNums= DoIt.getMutableNums() //myNums type is inferred to be mut Nums
]]></pre>

Immutable lists can be combined with operators.
The general idea is that operators 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+,-]]></span><it style="font-style: bold; color:green;">&#187;</it> works 
on one sequences and one element,
while the corresponding doubled-up operators
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[++,--]]></span><it style="font-style: bold; color:green;">&#187;</it>
works on two sequences.
You can see the details of this below.
<pre class="l42Big"><![CDATA[
X[
  //element addition
  Nums[a;b;c]+d == Nums[a;b;c;d];
  //element addition works both ways
  k+Nums[a;b;c]+d == Nums[k;a;b;c;d];
  //sequence concatenation
  Nums[a;b]++Nums[c;d] == Nums[a;b;c;d];
  //element removal
  Nums[a;b;b;c]-b == Nums[a;c]; //how to tell two elements apart?
  //sequence subtraction (like removeAll / set minus)
  Nums[a;b;b;c]--Nums[b;c] == Nums[a];
  ]
]]></pre>
In addition of operators, immutable lists also supports a pletora of methods:
<pre class="l42Big"><![CDATA[
X[
  //replacement
  Nums[a;b;c;d].with(2I,val=e) == Nums[a;b;e;d];
  Nums[a;b;c;d].withLeft(e) == Nums[e;b;c;d];//==Nums[..].with(0I val=e)
  Nums[a;b;c;d].withRight(e) == Nums[a;b;c;e];//==Nums[..].with(\size-1I val=e)
  //insertion
  Nums[a;b;c;d].withAlso(2I,val=e) == Nums[a;b;e;c;d];
  Nums[a;b;c;d].withAlsoLeft(e) == Nums[e;a;b;c;d];//==Nums[..].withAlso(0I val=e)
  Nums[a;b;c;d].withAlsoRight(e) == Nums[a;b;c;d;e];//==Nums[..].withAlso(0I val=e)
  //skipping/filtering
  Nums[a;b;c;d].without(index=2I) == Nums[a;b;d];
  Nums[a;b;c;d].withoutLeft() == Nums[b;c;d];//==Nums[..].without(0I)
  Nums[a;b;c;d].withoutRight() == Nums[a;b;c];//==Nums[..].without(\size-1I)
  Nums[a;b;c;b;d].withoutAll(val=b) == Nums[a;c;d];
  Nums[a;b;c;b;d].withoutLeft(val: b) == Nums[a;c;b;d]; //filter out the leftmost b
  Nums[a;b;c;b;d].withoutRight(val: b) == Nums[a;b;c;d]; //filter out the rightmost b
  ]
]]></pre>
As you notice, there are different kind of actions: 
replace an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with]]></span><it style="font-style: bold; color:green;">&#187;</it>),
insert an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[withAlso]]></span><it style="font-style: bold; color:green;">&#187;</it>)
and skipping/filtering elements out (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[without]]></span><it style="font-style: bold; color:green;">&#187;</it>).
Then, elements can be specified by index, by being
the leftmost or the rightmost.
To filter elements
out, you can also just provide the element.

</p><p>


Immutable collections (and also mutable ones, as we will see later)
can be accessed with the following methods: 

<pre class="l42Big"><![CDATA[
X[
  //access
  Nums[a;b;c;d].left() == a;
  Nums[a;b;c;d].right() == d;
  Nums[a;b;c;d].val(2I) == c;
  Nums[a;b;c;d].size() == 4I;
  !Nums[a;b;c;d].isEmpty();
  ]
]]></pre>

</p><h2> Mutate sequences </h2> <p>

Mutable sequences can contains mutable objects.
While this can be useful in special circumstances, it can create aliasing issues similar to the
ones of the animals example of before.
To warn against such issues, methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left()]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> return 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> references to mutable objects. In order to obtain 
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, the user need to use the methods
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#left()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#right()]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>

Mutable sequences can be more efficient that 
immutable ones, and are more general, since they 
can store mutable objects.
<br/>


Now we show some methods over a mutable list <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[foo = Nums[a;b;c;d]]]></span><it style="font-style: bold; color:green;">&#187;</it>; consider each following line independently: 
<pre class="l42Big"><![CDATA[
//setting a value in a position
foo.set(2I val=e) //foo == Nums[a;b;e;d]
//setting at left or right
foo.left(e) //foo == Nums[e;b;c;d]
foo.right(e) //foo == Nums[a;b;c;e]

//add a value in a position
foo.add(2I val=e) //foo == Nums[a;b;e;c;d]

//add at left or right
foo.add(left=e) //foo == Nums[e;a;b;c;d]
foo.add(right=e) //foo == Nums[a;b;c;d;e]

//removal
foo.remove(2I) //foo == Nums[a;b;d]
foo.removeLeft() //foo == Nums[b;c;d]
foo.removeRight() //foo == Nums[a;b;c]

//removal
foo.removeAll(val=b) //foo == Nums[a;c;d]
foo.removeLeft(val=b) //remove the leftmost b
foo.removeRight(val=b) //remove the rightmost b
]]></pre>


</p><h2> (2/5) Iterations on lists </h2> <p>

We now show various pattens to iterate on lists.
First some usual foreach:
<pre class="l42Big"><![CDATA[
vec = S.List[S"foo"; S"bar"; S"beer"]
var S result = S""
for myElem in vec ( result++=myElem ) 
//result==S"foobarbeer"
]]></pre>

In 42 foreach allows to iterate on multiple collections at onece, and also to update the collections:
<pre class="l42Big"><![CDATA[
rs = Nums[1\;2\;3\;]
as =  Nums[10\;20\;30\;]
bs =  Nums[100\;200\;300\;]
for a in as, b in bs, var r in rs ( r:= r+a+b )
//now rs==Nums[111\;222\;333\;]
]]></pre>

In the example above, a dynamic error would be raised if 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[rs]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[as]]></span><it style="font-style: bold; color:green;">&#187;</it> and
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bs]]></span><it style="font-style: bold; color:green;">&#187;</it> have different length.
This behaviour can be tuned in many way: 
iterators can be parametrized with
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cut()]]></span><it style="font-style: bold; color:green;">&#187;</it> , <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cutVals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cut()]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to skip extra elements, while <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>
allows iterate on a subsequence only.

<br/>
Let see some examples: 
<pre class="l42Big"><![CDATA[
for x in xs.cut(), y in ys ( .. )
//will iterate as long as xs, even if ys is longer.
//will stop after xs.size() cycles, and fail if xs.size()>ys.size()

for x in xs.vals(5I to 10I), y in ys ( .. )
//will iterate across xs elements from position 5 to 10, pairing them up with elements 0-5 of ys.
//will stop after 5 cycles, and go in error is ys.size()!=5 or xs.size()<10

for x in xs.cut(), y in ys.cut() ( .. )
//will iterate for as long as both xs and ys have elements.
//similar to a functional zip

rs = Nums[1\;2\;3\;]
imm as =  Nums[10\;20\;30\;40\;50\;]
imm bs =  Nums[100\;200\]
for a in as.cut(), b in bs+300Num, var r in rs ( r:= r+a+b )
//rs==Nums[111\;222\;333\;]
]]></pre>

</p><h2> The power of the \ </h2> <p>

There are varius methods taking advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> syntactic sugar.
They provides an expressive power similar to what list comprehensions provides in python and streams in Java, but by just using simple control flow like for/if:

<pre class="l42Big"><![CDATA[
as =  Nums[1\;2\;3\;4\;]
//mapping
bs0 = Nums[](for a in as \add(a*10Num))
//bs0==Nums[10\;20\;30\;40\]
//filtering
bs1 = Nums[](for a in as if a>2Num \add(a))
//bs1==Nums[3\;4\]
//flatmapping
bs2 = Nums[](for a in as for b in bs0 \add(a+b))
//bs0==Nums[11\;21\;31\;41\;12\;22\;32\;42\;13\;23\;33\;43\;14\;24\;34\;44\;]
//reduce
tot0 = as.reduce()(for v in \vals \add(\acc+v)) //would go in error if as.isEmpty()
tot1 = as.reduce(0\)(for v in \vals \add(\acc+v)) //ok also if as.isEmpty()
//tot0 == tot1 == 10Num

//checks a property; great in an if or an X[]
ok0 = Match.Some()(for a in as \add(a>3Num))
//ok0==true
ok1 = Match.All()(for a in as \add(a>3Num))
//ok1==false
ok2 = Match.None()(for a in as \add(a>3Num))
//ok2==false
ok3 = Match.Count()(for a in as \add(a>3Num))
//ok3==2I
asContainsAllBs = Match.All()(for b in bs \add(b in as))
asIntersectBs = Match.Some()(for b in bs \add(b in as))
asDisjointBs = Match.None()(for b in bs \add(b in as))
//Note: b in as == as.contains(b)

]]></pre>
The language 42 is expression based. Expressions that look like statements are just expressions with the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> return type.
Those methods that take advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> are simply methods with a single parameter 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void that]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method in the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match.**]]></span><it style="font-style: bold; color:green;">&#187;</it> examples short circuit when appropriate, so that the for can terminate as soon as the result is known.


</p><h2> (3/5) Lists with mutable and immutable elements </h2> <p>

Up to now we focused on lists of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>, but 
all instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> are immutable; we now discuss what happens where
mutable lists contains a mixture of mutable and immutable elements.
Consider the following code:
Finally, we conclude discussing iteration on mutable elements:
Mutable lists can contains
<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
Points = Collection.list(Point)
..
imm p0=Point(x=0\,y=0\) //an imm point
p1=Point(x=1\,y=1\) //a mut point
ps=Points[p0;mutVal=p1] //a mut list with both points
X[
  p0==ps.val(0\);
  p0==ps.left();
  p1.readEquality(ps.#val(1\)); //== only works on imms,
  p1.readEquality(ps.#right()); //readEquality checks for structural equality
  p0.readEquality(ps.readVal(0\)); // .readVal generalizes over imm/mut values
  p1.readEquality(ps.readVal(1\));
  ]
for read p in ps ( Debug(p) )
]]></pre>

As you can see, to insert a mutable point we need to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mutVal]]></span><it style="font-style: bold; color:green;">&#187;</it> and to
take the point out we have to add the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it> to the method.
When iterating on a list, if we expect a mixture of mut and imm values we must add <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>
to avoid a runtime error.
If we expect all values to be <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> instead.
When a mut collection is promoted to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, it still remembers what values were originally inserted as
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
To make it so that all values can be read as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can use the method
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.immNorm()]]></span><it style="font-style: bold; color:green;">&#187;</it>. In addtion of normalizing the collection, it also marks all values
accessible as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown in the code below:

<pre class="l42Big"><![CDATA[
Points immPs=(
  imm p0=Point(x=0\,y=0\) //an imm point
  p1=Point(x=1\,y=1\) //a mut point
  Points[p0;mutVal=p1] //a mut list with both points
  ).immNorm()
for p in ps ( Debug(p) ) //works, it would fail without 'immNorm()'
]]></pre>

</p><h2> (4/5) Map </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> also support maps, sets, optional and enumerations.
We will add more kinds of collections in the future.

</p><h2> Optional </h2> <p>
In 42 there is no concept of null, and all the values are always intentially initialized before
they can be read.
There are two main reasons programmers relies on nulls: optional values and circular/delayed initialization.
Circuar initialization can be solved with a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd]]></span><it style="font-style: bold; color:green;">&#187;</it> types, an advanced typing feature that we do not discuss here.
Optional values are a staple of functional programming and are logically equivalent to a collection of zero or one element, or, if you prefer, a box that may or may not contain an element of a certain type.
Optionals values can be obtained with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.optional(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below.
Optionals are also optimized so that they do not require the creation of any new objects at run time.

<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
OPoint = Collection.optional(Point)
Main = (
  imm p00=Point(x=0\ y=0\)//an imm Point in 00
  mut p01=Point(x=0\ y=1\)//a mut Point originally in 01
  var imm p00Box = OPoint(p00) //immutable Optional Point
  var mut p01Box = OPoint(p01) //mutable Optional Point
  X[
    p00 in p00Box; //the in syntax checks if an object is in the box
    p00Box.val()==p00; //Data defines == only for imm references
    p01Box.val().readEquality(p01);//here .val() gives us a read reference
    ]
  if p00Box ( Debug(S"printing %p00Box") )//printing [Point(x=0, y=0)]
  //we can just check if a box is not empty as if it was a boolean
  p01Box.#val().x(50\)//updates the x value of the point
  Debug(S"printing %p01")//printing Point(x=50, y=1)
  p00Box:= OPoint()//updates the local variables with empty boxes
  p01Box:= OPoint()
  if !p00Box ( Debug(S"printing %p00Box") )//printing []
    X[
    !(p00 in p00Box);
    !p00Box;//using isPresent() or not is just a matter of style
    !p00Box.isPresent();
    ]
  )
]]></pre>
At this point in the tutorial, some readers will be confused that we can update the local variable binding 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> even if it is immutable.
Other readers instead will remember that immutability is a property of the reference and not of the binding/field: a local binding and fields declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> can be updated.
The updated value need to respect the modifier of the fild/binding type: if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> it needs to be updated with another <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it>; if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> than it can be updated with either
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Oh, yes, another reader will realize ... and a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> reference can be assigned to any of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Note how both local bindings are updated using the same exact expression :
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()    p01Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it>
In 42 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> can be either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> (or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> indeed)
On the other side, consider 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p00)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p01)]]></span><it style="font-style: bold; color:green;">&#187;</it>: the first one is immutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>,
while the second one is mutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p01]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Map </h2> <p>
Thanks to normalization 42 can have very fast and most reliable hash sets and hash maps.
The values of sets and the keys of maps must be immutable, and are normalized just before being intserted in the collection.
Then, the value of the normalized pointer is used to check for equality and hashcode.
This have various positive effects:

<ul><li>
The user does not need to write equality and hashing behaviour
</li><li>
There is no risk of mistake in the equality and hashing behaviour
</li><li>
The intrinsic invariants of the hashmap/hashset are never violated/corrupted.
</li><li>
The equality is a perfect structural equality, but is as fast as a pointer equality; for maps with large keys this can make a massive performance difference.
</li></ul>

Maps and sets have less methods that lists, but they can still be iterated upon, as shown in the following code:

<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
Points = Collection.list(Point)
PointToString = Collection.map(key=Point, val=S)
Roads = Collection.map(key=Point, val=Point)
Main = (
  map = PointToString[
    key=\(x=3\ y=4\), val=S"MyBase";
    key=\(x=0\ y=0\), val=S"Source";
    key=\(x=5\ y=8\), val=S"EnemyBase";
    ]
  for (key,val) in map ( Debug(S"%key->%val") )
  //we can use (..) to extract the key/val fields from PointToString.Entry
  //this iteration is straightforward since all values are imm
  roads = Roads[
    key=\(x=3\ y=4\), val=\(x=0\ y=0\); //immutable to immutable
    key=\(x=0\ y=0\), mutVal=\(x=0\ y=0\);//immutable to mutable
    key=\(x=5\ y=8\), mutVal=\(x=0\ y=0\);//immutable to mutable
    ]
  for read (key, val) in roads ( Debug(S"%key->%val") )
  //we add 'read' in front to be able to read mixed imm/mut values
  //if all the values were mutable, we could just add 'mut' in front
  )
  mut Roads.Opt?? optPoint = roads.#val(key=\(x=0\ y=0\)))
  optPoint.#val().x(50\)//update the field of the objectv inside the map
  ]]></pre>

As you can see, when objects are retrived from the map, we obtain an optional value; this is because statically we can not know if a key is mapped to a value or not.
<br/>
In addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
maps offers the following methods:
<ul><li>
To extract a value using the key:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>; to extract an optional
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, respectivelly.
As for lists, it is always safe to extract a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference. An empty optional will be produced when attempting to extract as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm/mut]]></span><it style="font-style: bold; color:green;">&#187;</it> a value that was inserted as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> instead, so to relayably ask if a key is contained in the map we should write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[map.readVal(key=myKey).isPresent()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</li><li>
Mutable maps can be modified by
inserting immutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it> and mutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Finally, an association can be removed using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.map(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> creates a class remembering the insertion order.
This is needed to make the iteration deterministic.
The keys can be retreived with their order using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[key(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> passing the desired <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I index]]></span><it style="font-style: bold; color:green;">&#187;</it>, from zero to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\size-1I]]></span><it style="font-style: bold; color:green;">&#187;</it>
The corresponding value can be retreived by methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> 
to extract a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> (not optional) reference to the value, respectivelly.
</li></ul>
     

</p><h2> Set </h2> <p>
Sets behaves a lot like maps where the values are irrelevant, and have differently named methods.
In particular, in addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
sets offers method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> to add and remove an element,
and elements can be extracted in the insertion order by using method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>

We are considering adding operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it> as for lists, and
support for the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> like for lists.
An operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[&&]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the intersection of the two sets.
On the other side, boolean methods like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[intersect(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[disjoint(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[containsAll(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> can already be easily emulated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match]]></span><it style="font-style: bold; color:green;">&#187;</it> as we shown for lists.
</p><h2> (5/5) Collection summary </h2> <p>

<ul><li>
There are a tons of methods and operators to know, but since most code works 
around collections, it is worth the effort to memorize them.
</li><li>
Immutable collections are easy to play with, using operators and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with**]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
</li><li>
Mutable collections can be more efficient and flexible, but they come with additional
difficulties.
</li><li>
Most methods have a general version that works with an index, and specialized <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right]]></span><it style="font-style: bold; color:green;">&#187;</it> variants.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> can help remove a lot of boilerplate, but is a concept unique to 42, and require some effort to get used to.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> is very useful and flexible. It is common to find methods composed from just a large
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> statement plus a little pre and post processing around it.
</li></ul>
 </p><p id="InputOutput"> </p><h1> Input Output with Object Capabilities </h1> <p>
</p><h2> (1/5) Controlling non determinism </h2> <p>
Traditionally, in imperative languages I/O and side effects can happen everywhere, while
in pure functional languages like Haskell they are kept in check by monads.

In 42 we have type modifiers to keep mutation and aliasing under control.
With only the features shown up to now, 42 is a deterministic language, thus
every expression that takes in input only immutable objects
can be called multiple times with the same arguments and will produce the same result.
<br/>
The whole caching system relies on this property to work.
<br/>
Thus input output, random numbers and any other kind of observable non determinism must preserve this property.
Introducing object capabilities:
<br/>
An <it style="font-style: italic;">object capability</it> is a mutable object whose methods can do some non deterministic, or otherwise privileged operation.
If a method is given a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference to an object capability, then it can be non deterministic,
otherwise it will be deterministic.
Creation of new object capabilities is only possible by either relying on an existent object capability
or by using a <it style="font-style: italic;">capability method</it>: a method whose name starts with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$]]></span><it style="font-style: bold; color:green;">&#187;</it>; however those specially named methods can only be called from a main, from another capability method or from a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> method of a capability object.

</p><h2> (2/5) Example: File System </h2> <p>

To read and write files we need to load a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FileSystem]]></span><it style="font-style: bold; color:green;">&#187;</it> library as shown below:
<pre class="l42Big"><![CDATA[
FS = Load:{reuse [L42.is/FileSystem]}
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FS]]></span><it style="font-style: bold; color:green;">&#187;</it> is the local name for the library located at <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/FileSystem]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator embeds the librady in the current environment.
We can now use our file system:
<pre class="l42Big"><![CDATA[
Main1 = (
  mut FS f = FS.Real.#$of()
  S s=f.read(fileName=S"data.txt") //non determistic operation
  //the result depends on the current file content
  f.write(fileName=S"data.txt",content=S"SomeContent") //non determistic operation
  //the operation could go in error if there is not enough space to write the content on disk.
  Debug(s)
  )
  }
]]></pre>
The crucial point in the former code example is the call to 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FS.Real.#$of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This instantiates a capability object using the capability method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

We could write the code inside a method in the following way:
<pre class="l42Big"><![CDATA[
ReadWrite = {class method
  Void (mut FS f) = (
    S s=f.read(fileName=S"data.txt")
    f.write(fileName=S"data.txt",content=S"SomeContent")
    Debug(s)
    )
  }
Main1 = ReadWrite(f=FS.Real.#$of())
]]></pre>
Note how we pass the capability object explicity to the method.
This is the most common style, and have great testing advantages:
Indeed, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FS]]></span><it style="font-style: bold; color:green;">&#187;</it> corresponds to the following interface:
<pre class="l42Big"><![CDATA[
interface
mut method Void makeDirs(S fileName)
mut method Void delete(S fileName)
mut method Void write(S fileName,S content)
mut method S read(S fileName)
]]></pre>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FS.Real]]></span><it style="font-style: bold; color:green;">&#187;</it> is simply an implementation of such interface connected with the real file system.
Thus, we can write a simple mock to check that the function behaves as expected:
<pre class="l42Big"><![CDATA[
Mock = Data:{[Fs]
  var S log=S""
  method makeDirs(fileName) = error X""
  method delete(fileName) = error X""
  method write(fileName,content) = ( 
    X[actual=fileName expected=S"data.txt";
      actual=content  expected=S"SomeContent";]
    this.log(\log++S"write")
    )
  method read(fileName) = (
    X[actual=fileName expected=S"data.txt"]
    this.log(\log++S"read")
    S"oldContent"
    )
  }
Test1= (
  m=Mock()
  ReadWrite(f=m)
  {}:Test"ReadWriteOk"(actual=m.log() expected=S"readwrite")
  )
]]></pre>

</p><h2> (3/5) Object capabilities programming patterns </h2> <p>

The advantage of the division of the file system in an interface and a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Real]]></span><it style="font-style: bold; color:green;">&#187;</it> implementation are not limited to testing.
For example, the user could embed some security and on some restrictions in an alternative implementation of a file system.
Consider the following code:

<pre class="l42Big"><![CDATA[
OnlyTxt = Data:{[Fs]
  capsule Fs inner
  class method
  Void checkTxt(S that)= X.Checked[
    that.endsWith(S".txt")
    ]
  method makeDirs(fileName) = error X""
  @Cache.Clear class method Void delete(mut Fs inner, S fileName) = (
    this.checkTxt(fileName)
    inner.delete(fileName)
    )
  @Cache.Clear class method Void write(mut Fs inner, S fileName, S content) = ( 
    this.checkTxt(fileName)
    inner.write(fileName=fileName, content=content)
    )
  @Cache.Clear class method Void read(mut Fs inner, S fileName) = ( 
    this.checkTxt(fileName)
    inner.read(fileName=fileName)
    )
  class method          //example user declared #$ method, that can
  mut This #$of() =     //use $# methods inside its body
    This(inner=Fs.Real.#$of())
  }
SaferMain = (
  fs = OnlyTxt.#$of()
  ReadWrite(f=fs)
  )
]]></pre>
Any code that would take in input a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> would have a limited access to the file system; only able to read and write onWcode(*.txt) files.
Note that the field <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[inner]]></span><it style="font-style: bold; color:green;">&#187;</it> is not private but it is well encapsulated, thus a user of 
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> could only extract the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> version of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[inner]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We will see later how to set some members private, but in this case just encapsulation is sufficient.
<br/>
Instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> are capability objects; note how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> can even declare a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$of]]></span><it style="font-style: bold; color:green;">&#187;</it> method. In this way for the user there is no syntactical difference between using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs.Real]]></span><it style="font-style: bold; color:green;">&#187;</it> or using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Capability objects are a useful abstraction and can be designed and implemented by normal 42 programs; they are not just a way for the language implementation to expose native code.
We have just shown that new object capabilities can easy be defined by simple wrapping over existing capability objects.

<br/>
Since inner is of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs]]></span><it style="font-style: bold; color:green;">&#187;</it>, this programming patterns allows to layer many levels of security / restrictions on top of a capability object, as shown below:
<pre class="l42Big"><![CDATA[
fs = OnlyTxt(inner=OnlySmallFiles(inner=Fs.Real.#$of()))
]]></pre>


</p><h2> (4/5) Connection with other languages </h2> <p>
In general, all the  non determinism in 42 is obtained by comunicating with other languages.
42 allows to connect with Java, and Java allows to connect with C/assembly.
The best way to connect with java is to use the library <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JavaServer]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below:
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamTowel]
J0 = Load:{reuse [L42.is/JavaServer]}
J = J0(slaveName=S"mySlave{}")
]]></pre>
The code above loads the library <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JavaServer]]></span><it style="font-style: bold; color:green;">&#187;</it>. It is a generic library: before being used we need to provide a name for the Java slave.
A 42 program is not a single process but a cluster of intercommunicating Java processes.
There is one master process where the 42 computation is actually running and many other slave processes allowing safe input output and safe interaction with arbitrary code.
Such slave processes have their own name: in this case <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mySlave]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Slaves also have a set of options, that can be specified between the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{}]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We do not describe the details of those options here.
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J]]></span><it style="font-style: bold; color:green;">&#187;</it> can now be used to comunicate with the Java slave as shown below:
<pre class="l42Big"><![CDATA[
MainAsk = (
  j = J.#$of()
  j.loadCode(fullName=S"foo.Bar1",code=S"""
    |package foo;
    |import is.L42.platformSpecific.javaEvents.Event;
    |public record Bar1(Event event){//class Bar1 will be instanstiated by 42
    |  public Bar1{                  //and the Event parameter is provided
    |    event.registerAskEvent("BarAsk",(k,id,msg)->
    |      "any string computed in Java using "+id+" and "+msg);
    |    }
    |  }
    """)
  S.Opt text = j.askEvent(key=S"BarAsk", id=S"anId",msg=S"aMsg")
  {}:Test"OptOk"(actual=text, expected=S"""
    |["any string computed in Java using anId and aMsg"]
    """.trim())
  )
]]></pre>
This code asks the event <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["anId"]]></span><it style="font-style: bold; color:green;">&#187;</it> on the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarAsk"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The Java code registers the capacity of answering to the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarAsk"]]></span><it style="font-style: bold; color:green;">&#187;</it> and
computes an answer parametrized over <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[id]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[msg]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[askEvent]]></span><it style="font-style: bold; color:green;">&#187;</it> is syncronus: it will wait for java to provide an answer as an optional string; optional since Java can return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[null]]></span><it style="font-style: bold; color:green;">&#187;</it> as a result.

As you can see, you can embed arbitrary Java code in 42 and communicate back and forth serializing data and instructions as strings.

Syncronus comunication is sometimes undesirable. 
For example, to use Java to open a GUI it would be better to have asyncronus comunication and a queue of events.
You can do this with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J.Handler]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown below:
<pre class="l42Big"><![CDATA[
Model = Data:J.Handler:{
  var I count, mut J j
  @J.Handler mut method Void fromJavaToL42(S msg)=(
    this.count(\count+1\)
    Debug(S"pong received %msg with count=%this.count()")
    if this.count()<40I (
      this.#j().submitEvent(key=S"BarIn", id=S"ping", msg=S"the message %this.count()")
      whoops J.Fail
      )
    else this.#j().kill()
    )
  }
MainPingPong = (
  j=J.#$of()
  j.loadCode(fullName=S"foo.Bar2",code=S"""
    |package foo;
    |import is.L42.platformSpecific.javaEvents.Event;
    |public record Bar2(Event event){
    | public Bar2{
    |    event.registerEvent("BarIn","ping"(k,id,msg)->{
    |      System.out.println("Ping Event received "+id+" "+msg);
    |      event.submitEvent("BarOut","fromJavaToL42","pong");
    |      });
    |    event.registerEvent("Kill",(k,id,msg)->{
    |      System.out.println("Doing cleanup before slave JVM is killed");
    |      System.exit(0);
    |      });
    |    }
    |  }
    """)
  model=Model(count=0I, j=j)
  model.fromJavaToL42(msg=S"Initial message")
  keys=S.List[S"BarOut"]
  models=J.Handler.Map[key=S"BarOut" mutVal=model]
  for e in j(keys) ( e>>models )
  Debug(S"Completed")
  )
]]></pre>
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Model]]></span><it style="font-style: bold; color:green;">&#187;</it> handles the events inside of 42:
if Java send an event with id <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["fromJavaToL42"]]></span><it style="font-style: bold; color:green;">&#187;</it> then the method
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Model.fromJavaToL42(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it> will be called.
In turn, such method
sends to java the message 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["ping"]]></span><it style="font-style: bold; color:green;">&#187;</it> on channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut method J.submitEvent(key,id,msg)]]></span><it style="font-style: bold; color:green;">&#187;</it>
up to 40 times, and kills the slave JVM after that.

In <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MainPingPong]]></span><it style="font-style: bold; color:green;">&#187;</it> we initialize the slave JVM to respond to two channels:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Kill"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In our example Java will submit an asyncronus event to 42 as a response to
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn":"ping"]]></span><it style="font-style: bold; color:green;">&#187;</it> event and will terminate the slave on any <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Kill"]]></span><it style="font-style: bold; color:green;">&#187;</it> event.
The slave should always terminate its JVM when receiving a kill, but can do any kind of clean-up before that.
After a JVM is terminated, it can be restarted by simply calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J.loadCode(fullName,code)]]></span><it style="font-style: bold; color:green;">&#187;</it> again.

Finally, we set up the event loop:
An event loop will collect events from a list of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and dispatch them
to a map of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it>, mapping every key to a specific <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[model]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Note that both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it> are mutable objects. In this way we can dynamically
register and unregistered keys/models by mutating <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it>.
If the JVM is killed or the list of keys becomes empty, the event loop <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for e in j(keys)]]></span><it style="font-style: bold; color:green;">&#187;</it> will terminate.
The operation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[e>>models]]></span><it style="font-style: bold; color:green;">&#187;</it> dispatches the event to the model.
<br/>
We need to use two different channels (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarOut"]]></span><it style="font-style: bold; color:green;">&#187;</it>) to distinguish if an event is should be handled by 42 or by Java.


</p><h2> (5/5) Object capabilities summuary </h2> <p>
<ul><li>
While most languages run in a single process, 42 runs in a cluster of processes; this is needed so that the master process is procted from any slave process going into undefined behaviour.
This is the final piece of the puzzle allowing the correctness properties of 42 to be ensured in any circumstance.
</li><li>
To enable non deterministic behaviour we need to call those specially named <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
Since they can only be called in a few controlled places, we can control what parts of the code can perform non determinism by explicitly passing capability objects.
</li><li>
Capability objects are a very convenient centralized point of control to inject security or other kinds of restrictions.
</li></ul>
 </p><p id="Exercises"> </p><h1> Exercises </h1> <p>

A very large class of practically useful programs can be obtained
just by declaring
basic classes, collections
and simple Data classes.

Let's see some exercises and solutions 
to understand better how 42 code looks like

</p><h2> (1/5) Max method </h2> <p>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MaxOfList]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the max from a list of numbers
</p><p>
Basic Solution: 
<pre class="l42Big"><![CDATA[
MaxOfList = {//static method pattern
  UndefinedOnEmpty = Message:{[Message.Guard]}
  //Max is undefined on empty lists.
  //Since there was no mention of preconditions, we should explicitly handle all the error cases as Guards
  class method
  Num (Num.List that) = {
    if that.isEmpty() ( error UndefinedOnEmpty"Max is undefined on empty lists" )
    //now that we know we can proceed: 
    var Num maxCandidate= that.left()
    //there is no such thing like a minimum Num, we need to select one element from the list.
    for n in that (
      //we could write 'that.withoutLeft()' to avoid checking on the first again
      if maxCandidate<n (maxCandidate:= n)
      //update the variable to keep track of the max so far.
      )
    return maxCandidate
    }
  }
]]></pre>

Solution using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
MaxOfList = {
  class method
  Num (Num.List that) =
    that.reduce()(
      for e in \vals() (
        if \acc < e \add(e) 
        )
      )
  }
]]></pre>
Where the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it>  will already throw a meaningful error in case of an empty list: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.OperationUndefinedOnEmpty]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Defining your own error may still produce more readable errors, so feel free to mix and match the two approaches as show in the next exercise:


</p><h2> (2/5) Merging and filtering </h2> <p>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MapText]]></span><it style="font-style: bold; color:green;">&#187;</it> producing a string from to lists of strings of the same length.
 For example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MapText(keys=S.List[S"a";S"b";S"c"] vals=S.List[S"z";S"y";S"z"])]]></span><it style="font-style: bold; color:green;">&#187;</it>
should produce <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"[a->z, b->y, c->z]"]]></span><it style="font-style: bold; color:green;">&#187;</it>
</p><p>
Solution: 
<pre class="l42Big"><![CDATA[
MapText = {
  UnequalSize = Message:{[Message.Guard]}
  class method
  S (S.List keys, S.List vals) = {
    if keys.size() !=  vals.size() error UnequalSize
      "keys= %keys.size(), values= %vals.size()" 
    //the former formatting allows us to keep a whole line for the error message
    res = S.List()(for k in keys, v in vals \add(S"%k->%v"))
    if res.isEmpty() return S"[]"
    text = res.reduce()(for s in \vals \add(\acc++S", %s"))
    return S"[%text]"
    }
  }
]]></pre>
Note how we write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(\acc++S", %s")]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(S"%\acc, %s")]]></span><it style="font-style: bold; color:green;">&#187;</it> since 
 string interpolation does not currently support the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<br/>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FilterUpTo{ class method S.List(S.List that, I size)}]]></span><it style="font-style: bold; color:green;">&#187;</it> filtering out from a list of strings the ones longer
than <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FilterUpTo(S.List[S"a";S"ab";S"abc"] size=2I)==S.List[S"a";S"ab"]]]></span><it style="font-style: bold; color:green;">&#187;</it>
</p><p>
Precondition: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size]]></span><it style="font-style: bold; color:green;">&#187;</it> is not negative
</p><p>
Solution: 
<pre class="l42Big"><![CDATA[
FilterUpTo = {
  class method
  S.List (S.List that, I size) = (
    X.Pre[size >= 0I]
    S.List()(for s in that if s.size()<= size \add(s))
    )
  }
]]></pre>
Again we see yet another way to handle errors; preconditions are appropriate when it is an observed  bug if the user calls it with wrong parameters.

</p><h2> (3/5) Read/Write files </h2> <p>

Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ReadSelf]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the content of the file where the current source code is located.
<br/>
<pre class="l42Big"><![CDATA[
FileSystem = Load:{reuse[FileSystem]}

ReadSelf = {
  class method
  S (mut FileSystem that) = 
    that.read(fileName=S"This.L42")
  }
Test = {}:Test""(expected=ReadSelf(FileSystem.Real.#$of())
    actual=S"reuse [AdamTowel]%S.nl()MaxOfList = [###]end")
//end
]]></pre>

As you can see, In the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[actual]]></span><it style="font-style: bold; color:green;">&#187;</it> parameter of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Test]]></span><it style="font-style: bold; color:green;">&#187;</it> we can use the symbol
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["[###]"]]></span><it style="font-style: bold; color:green;">&#187;</it> to specify holes in the expected string.
This is very useful to make more resilient tests.

</p><h2> (4/5) Random mole </h2> <p>
For a longer example, represent a piece of land as a 80*80 bi-dimensional map,
where every cell can be full of dirt (90%) or rock (10%).
Then a mole start from the left top corner and attempts to
digs through dirt randomly.
After 3000 steps the mole stops.
Define the opportune classes and write a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[randomDig]]></span><it style="font-style: bold; color:green;">&#187;</it>
method. 
</p><p>
To start, we define some auxiliary classes: 
<pre class="l42Big"><![CDATA[
Point = Data:{I x, I y
  @Cache.Now class method
  Void invariant(I x, I y) = X.Guarded[
    x>=0I; x<80I;
    y>=0I; y<80I;
    ]

  method
  This go(Direction that) = {
    return that.go(this)
    catch error X.Guarded _ return this
    }
    
  method
  I index() = 
    (this.y()*80I)+this.x()
  }
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> has an invariant ensuring that the coordinates are inside the 80*80 area.
We use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Guarded]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Guarded]]></span><it style="font-style: bold; color:green;">&#187;</it> implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Guard]]></span><it style="font-style: bold; color:green;">&#187;</it>, thus we can rely on such error to trigger predictably.
We do this in method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, where we capture the invariant failure in case moving the point would push it outside of the boundary; in that case we keep the point in the original coordinates.

<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{interface
  method Point go(Point that)
  Up={[This1] method go(that)=that.with(x=\x-1I)}
  Down={[This1]method go(that)=that.with(x=\x+1I)}
  Left={[This1]method go(that)=that.with(y=\y-1I)}
  Right={[This1]method go(that)=that.with(y=\y+1I)}
  }
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it> is an enumeration, and we leverage on dyanamic dispatch to encode the beaviour of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
Note how in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it> we explicitly declared the top level <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> and
we implemented the outer level <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This1]]></span><it style="font-style: bold; color:green;">&#187;</it> explicitly in all the cases.
Then we could implemented the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method without repeating the type signatore.

<pre class="l42Big"><![CDATA[
Cell = Collection.Enum:{
  method S symbol()
  Dirt={method S symbol()=S"#"}
  Rock={method S symbol()=S.percent()}
  Empty={method S symbol()=S" "}
  Mole={method S symbol()=S"M"}
  }
]]></pre>
Instead, while declaring <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cell]]></span><it style="font-style: bold; color:green;">&#187;</it> we omit the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword and the explicit implementation.
Then we had to repeat the type signature all the times while implementing the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[symbol()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Both ways to declare enumerations works and produce the same result.

<pre class="l42Big"><![CDATA[  
Land = Data:{[HasToS]
  mut Math.Random rand
  mut Cell.List cells
  
  class method
  mut Cell.List #default#cells(mut Math.Random rand) = Cell.List[](
    for i in Range(80I*80I) (
      if rand.nextInRange(0I to=10I)==0I \add(Cell.Rock())
      else \add(Cell.Dirt())
      )
    )

  mut method 
  Void set(Point that, Cell val) =
    this.#cells().set(that.index() val=val)
    
  read method 
  Cell val(Point that) =
    this.cells().val(that.index())    
  
  mut method
  Void randomDig() = (
    var current = Point(x=0I y=0I)
    for i in Range(3000I) (
      this.set(current,val=Cell.Empty())
      d = Direction.Vals().val(this.#rand().nextInRange(0I to=4I))
      newPoint = current.go(d) //no digging in rock
      if this.val(newPoint)!=Cell.Rock() ( current:=newPoint )
      )
    this.set(current,val=Cell.Mole()) //finally, the mole is where we ends up
    )
  
  method toS() = (
    var res=S""
    for x in Range(80I) (
      res++=S.nl()//newline
      for y in Range(80I) res++=this.val(\(x=x,y=y)).symbol()
      )
    res++S.nl()
    )
  //since we define 'toS()' explicitly, Data will leave it alone :)
  }
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Land]]></span><it style="font-style: bold; color:green;">&#187;</it> has a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Math.Random rand]]></span><it style="font-style: bold; color:green;">&#187;</it> field and a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List cells]]></span><it style="font-style: bold; color:green;">&#187;</it> field; a list of cells of size 80*80.
While we expect the user to provide the random object, we wish to provide a way to initialize the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cells]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In 42, as for most languages, we could provide a default value for a field by writing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List cells = Cell.List[](..)]]></span><it style="font-style: bold; color:green;">&#187;</it>, but in this case we need to use the provided random object
to complete the initialization, thus we use a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List #default#cells(mut Math.Random rand)]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead.
As with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>,
we take in input parameters with the same name of the fields we wish to use.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is going to rely on this method to initialize the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cells]]></span><it style="font-style: bold; color:green;">&#187;</it> field.
This is actually a general pattern of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, allowing default values for any method.
<br/>
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[randomDig()]]></span><it style="font-style: bold; color:green;">&#187;</it> is straightforward.
<br/>
Note how we override <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[toS()]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of accepting the implementation provided by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.

To use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Land]]></span><it style="font-style: bold; color:green;">&#187;</it> class we can use the code below.
<pre class="l42Big"><![CDATA[
MainMole = (
  land = Land(rand=\.#$random())
  land.randomDig()
  Debug(land)
  )
]]></pre>


</p><h2> (5/5) Examples summary </h2> <p>
<ul><li>
Always think about what can go wrong upfront
</li><li>
Many methods can be completed by first checking for 
errors/issues and then using a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it>, possibly inside a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
Before heading into a problem,
spend some time to define your problem domain.
We dodged a lot of headaches by defining
points with invariants.
</li></ul>
        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'><a href="http://ecs.victoria.ac.nz/Main/MarcoServetto" >Contact Us</a> |</li>
            <li style='display:inline;'><a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>

