<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logo.png' alt='42'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<ol>
 <li><a href="#Basics"> Basics </a></li>
 <li><a href="#ModifiersIntro"> ModifiersIntro </a></li>
 <li><a href="#BasicClasses"> BasicClasses </a></li>
 <li><a href="#InterfacesAndData"> InterfacesAndData </a></li>
 <li><a href="#ErrorsAndExceptions"> ErrorsAndExceptions </a></li>
 <li><a href="#Sequences"> Sequences </a></li>
 <li><a href="#Exercises"> Exercises </a></li>
 <li><a href="#ExamplesOfLibraries"> ExamplesOfLibraries </a></li>
 <li><a href="#MetaprogrammingIntro"> MetaprogrammingIntro </a></li>
 <li><a href="#DeployCode"> DeployCode </a></li>
</ol>
 </p><p id="Basics"> </p><h1> Basics </h1> <p>
</p><h2> (1/5)Simple hello world program </h2> <p>
Let's look at a simple hello world program: 

<pre class="l42Big"><![CDATA[ 
{reuse L42.is/AdamTowel
Main: {
  Debug(S"Hello world")
  return ExitCode.success()
  }
}
]]></pre>

When we write <span class="code"><![CDATA[reuse L42.is/AdamTowel]]></span> we are asking 42 to
reuse the code of the library found in the internet address 
<span class="code"><![CDATA[L42.is/AdamTowel]]></span>.
AdamTowel is our Towel, that is the set of classes and interfaces that we wish to start from (<a href="towel.xhtml">see more on towels</a>).
<span class="code"><![CDATA[L42.is]]></span> is the main website of 42, where most commonly used libraries are hosted. To reuse code you 
need an internet connection; but this also means that you will never have to manually import any code.
Required code will be transitively downloaded and cached on your machine, so you need not to be aware of the existence of this mechanism.
</p><p>
We do not need to always start from AdamTowel, there are many interesting towels out there, and you may also become skilled in the 
advanced technique of towel embroidery.
</p><p>

At the right of <span class="code"><![CDATA[Main: ]]></span> we write the expression that
we wish to execute; in this case a sequence of two statements.
<span class="code"><![CDATA[Main]]></span> is not a method, and <span class="code"><![CDATA[Main]]></span> is not special name either, you can replace it with <span class="code"><![CDATA[Task]]></span> or any other valid
upper-case name. In 42 there is no concept of main method as in
Java or C. For now you can think of <span class="code"><![CDATA[Main: ]]></span> as a top level command, we will understand later how this fits with the general language design.
</p><p>
<span class="code"><![CDATA[Debug]]></span>
is a simple class offering methods to prod the system to understand what is going on.
The most important method of <span class="code"><![CDATA[Debug]]></span> is to just print a message on the console.
In 42, when a class has a "most important" method, it is conventional to name it so that can be used as if the
class name was a function, that is
we write <span class="code"><![CDATA[Debug(S"Hello world")]]></span> instead
of a more verbouse <span class="code"><![CDATA[Debug.println(S"Hello world")]]></span>. We call <span style="color:#ff1111; font-weight: bold;"> funtors </span> objects and classes that can be used as functions.

Finally, our code ends by returning "success" as exit status.


</p><h2> (2/5)Method declaration and call </h2> <p>
Let's now declare a method and call it.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
MyCode: {
  class method
  S hello(S nickName){
    return S"Hello " ++ nickName
    } 
  }
Main: {
  Debug(MyCode.hello(nickName: S"Marvin"))
  return ExitCode.success()
  }
}
]]></pre>
Here we declare a class to host our <span class="code"><![CDATA[hello(name)]]></span> method.
We write <span class="code"><![CDATA[class method]]></span> to declare a method that can be called on the class object, as in <span class="code"><![CDATA[MyCode.hello(name: S"world")]]></span>.
This is roughly equivalent to a static method in languages like Java or C++ , or class methods in Python.

</p><p>
Note how the method is called using the parameter name explicitly.
We believe this increases readability.
</p><p>
You may also notice how there are two different usages for curly brackets:  if there is at least one <span class="code"><![CDATA[return]]></span> keyword then the expression is a block of statements,
otherwise the expression is a library literal, witch can contains methods and nested libraries.
A Wemph(nested library)
is denoted by an upper-case name, and can be obtained by a library literal or an expression producing a library literal.
A library literal can be a class (default case) or an interface (starts with the <span class="code"><![CDATA[interface]]></span> keyword).
A nested library in 42 is similar to a static inner class in Java, or a nested class in C++. It is just a convenient way to organize the various components of our program into a tree shape.
</p><p>
The class <span class="code"><![CDATA[MyCode]]></span> from before offers a single class method, has no fields and you can not create instances of <span class="code"><![CDATA[MyCode]]></span>, since no <span class="code"><![CDATA[factory]]></span> is present; you can think about it as a module.
In 42 we do not have constructors. Objects are created by factory methods, that are just normal methods that happen to return an instance of their class. We believe this is a much simpler and more consistent approach to object initialization.

</p><h2> (3/5)Simple class with internal state </h2> <p>
Let's create now a class with state and factory: 
<pre class="l42Big"><![CDATA[
Point: Data<<{
  Num x
  Num y
  method
  Point add(Num x)
    Point(x: x + this.x(), y: this.y())
  Point add(Num y)
    this.with(y: y + this.y())
  }
]]></pre>
Here you can see we declare a <span class="code"><![CDATA[Point]]></span> class with <span class="code"><![CDATA[x]]></span> and <span class="code"><![CDATA[y]]></span> <span class="code"><![CDATA[Num]]></span> (unlimited precision rational number) coordinates.
<span class="code"><![CDATA[Data]]></span> is a decorator. Decorators are classes/objects that offer an operator <span class="code"><![CDATA[<<]]></span>, called the babel fish operator,
whose goal is to translate a library into a "better" library.
In this case, <span class="code"><![CDATA[Data]]></span> is translating the class <span class="code"><![CDATA[{Num x, Num y}]]></span> into a much longer class, with
a factory method taking in input the fields and initializing them, but also containing
 boring but useful definitions for
equality, inequality, conversions from and to human readable strings, XML and binary representations for (de)serialization.
</p><p>
Finally, we declare methods to add to a single coordinate.
For very short methods we can omit the curly brackets and return.
Indeed, method bodies are just expressions, and the curly brackets turn statements into expressions. 

In the method <span class="code"><![CDATA[add(x)]]></span> we show a constructor call and getters.
In the method <span class="code"><![CDATA[add(y)]]></span> we show an improved version, using the <span class="code"><![CDATA[with]]></span> method, another gift of Data, that allows us to easily create a clone with a
single field updated.
We can declare two methods, <span class="code"><![CDATA[add(x)]]></span> and <span class="code"><![CDATA[add(y)]]></span> with the same name, if parameter names are different.
</p><p>
Note how we always use getters and we never access fields directly.
In many other languages we can use write <span class="code"><![CDATA[a.fieldName]]></span> and <span class="code"><![CDATA[a.fieldName: newValue]]></span>. Such syntax does not exists in 42. The same goes for object instantiation; in many languages there is a special <span class="code"><![CDATA[new ClassName(..)]]></span> dedicated syntax, while in 42 it is just a method call.
</p><p>
Also, similarly to what happens in Python, we need to use <span class="code"><![CDATA[this.methodName()]]></span> to call methods when the receiver is <span class="code"><![CDATA[this]]></span>.
While this makes some code more verbose, it saves us from the burden of  method hiding.   



</p><h2> Decorators </h2> <p>
Decorators are one of the main concepts used by 42 programmers. We will encounter many decorators in this tutorial.
For now, just get used to the pattern of writing
<span class="code"><![CDATA[<<]]></span> to go from a minimal chunk of code, with method declarations for the important bits, to a fully fledged usable class.
<a href="Decorators.xhtml">More on decorators</a>


</p><h2> (4/5)Vectors </h2> <p>

Vectors can be declared using <span class="code"><![CDATA[Collections.vector(of)]]></span>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums: Collections.vector(of: Num)//declaration for vectors of nums
Points: Collections.vector(of: Point)//same for points
/*..*/
xs=Nums[10Num;20Num;30Num]
ys=Nums[1Num;2Num;3Num]
points=Points[with x in xs.vals(), y in ys.vals() (
  use[Point(x: x, y: y)]
  )]
]]></pre>

Vectors can be initialized with the <span class="code"><![CDATA[[_;_;_]]]></span>
syntax or with the <span class="code"><![CDATA[[with _ ( _ use[ _ ]_ )]]]></span> syntax.
We will discuss all the variation of <span class="code"><![CDATA[with]]></span> later.
Note how to express number literal we need to specify their class.

</p><h2> (5/5)Basis Recall </h2> <p>

<ul><li>
At the start of your program, import a towel using 
"<span class="code"><![CDATA[reuse _]]></span>", as in <span class="code"><![CDATA[reuse L42.is/AdamTowel]]></span>.
</li><li>
To declare a simple class exposing its state and 
some methods working with those, use <span class="code"><![CDATA[Data]]></span>, as in
<span class="code"><![CDATA[Point: Data<<{Num x]]></span>.
</li><li>
You can declare methods in classes with the <span class="code"><![CDATA[method]]></span> keyword,
as in <span class="code"><![CDATA[method ReturnType myName(ParType parName) body]]></span>.
Use <span class="code"><![CDATA[class method]]></span> for methods that can be called on the class object directly.
</li><li>
To define a vector of a type, use 
<span class="code"><![CDATA[Collections.vector(of)]]></span>
as in 
<span class="code"><![CDATA[Points: Collections.vector(of: Point)]]></span>
</li></ul>


</p><h2> Object creation recall </h2> <p>
42 supports many different syntactic forms that are convenient to create objects: 
<ul><li>
12Num:  from a numeric representation
</li><li>
S"foo":  from a string representation
</li><li>
Point(x: _,y: _):  from the parameter values
</li><li>
Points[_;_;_]:  from a variable length sequence of values; for example <span class="code"><![CDATA[Points]]></span> can be a list of <span class="code"><![CDATA[Point]]></span>. We can instantiate <span class="code"><![CDATA[Points]]></span> by using the square brackets as shown later. 
</li></ul>

Note that in 42 those are all just expressions, and represent methods in the named class.
Sometimes it is convenient to reuse this kind of syntax to get better syntactic support for certain operations; for example, the string class uses square brackets to support string formatting.
<a href="S.xhtml">To understand it better:  a guide to the S class</a>

 </p><p id="ModifiersIntro"> </p><h1> Keep control:  Modifiers, kinds of classes/references/objects </h1> <p>

</p><h2> (1/5)Kinds of classes </h2> <p>
<span class="code"><![CDATA[Point]]></span> is an <span style="color:#ff1111; font-weight: bold;"> Immutable class: </span> 
 none of its fields can be <span style="color:#ff1111; font-weight: bold;"> updated </span> 
or <span style="color:#ff1111; font-weight: bold;"> mutated. </span>
Immutable classes are very easy to use but may be inadequate when representing real objects, whose state can changes across time.
A <span style="color:#ff1111; font-weight: bold;"> Mutable class </span> is a class where the state of (some of) its instances may be mutated.

Let's now declare a <span class="code"><![CDATA[Animal]]></span> mutable class, whose location can be updated.
<pre class="l42Big"><![CDATA[
Animal: Data<<{
  var Point location

  mut method
  Void run() 
    this.location(this.location().add(x: 20Num))
  }
]]></pre>
There are two new keywords used here: 
<ul><li>
the <span class="code"><![CDATA[location]]></span> field is declared <span class="code"><![CDATA[var]]></span>.
  This is called a variable field, and can be <span style="color:#ff1111; font-weight: bold;"> updated </span> by calling a setter.
  Non variable fields can not be updated
</li><li>
  the modifier <span class="code"><![CDATA[mut]]></span> in front of the method. 
  We have seen <span class="code"><![CDATA[class]]></span> already, an we have seen methods with the default modifier ( 
<span class="code"><![CDATA[add(x)]]></span> and
<span class="code"><![CDATA[add(y)]]></span> ).
  <span class="code"><![CDATA[mut]]></span> methods can mutate the "this" object. If you have experience with C++
  you can see the relationship with <span class="code"><![CDATA[const]]></span> methods.
  immutable (default) methods works only on immutable "this" objects. We will see later much more about modifiers
</li></ul>

</p><p>
As you see, we are using the <span class="code"><![CDATA[add]]></span> method from before.
Also notice that we are using a setter here, where we are providing the first parameter without the argument name.
While this is usual in other languages, in 42 parameters are selected by name.
However, for some methods with a single parameter, writing down the parameter name would not improve the readability and just add noise.
In those cases, the first parameter is conventionally called <span class="code"><![CDATA[that]]></span>, 
and writing <span class="code"><![CDATA[a.b(that: c)]]></span>
is equivalent to writing <span class="code"><![CDATA[a.b(c)]]></span>.
This works also for methods with multiple parameters, if the first one is called <span class="code"><![CDATA[that]]></span>.
We can use an animal by writing, for example: 

<pre class="l42Big"><![CDATA[
  mut Animal dog1=Animal(location: Point(x: 0Num, y: 0Num))
  dog2=Animal(location: Point(x: 0Num, y: 0Num)) //type 'mut Animal' inferred
  dog1.run()
]]></pre>

</p><h2> (2/5)Interaction between mutable and immutable </h2> <p>

We now explore some interaction between mutable and immutable objects.
<pre class="l42Big"><![CDATA[
Animal: Data<<{
  var Point location
  mut Points path
  mut method
  Void move() 
    this.location(path.left()))
    this.#path().removeLeft()
  }
]]></pre>


Here we use <span class="code"><![CDATA[mut Points path]]></span> to denote a mutable list of points. Note the absence of <span class="code"><![CDATA[var]]></span>; this is conceptually similar to a <span class="code"><![CDATA[Points * const path;]]></span> in C++  or <span class="code"><![CDATA[final Points path;]]></span> in Java.
To contrast, the declaration <span class="code"><![CDATA[var Point location]]></span> is similar to
<span class="code"><![CDATA[Point const * location;]]></span> in C++  or <span class="code"><![CDATA[ImmPoint location;]]></span> in Java (for an opportune <span class="code"><![CDATA[ImmPoint]]></span> class).
That is, 
mutable objects can be referred using mutable references,
Immutable objects can be referred using immutable references.
</p><p>
The method <span class="code"><![CDATA[move]]></span>
first use the <span class="code"><![CDATA[location(that)]]></span> setter method to update the <span class="code"><![CDATA[location]]></span> field,
then uses the <span class="code"><![CDATA[#path()]]></span>
 <span style="color:#ff1111; font-weight: bold;"> exposer </span> method and 
the <span class="code"><![CDATA[removeLeft()]]></span> method to mutate the list of points.
Both exposers and getters provide access to the value of a field;
Exposer are used to access the value of mutable fields.
Exposers should be used with care: taking access to parts of a mutable 
state of an object could cause 
spooky action at a distance effects by aliasing.

In general, methods starting with # should be used with care.
</p><p>
This code models an animal following a path. It can be used like this.
<pre class="l42Big"><![CDATA[
zero=Point(x: 0Num, y: 0Num)
ps1=Points[ Point(x: 12Num, y: 20Num);Point(x: 1Num, y: 2Num)]
ps2=Points[ zero;Point(x: 1Num, y: 2Num)]
dog1=Animal(location: zero, path: ps1)
dog2=Animal(location: zero, path: ps2)
dog1.move()
dog2.move()
]]></pre>

In this code the first dog goes to 12: 20.
The second dog goes to 0: 0. 

This code involves a mutable animal with a mutable field. This is often
a terrible idea, since its behaviour may depend on aliasing:  what happens if two dogs follow the same path?
<pre class="l42Big"><![CDATA[
zero=Point(x: 0Num, y: 0Num)
ps=Points[ Point(x: 12Num, y: 20Num);Point(x: 1Num, y: 2Num)]
dog1=Animal(location: zero, path: ps)
dog2=Animal(location: zero, path: ps)
dog1.move()
dog2.move()
]]></pre>
The first dog moves and consumes the path for the second one as well.
That is, the first goes to 12: 20 and the second goes to 1: 2.

This is because <span class="code"><![CDATA[Animal]]></span> is now a <span style="color:#ff1111; font-weight: bold;"> Deeply mutable class: </span>  a mutable class with mutable fields. 
An amazing amount of bugs are caused by the usage of deeply mutable classes.

Note how we are using the exposer <span class="code"><![CDATA[#path()]]></span>
in a safe pattern: only called over the <span class="code"><![CDATA[this]]></span> receiver, and the reference does not leak out of the method.
The problem here arise since the object was shared to begin with. 

</p><h2> (3/5)Capsules:  Keep aliasing graphs untangled </h2> <p>

This tricky behaviour is correct for a 
deeply mutable class. 
In 42 we can change <span class="code"><![CDATA[Animal]]></span> to prevent this aliasing issue.
<pre class="l42Big"><![CDATA[
Animal: Data<<{
  var Point location
  capsule Points path
  mut method
  Void move() 
    this.location(path.left()))
    this.#path().removeLeft()
  }
]]></pre>
Now we use the modifier <span class="code"><![CDATA[capsule]]></span>, this requires the field to be encapsulated with respect to aliasing.
Immutable objects do not influence aliasing, so they are free from aliasing limitations.

</p><p>
The <span class="code"><![CDATA[capsule]]></span>
 modifier <span style="color:#ff1111; font-weight: bold;"> forces </span> the users to provide well encapsulated values,
 and <span style="color:#ff1111; font-weight: bold;"> ensure </span> 
 the <span class="code"><![CDATA[Animal]]></span> data is well encapsulated.
</p><p>

Now the code from before would not compile. However we can still write the following variant
<pre class="l42Big"><![CDATA[
zero=Point(x: 0Num, y: 0Num)
capsule Points ps=Points[ Point(x: 12Num, y: 20Num);Point(x: 1Num, y: 2Num)]
dog1=Animal(location: zero, path: ps)
dog2=Animal(location: zero, path: Points[ Point(x: 12Num, y: 20Num);Point(x: 1Num, y: 2Num)])
dog1.move()
dog2.move()
]]></pre>
Where the <span class="code"><![CDATA[ps]]></span> local binding is declared capsule; 
it can satisfy the Animal.path requirement, but it can be used only once.
<span class="code"><![CDATA[dog2]]></span>
has to use another capsule. It is okay to just write the object creation in place as is done.
Alternatively, most classes offer a <span class="code"><![CDATA[clone()]]></span> method,
so in this case we could write

<span class="code"><![CDATA[dog2=Animal(location: zero, path: dog1.path().clone())]]></span>


</p><h2> (4/5)Handle mutability </h2> <p>

</p><h2> Immutable objects of Mutable classes </h2> <p>

How can we get an immutable <span class="code"><![CDATA[Animal]]></span>?
When an <span class="code"><![CDATA[Animal]]></span> is created using <span class="code"><![CDATA[Animal(location: __,path: __)]]></span> we create a <span class="code"><![CDATA[mut Animal]]></span>.

In most cases you can promote such reference to immutable/capsule; just make the type of the local binding explicit.
 The type system will take care of the rest.
If a reference can not be safely promoted to immutable/capsule, you may have to use the <span class="code"><![CDATA[.clone()]]></span> method or to refactor your code.
<pre class="l42Big"><![CDATA[
mut Animal dog1=Animal(__) //no promotion here
Animal dog2=Animal(__) //promotion mutable->immutable
dog1.move()
//dog2.move()  //ill-typed, requires a mut Animal
]]></pre>

We will explain later the exact rules for promotion,
the main idea is that if the initialization expression uses local bindings in a controlled/safe way, then promotion can be applied.
For example, a mutable expression using only capsule or immutable references can be promoted to capsule or immutable, as we prefer.

</p><h2> Exposers and getters: mutable, lent and read </h2> <p>

As we had seen before, exposers are needed to 
access a mutable reference for a mutable field.
In case of capsule fields, the exposer will provide a <span class="code"><![CDATA[lent]]></span> reference; that is:
a hygienic mutable reference allowing mutation but not long term storage.

Lent references are a supertype of mutable references and can not be stored in mutable/capsule/immutable fields.
A single lent reference in a subexpression can be temporary promoted to a mutable references.
for example, when doing 
<span class="code"><![CDATA[this.#path().removeLeft()]]></span>
the reference produced by <span class="code"><![CDATA[this.#path()]]></span> is promoted to mutable in order to call
the mutable method <span class="code"><![CDATA[removeLeft()]]></span>.

When access to a mutable reference is not needed, one can use
a normal getter also for mutable fields.
In this case, a <span class="code"><![CDATA[read]]></span> reference is provided.

In general, we can 
use <span class="code"><![CDATA[read]]></span> when we not care about the mutability of an object.
For example, we could add to <span class="code"><![CDATA[Animal]]></span>

<pre class="l42Big"><![CDATA[
read method
Bool hasArrived()
  this.path().isEmpty()
]]></pre>
This method can be called to mutable and immutable animals: 

<pre class="l42Big"><![CDATA[
Debug(dog1.hasArrived())
Debug(dog2.hasArrived())
]]></pre>

</p><h2> (5/5) Recall </h2> <p>
  
</p><h2> Kinds of classes, summary </h2> <p>
  
<ul>
<li>
immutable classes:  have only immutable fields.
It is useful to model mathematical concepts.
It is easy to reason about code using immutable classes,
but some properties of real objects can be better modelled with state mutation.
</li><li>
shallow mutable classes:  have only (variable) fields of immutable or capsule type (or class, as we will see later). 
Reasoning with shallow mutable classes is near as easy as reasoning with immutable ones, and often more natural.
</li><li>
deep mutable classes:  have mutable fields.
Reasoning with deep mutable classes can be very hard.
</li></ul>
  
</p><h2> Modifiers: summary </h2> <p>

<ul>
<li>
immutable:  the default. When you omit the modifier,
 you mean immutable. 
An immutable reference points to an object that is never changing. Its whole reachable object graph never changes and is immutable as well.

</li><li>
mutable:  A mutable reference behaves like a normal reference in Java, C#, C++ , Python and many other languages.
Mutable references require mutable objects and allow mutating the referred object.
</li><li>
capsule:  capsule references are used only once and they guarantee that the whole reachable object graph is reachable only thought that
capsule reference. 
Capsule references provide a structured way to reason over deep mutable objects.

Fields can be annotated capsule, the meaning is that they need to be initialized/updated with capsule variables.
We will discuss more about capsule fields and how they differs from capsule references later.
 
</li><li>
read:  A readable reference can not be used to mutate the referred object; but other mutable references pointing to the same object can mutate it.
Read references can point to both mutable and immutable objects.
It is easy to be confused between read and immutable references.
As a rule of thumb, if you are in doubt about whether to use an immutable or a readable reference,
you probably want an immutable reference.

</li><li>
lent:  a hygienic mutable reference allowing mutation but not storage.
Lent and read are useful to handle in controlled way the state of deep mutable classes;
moreover using lent and read on method parameters 
allows to make explicit what are the method intentions and requirements.
</li><li>

class:  class references denote the class object,
  on methods the meaning is the same of static methods in many languages, but it can consistently be used on parameters/local variables/fields
to encode behaviours similar to dependency injection.


</li></ul>



</p><h2> Kinds of objects, summary </h2> <p>

<ul>
<li>
immutable: immutable objects 
 can be instances of immutable classes, or promoted instances of mutable classes.
 They
can be referred to only by immutable and read references.
</li><li>
mutable:  mutable objects are instances of mutable classes.
They can be referred to by capsule, mutable, lent and read references.
</li><li>
class:  class objects can be accessed from anywhere by using the corresponding class name;
It is also possible to 
store them into local binding, but they can be referred to only by class references,
either of their class or any of the 
transitively implemented interfaces.
Some programmers found the fact that class objects are instances of themselves deeply concerning
or disturbing, while for others it is just a good story to tell to break the ice at parties.
</li></ul>

 </p><p id="BasicClasses"> </p><h1> Base </h1> <p>

An immutable class is <span style="color:#ff1111; font-weight: bold;">  </span>{base/basic}
if is logically not composed by other elements,
and can be instantiated by a single operations that takes no parameters.
For examples numbers and strings are basics, while
collections are not: you need to provide the elements and they are logically
composed by their elements.
In the examples of before, <span class="code"><![CDATA[Point]]></span> and 
<span class="code"><![CDATA[Animal]]></span> are not basic, since they are logically composed by their fields.


</p><h2> (1/5) Num and Size </h2> <p>
<span class="code"><![CDATA[Num]]></span> is a general number type,
implemented as an arbitrary precision rational.
When in doubt of what numeric type to use, <span class="code"><![CDATA[Num]]></span>
is a good first guess.
Some examples of usage:
<pre class="l42Big"><![CDATA[
little=123Num
stillLittle=4567890Num
big=100000000000000000Num
bigger=100000000000000000.0001Num
fraction=Num"123/4567890"
hold= fraction == little/stillLittle
Debug(fraction)
Debug(Num"12/4") //will print "3"
]]></pre>

Another useful numeric type is <span class="code"><![CDATA[Size]]></span>.
It represents sizes and indexes in sequences.
<span class="code"><![CDATA[Size]]></span>s are returned by <span class="code"><![CDATA[size()]]></span> methods
and are expected as parameter by indexing methods.
<span class="code"><![CDATA[Size]]></span> represent 32 bit numbers with the usual 
but triky modulo arithmetic.

</p><h2> Loading other numeric types </h2> <p>

You can import other numeric types by loading libraries.
For example

<pre class="l42Big"><![CDATA[
Int:Load<<{reuse L42.is/Numbers/Int}//not supported yet
//infinite precision positive and negative integer numbers
Double:Load<<{reuse L42.is/Numbers/Double}//not supported yet
//double precision positive and negative floating points numbers
Float:Load<<{reuse L42.is/Numbers/Float}//not supported yet
//single precision positive and negative floating points numbers
Int64:Load<<{reuse L42.is/Numbers/Int64}//not supported yet
//64 bit modulo arithmetic
UInt64:Load<<{reuse L42.is/Numbers/UInt64}//not supported yet
//64 bit modulo arithmetic, unsigned
]]></pre>

The class decorator <span class="code"><![CDATA[Load]]></span> allows to load libraries and embed them in the 
current context, while the
reuse keyword imports the code from the web.

</p><h2> Conversions </h2> <p>
Conversions between various numeric classes must be performed explicitly.

AdamTowel offers a simple way to convert between numeric classes, and more in general
between base classes.
All numeric  classes implements
the <span class="code"><![CDATA[Base]]></span> interface and offering the <span class="code"><![CDATA[.from(base)]]></span> method.
So, for example 
<pre class="l42Big"><![CDATA[
Double:Load<<{reuse L42.is/Numbers/Double}
size=S"hello".size()
myDouble=Double.from(base:size)
]]></pre>
converts from <span class="code"><![CDATA[Size]]></span> to <span class="code"><![CDATA[Double]]></span>.
This avoid precision loss as much as possible.




</p><h2> (2/5) Units </h2> <p>


The class 
<span class="code"><![CDATA[Units]]></span>
offers methods to create units out of numeric supports, like <span class="code"><![CDATA[Num]]></span>
and <span class="code"><![CDATA[Size]]></span>.

For example
<pre class="l42Big"><![CDATA[
Meter:Units.of(Num)
Second:Units.of(Num)
res=(6Meter +4Meter)*2Num //20Meter
//wrong1=6Meter+2Second
//wrong2=6Meter/2Second
]]></pre>
As you can see, we can sum meters together, and we can use the support for multiplication, but we can not mix different units of measure.


Mathematically you can obtain the support out of the unit by
division: <span class="code"><![CDATA[42Meter/2Meter = 21Meter]]></span>.
This do not work directly in 42, since multiplication and division
takes the support and not a unit.
Units provide method <span class="code"><![CDATA[div(that)]]></span> for this aim.
Units also provide method  <span class="code"><![CDATA[#inner()]]></span>,
this is just extracting the value of the support from the unit.
This can be convenient during programming but 
does not make a lot of sense mathematically.
Methods like that are required to be used with care, so they start with
<span class="code"><![CDATA[#]]></span> to underline that.

<pre class="l42Big"><![CDATA[
Num n1=42Meter.div(2Meter)//=21Num
Num n2=42Meter.#inner()//=42Num
]]></pre>



</p><h2> Composite Units </h2> <p>

<span class="code"><![CDATA[Units]]></span> supports composite units:
<pre class="l42Big"><![CDATA[
Speed:Units.of(Meter per:Second)
fast1=Speed(42Meter per:0.1Second)
fast2=Speed"42/0.1"
distance1=fast1.per(60Second)

Acc:Units.of(Speed per:Second)
g=Acc"9.8"
speedAfter=g.per(10Second)//98 m/s
distance2=speedAfter.per(10Second)/2Num //490 m after 10s free fall

Kg:Units.of(Num)
Newton:Units.of(Kg and:Acc)//Kg*m/s2
myRoket=900Newton
gForceOnMe=Newton(78Kg and:g)//little less than 780
myLift=myRoket-gForceOnMe
if myLift>0Newton (Debug(S"I can fly"))
myAcc=myLift.div1(78Kg)//get second component
reachedHeight=myAcc.per(10Second).per(10Second)/2Num //after 10 sec
]]></pre>
Note how we can use <span class="code"><![CDATA[.per()]]></span>,
 <span class="code"><![CDATA[.div1()]]></span> 
 and <span class="code"><![CDATA[.div2()]]></span> to extract the first or the second component
 in a composed unit.
</p><p>
We can also declare aliasing units:

<pre class="l42Big"><![CDATA[
Cm:Units.alias(0.01Meter)//not supported yet
Meter height=178Cm
]]></pre>

Note how height is of type <span class="code"><![CDATA[Meter]]></span>.
Alias units are just shortcut to declare values of
the original unit.




</p><h2> (3/5) Alphanumeric </h2> <p>
In the same way <span class="code"><![CDATA[Units]]></span> allows easy creation of
arithmetic classes,
<span class="code"><![CDATA[Alphanumeric]]></span> allows easy creation of alphanumeric classes:
classes that can be istantiated from a string literal that follow certain 
properties.


<pre class="l42Big"><![CDATA[
Email:Alphanumeric<<{//not supported yet
  S local //fields
  S domain
  class method
  This parse(S that) {
    index=that.indexOf(S"@")//works only for simple emails
    if index==-1 (error this.parseError(S"@ not found"))
    local=that(end:index)//string slicing
    domain=that(start:index+1/ )//string slicing
    if domain.contains(S"@") (error this.parseError(S"multiple @ found"))
    return This(that,local:local,domain:domain)
    }//call the factory with fields plus the original string
}
myEmail=Email"arthur.dent@gmail.com"
Assert.$[// assertions check the truth of some statementes
  myEmail.local() expected:S"arthur.dent";
  myEmail.domain() expected:S"gmail.com";
  myEmail.toS() expected:S"arthur.dent@gmail.com";
  ]
]]></pre>

Note how we can raise an error if the string does not have the shape we expected.
We will see errors/exception in more detail soon.
We can declare fields, and compute their values by parsing the string.
While it is suggested to propagate the original string in the factory,
it is not mandatory, for example you could apply some form of normalization, as shown under:

<pre class="l42Big"><![CDATA[
Email:Alphanumeric<<{/*..*/
  This parse(S that) {/*..google ignore dots anyway..*/
    local=that(end:index).replaceAll(S"." with:S"")
    /*..*/
    return This(local++S"@"+domain,local:local,domain:domain)
    } 
  }
myEmail=Email"arthur.dent@gmail.com"
Assert.$[myEmail.toS() expected:S"arthurdent@gmail.com"]
]]></pre>


</p><h2> (4/5) Enumerations </h2> <p>

Enumerations can be obtained with the <span class="code"><![CDATA[Enumeration]]></span> class, as in the following code.

<pre class="l42Big"><![CDATA[
Direction: Enumeration"north, east, south, west"
/*..*/
n=Direction.north()
s=Direction.south()
Direction.names()==Strings[S"north,S"east",S"south",S"west"]

if n.isNorth() (/*..*/)
else if n.isEast() (/*..*/)

Debug(n)//prints north

e=Direction.fromS(S"east")

with d in Direction.all().vals() (
  Debug(d)//prints all the directions in order.
  )

]]></pre>
Enumerations also come with their customized set and vector type,
we will see more about that when we discuss collections.

</p><h2> (5/5) Recall </h2> <p>

<ul><li>
Base classes are the basic building block for your program;
be sure to declare all the right base classes to establish a convenient vocabulary
to talk about your problem domain.
</li><li>
Use <span class="code"><![CDATA[Num]]></span> as your first guess for numeric types,
if you have special needs, can consider loading a numeric library.
</li><li>
Use <span class="code"><![CDATA[Size]]></span> for indexing linear datastructures like vectors and strings.
Beware of the tricky modulo arithmetic.
</li><li>
Use <span class="code"><![CDATA[Units]]></span> 
and <span class="code"><![CDATA[Alphanumeric]]></span> to give meaning to your constants.
In this way the type system will help you to use values with the semantic you decided.
</li></ul>

 </p><p id="InterfacesAndData"> </p><h1> Interfaces, Concepts and Data </h1> <p>

</p><h2> (1/5)Interfaces </h2> <p>
In 42 interfaces are quite similar to interfaces in other oo languages.
There are however a couple of important differences:

</p><p>
while implementing an interface method, you have not to repeat the
typing.
For example, in the following code, to implement <span class="code"><![CDATA[Shape.draw(that)]]></span> inside
of <span class="code"><![CDATA[Square]]></span>, we do not repeat the types <span class="code"><![CDATA[Void]]></span> and <span class="code"><![CDATA[mut Canvas]]></span>
<pre class="l42Big"><![CDATA[
Shape:{interface
  method Void draw(mut Canvas that)
  }
Square:{implements Shape
  method draw(that){..}
  }
]]></pre>

In 42, we say that the method <span class="code"><![CDATA[draw(that)]]></span> 
implemented in <span class="code"><![CDATA[Square]]></span>
<span style="color:#ff1111; font-weight: bold;"> is defined by </span>
<span class="code"><![CDATA[Shape]]></span>.
Each method is defined in a single point, either the class itself
or a (transitively) implemented interface.
This means that a class can not implement multiple interfaces defining methods
with the same name.
For example, this code is ill-typed:
<pre class="l42Big"><![CDATA[
Card:{interface
  method Num draw()//the value of the drawn card
  }
Gun:{interface
  method Num draw()//the time it takes to drawn the gun
  }
Wrong:{implements Card,Gun//not allowed
  }
]]></pre>


Note that that would be bad 42 code anyway, you should define an
enumeration (or an alphanumeric)
 for your cards and use a <span class="code"><![CDATA[Second]]></span> unit of measure
for the time.

</p><h2> (2/5)Interfaces </h2> <p>
However, interface diamond is allowed, that is, the following code is correct:
<pre class="l42Big"><![CDATA[
Shape:{interface
  method Void draw(mut Canvas that)
  }
Animal:{interface implements Shape
  method Meter run(){..}
  }
Noisy:{interface implements Shape
  method Void play(mut Audio that){..}
  }
LoudCat:{implements Animal, Noisy
  method draw(that){..}
  method run(){..}
  method play(that){..}
  }
]]></pre>

You can further specify the type of an interface method by using the keyword 
<span class="code"><![CDATA[refine]]></span>:
<pre class="l42Big"><![CDATA[
Monster:{interface
  method Monster spawnMinion()
  }
BigMonster:{implements Monster
  refine method BigMonster spawnMinion(){..}
  }
]]></pre>


</p><h2> (3/5)Concepts: ToS, Equals, Classable, ... </h2> <p>
<span class="code"><![CDATA[Concepts]]></span> is a class defined in AdamTowel,
containing interfaces commonly used by many classes.
</p><p>
The most well known one is 
<span class="code"><![CDATA[Concepts.ToS]]></span>, implemented by all objects that can
be converted in human readable strings.

In AdamTowel, all basic classes (as alphanumeric, numeric and units) just print
the string or the number as it is.

</p><p>
Other objects prints their fields content in square brackets.
<span class="code"><![CDATA[Data]]></span> generates a reasonable
<span class="code"><![CDATA[Concepts.ToS]]></span> implementation, following this patter. For fields of interface type,
the class name of the stored instance is also produced.
Strings and numbers are enclosed with double quotes.

</p><p>
Another very well known interface is <span class="code"><![CDATA[Concepts.Equals]]></span>
implemented by objects that can be compared with
<span class="code"><![CDATA[read method Bool equals(Concepts.Equals that)]]></span>.
Such objects usually also define methods <span class="code"><![CDATA[==]]></span> and <span class="code"><![CDATA[!=]]></span>
based on <span class="code"><![CDATA[equals]]></span>, but is not required by the interface.

<span class="code"><![CDATA[Data]]></span> will automatically generate a valid <span class="code"><![CDATA[Concepts.Equals]]></span>
implementation, and derived methods <span class="code"><![CDATA[==]]></span> and <span class="code"><![CDATA[!=]]></span>.
The default implementation of 
<span class="code"><![CDATA[Data]]></span> do not takes in account circular object graphs, and will end up in loop in those cases. We will discuss later how to personalize the behaviour of <span class="code"><![CDATA[Data]]></span>.

</p><p>
Finally, an interface that near every class or interface implements is <span class="code"><![CDATA[Concepts.Classable]]></span>.
It allows to get the class object out of an ordinary instance.
This is very useful when wanting to create an instance based on another.
For example, to create another shape of the same kind of a given shape,
we could do the following:
<pre class="l42Big"><![CDATA[
Shape:{implements Concepts.Classable
  class method This newShape(Color that)
  }
Square:{implements Shape
  Color color
  method newShape(that)//implemented from Shape
    This(color:that)
  method class()//implemented from Concept.Classable
    This//this implementation can be omitted if "Data<<" is used
  }
/*..*/
Shape s=..
s.class().newShape(Color.red())
]]></pre>
Where the interface <span class="code"><![CDATA[Shape]]></span> defines an abstract factory method (that is,
an interface class method returning <span class="code"><![CDATA[This]]></span>)
and class <span class="code"><![CDATA[Square]]></span> implements
 <span class="code"><![CDATA[Shape]]></span> (and thus also <span class="code"><![CDATA[Concepts.Classable]]></span>).
 
 
</p><h2> (4/5)Concepts.Invariant </h2> <p>
 
<span class="code"><![CDATA[Concepts.Invariant]]></span> is another interface implemented very often and
 that can be handled by <span class="code"><![CDATA[Data]]></span>, but in a different way with respect to the former ones:
 An instance of an object is more than just a record storing other objects of various types;
 those values are bond together by an invariant: a property that
 holds for all values of that type.
 AdamTowel and Data use <span class="code"><![CDATA[Concepts.Invariant]]></span> to represent this idea:
 A class that does not implement <span class="code"><![CDATA[Concepts.Invariant]]></span> just have the
 empty invariant enforced by type type of its fields, but the programmer can specify a
 more stringent invariant by implementing <span class="code"><![CDATA[Concepts.Invariant]]></span>, as 
 in the following code:
 
 <pre class="l42Big"><![CDATA[
Margin:Data<<{implements Concepts.Invariant
  var Meter minX
  var Meter minY
  var Meter maxX
  var Meter maxY
  method invariant()
    this.minX()<=this.maxX() & this.minY()<=this.maxY()
  }
]]></pre>

Here we define a class <span class="code"><![CDATA[Margin]]></span> where the invariant
states that the min coordinates have to be smaller that the max ones.

<span class="code"><![CDATA[Data]]></span> will generate code so that the invariant is checked while the object is created
and in any field update.
<span class="code"><![CDATA[Data]]></span> guarantees that no <span class="code"><![CDATA[Margin]]></span> object that does not 
satisfy the invariant will ever be visible outside of the scope of the <span class="code"><![CDATA[invariant()]]></span> method itself.

See more about restrictions of this mechanism in (<a href="dataAndInvariants.xhtml">data and invariants</a>)

The current example shows a class with all immutable fields.
It is possible to enforce the invariant also on classes with immutable
and capsule fields.
Then <span class="code"><![CDATA[Data]]></span> will additionally check that the
lent exposers are used in a safe pattern:
they are used only on the <span class="code"><![CDATA[this]]></span> receiver,
and every method using the lent exposer do not return
a lent result.
It is unobvious why such requirements suffice: the idea is that the only way a mutable/lent reference
to the content of a capsule field can be
accessed is by the exposer. The reference produced by the lent exposer can only be returned as lent,
or wrapped inside of freshly created objects referred to by lent references.
(<span style="color:#ff1111; font-weight: bold;"> note for marco: </span> this means no more lent/read fields)


</p><h2> (5/5)Interfaces and Data, summary </h2> <p>

Interfaces in 42 serves the same role they serve in other languages,
with a little bit of a twist in the details.

The big news is that Decorators (<span class="code"><![CDATA[Data]]></span> in our examples) can
help and provide implementations for free.
This is much more powerful with respect of traits, multiple inheritance or
Java 8 default methods, since the implementation can be generated ad hoc
by examining the class.
 
 </p><p id="ErrorsAndExceptions"> </p><h1> Errors and Exceptions: Messages in AdamTowel </h1> <p>

</p><h2> (1/5)Errors, Messages, Asserts, Guards, .. so much terminology </h2> <p> 
In 42 when something takes an unexpected turn,
you can throw an <span class="code"><![CDATA[error]]></span>
This is similar to Java unchecked exceptions.
Every immutable object can be thrown as an error.
While it is possible to thrown informative strings, they do no offer enough
structure to fully take advantage of the error mechanism.
AdamTowel defines the interface <span class="code"><![CDATA[Message]]></span>:
a structured way to provide a certain kind of message to the user.
<span class="code"><![CDATA[Message]]></span>s has <span class="code"><![CDATA[.text()]]></span> ,
<span class="code"><![CDATA[.isResponse()]]></span> and <span class="code"><![CDATA[.responseOf()]]></span>.
The text is the informative string, while if there is
a response (<span class="code"><![CDATA[msg.isResponse()==Bool.true()]]></span> 
then <span class="code"><![CDATA[msg.responseOf()]]></span> will be the 
former message in the chain.

There are two main kinds of <span class="code"><![CDATA[Message]]></span>s:
<span class="code"><![CDATA[Guard]]></span> and <span class="code"><![CDATA[Assert]]></span>.
While Assertions are useful to observe bugs, the application
logic should not depend on them, since they may change
in unpredictable ways during library evolutions, and can be
enabled or disabled.
A guard is guaranteed to be consistent across library evolution
thus program logic can depend on them being thrown.

Assertions are very convenient to check for pre/post conditions.
The following code show usages of <span class="code"><![CDATA[Assert.Pre]]></span> and <span class="code"><![CDATA[Assert.Bug]]></span>

<pre class="l42Big"><![CDATA[
Assert.Pre[ //preconditions
  myVal>0Nat;//simplest form
  myVal>0Nat msg:S"here with personalized message";
  myVal expected:42Nat //call equals and do a better error reporting
  ]//in a bunch of assertions, they are all going to be checked together.
Assert.Bug[ //postconditions/checks in the middle
  res expected: 42Nat msg:S" message"
  ]
if notGoodParameter (Assert.Pre"error message")
if observedBug  (Assert.Bug"error message")
]]></pre>

</p><h2> (2/5) create, throw and capture </h2> <p>

You can create new kinds of messages using the 
service class of the message interface:

<pre class="l42Big"><![CDATA[
AnswerNotUnderstood:Message.$<<{implements Guard}
//this is a new kind of message, implementing Guard.
//you can also add methods to your kind of message.
//you can add fields, we will see this more in detail later.
/*..*/
//throwing an error
if this.ohNoNoNOOO() (error AnswerNotUnderstood"Well, too bad")

if this.iWasDistracted() (
  //throwing an error in response of another
  Guard other=NotListening""//empty message
  error AnswerNotUnderstood"Try again"(other)
  )

]]></pre>

As you can see, since <span class="code"><![CDATA[Message]]></span> is an interface, it can not help us directly
to create messages, however it has a service nested class called <span class="code"><![CDATA[$]]></span>, that
is a class decorator helping us to create valid messages.
As you can see we can create messages with text, and
then we can optionally add a response.
Now, let see how to capture errors:

<pre class="l42Big"><![CDATA[
(myWait=7.5MillionYear
 answer=DeepThought.answer()
 understanding=myBrain.process(answer)
 catch error AnswerNotUnderstood msg (/*handle it*/)
 catch error Guard msg (/*something else gone wrong*/)
 //in the catch bodies, 'understanding' and 'answer' are not defined
 myBrain.accept(understanding)//normal execution if no issue
 )
]]></pre>

As you see, in 42 there is no explicit <span class="code"><![CDATA[try]]></span> statement,
but any block of code can contain <span class="code"><![CDATA[catch]]></span>.
The catch capture errors in the block before the last (group of) catches.
Catches can not see local variables declared in the scope of a possible error.
The following example explain the control flow more in detail:

<pre class="l42Big"><![CDATA[
res=(
 b1=CanGoWrong()
 b2=CanGoWrong()//see b1
 catch error Wrong msg1  1Nat//not see b1,b2
 catch error Guard msg2  2Nat//not see b1,b2
 b3=CanGoWrong()//can see b1, b2
 catch error Wrong msg3  3Nat//see b1,b2, not see b3
 4Nat//see b1,b2,b3
 )
]]></pre>
The following code can assign to <span class="code"><![CDATA[res]]></span> either 1,2,3 or 4.
Note how every catch exits from the whole block.
Errors guarantee a property called strong error safety
(strong exception safety in the Java/C++ terminology)
This means that the body of a catch will observe the same 
state present at the start of the block.
This is enforced by disallowing catching errors if the (portion of the) block before can mutate visible objects.

That is, the following code do not compile
<pre class="l42Big"><![CDATA[
p=Person(name:S"Bill" age:23Year)
res=(
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Guard msg2  (/*could see p with 23 or 24 years*/)
 p
 )
]]></pre>

While the following is accepted.

<pre class="l42Big"><![CDATA[
res=(
 p=Person(name:S"Bill" age:23Year)
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Guard msg2  (/*can not see p*/)
 p
 )
]]></pre>

</p><h2> (3/5) exceptions and errors </h2> <p>

Exceptions are like checked exceptions in java.
As for errors, every immutable object can be thrown as an exception.
just write "exception" instead of "error" while throwing or capturing.
Exceptions represent expected, documented and reliable behaviour,
they are just another way to express control flow.
They are useful to characterize multiple outcomes for an operation,
where is important to prevent the programmer from forgot about
the many possible outcome and focus only on its preferred one.
Exceptions are checked, so methods leaking exceptions have to
declare so in their header, as in the following.
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
method
S promptUser(S text)
exception CancelPressed {
  /*implementation to open a text dialog*/
  }
]]></pre>
Where the programmer using <span class="code"><![CDATA[promptUser]]></span> will have to handle 
the possibility that the cancel button was pressed.

Exceptions does not enforce strong exception safety as error do,
so they can be used more flexibly, and since they are documented in
the types, we can take their existence in account while writing imperative programs.
<span class="code"><![CDATA[Assert]]></span>ions should not be thrown as exceptions, but only as errors.

Often, the programmer wants to just turn exceptions in errors or other exceptions.
This is possible with the following code:


<pre class="l42Big"><![CDATA[
//long version
DoStuff()
catch exception FileNotFound fnf (
  error WTF"I just created it!"(fnf)
  )

//short version
DoStuff()
error on FileNotFound
  WTF"I just created it!"
]]></pre>
The two snippets of code behave identically: the first
show a very common patter; 42 supports syntactic sugar to
ease following that pattern, as you can see in the second snippet.
<span class="code"><![CDATA[WTF]]></span> stands for what a terrible failure
(as in android), and can be used to mark branches of code
that the programmer believe would never be executed.
<span class="code"><![CDATA[WTF]]></span> implements <span class="code"><![CDATA[Assert]]></span>, thus code capturing
<span class="code"><![CDATA[WTF]]></span> is unreliable.





</p><h2> (4/5) return </h2> <p>

Return, as we have seen, can be used to exit from the inner
most level of curly brackets.
Also curly brackets can have catches, let see some examples
<pre class="l42Big"><![CDATA[
{
x=DoStuff()
catch exception Stuff e1
  void//just swallow the exception
catch exception Guard e2
  obj.doSideEffect()//this method return void
catch exception Message e3
  return e3//a result of the curly brackets
y=DoStuff(x)
return y
error on Guard 
  WTF""
}  
]]></pre>

Moreover, curly brackets/return can be used
to provide a different result if some computation fails:

<pre class="l42Big"><![CDATA[
res={return PlanA()
  catch error Guard x
    return PlanB()
  }
]]></pre>

</p><h2> return looks similar to error/exception </h2> <p>
Return is actually another thing that can be thrown and captured.
While only immutable values can be thrown as errors/exceptions,
return can throw any kind of value, but returns can not flow
outside of the scope of a method.
Hold your head before it explodes, but curly brackets are just a syntactic sugar
 to capture returns; those two snippets of code are equivalent

<pre class="l42Big"><![CDATA[
N res={if bla return e1
  return e2}
//---
N res=(
  Void unused=(
    if bla return e1
    return e2
    )
  catch return N x
    x
  error void//this line is never executed
  )
]]></pre>
Depending on how your brain works,
knowing the desugaring of <span class="code"><![CDATA[{..return..}]]></span>
can help you to use return better and understand why you can omit 
<span class="code"><![CDATA[{..return..}]]></span> for simple method bodies, and why you can
write multiple groups of curly brackets and have local returns.
Or can just be very confusing. If you are in the second group, just
never ever write <span class="code"><![CDATA[catch return]]></span> explicitly and continue
your 42 experience ignoring the issue.


</p><h2> (5/5) Errors, exceptions and return, summary </h2> <p>
<ul><li>
Whenever possible, try to detect if your code misbehave, and 
terminate it with an <span class="code"><![CDATA[Assert]]></span>
</li><li>
Whenever something out of your
control happen, Give it a name and throw it as an error, as in
<pre class="l42Big"><![CDATA[
NameOfIssue:Message.$<<{implements Guard}
/*...*/
if /*..*/ error NameOfIssue"more info"
]]></pre>
It just take 2 lines, and will make debugging your code so much 
easier.
</li><li>
Use errors as much as makes sense, 
but use exceptions sparsely: they are needed only in few 
cases, mostly when designing public libraries.
</li><li>
To convert exception into errors or other exceptions, use the convenient short
syntax <span class="code"><![CDATA[error on T1,..,Tn  OtherMessage""]]></span> or 
<span class="code"><![CDATA[exception on T1,..,Tn  OtherMessage""]]></span>
</li><li>
Sometimes it is possible to write elegant and correct code
that is not covered in layers upon layers of error/exception checking,
but often is not possible or is not convenient.
Good 42 code can be composed for half of
its content of just error/exception handling/lifting and management.
Do not be scared of turning your code in it's own policemen.
</li></ul>
 </p><p id="Sequences"> </p><h1> Sequences high level manipulation </h1> <p>

</p><h2> (1/5)Vectors as Sequences </h2> <p>

As we have seen before, vectors can be declared using <span class="code"><![CDATA[Collections.vector(of)]]></span>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums:Collections.vector(of:Num) //declaration for vectors of nums
/*..*/
Nums xs=Nums[10Num;20Num;30Num] //immutable vector
//note how we declare the type explicitly,
//the default vector would be mutable.
]]></pre>

Immutable sequences are created with square brackets
and can be combined with operators.
The general idea is that operators 
<span class="code"><![CDATA[+]]></span> works 
on one sequences and one element,
while the corresponding doubled-up operators
<span class="code"><![CDATA[++]]></span>
works on two sequences.
In the details, as you can see in the code below:
<pre class="l42Big"><![CDATA[
Nums[a;b;c]+d==Nums[a;b;c;d]
Nums[a;b]++Nums[c;d]==Nums[a;b;c;d]
Nums[a;b;b;c] - b==Nums[a;c] //only if elements implements Concepts.Equals
Nums[a;b;b;c] -- Nums[b;c]==Nums[a] //same for all the operators under
Nums[a;b;c]>>Nums[a;c] //holds
Nums[a;b;c]>>=Nums[a;c] //holds
Nums[a;b]>>=Nums[a;c] //holds
Nums[a;b]>>Nums[a;c] //not holds
Nums[a;b]>b //holds
b<Nums[a;b] //holds
Nums[a;b]& Nums[b;c] //Nums[b] set intersection
]]></pre>

In addition of operators, immutable collections can
be manipulated by the following methods:

<pre class="l42Big"><![CDATA[
//with replacement
Nums[a;b;c;d].withLeft(b) //Nums[b;b;c;d]
Nums[a;b;c;d].withRight() //Nums[a;b;c;b]
Nums[a;b;c;d].with(2Size,d) //Nums[a;d;c;d]

//appending
Nums[a;b;c;d].withAlsoLeft(b) //Nums[b;a;b;c;d]
Nums[a;b;c;d].withAlsoRight() //Nums[a;b;c;d;b]
Nums[a;b;c;d].withAlso(2Size,b) //Nums[a;b;b;c;d]

//filtering
Nums[a;b;c;d].without(index:2Size) //Nums[a;b;d]
Nums[a;b;c;d].withoutLeft() //Nums[b;c;d]
Nums[a;b;c;d].withoutRight() //Nums[a;b;c]

//filtering, if elements implements Concepts.Equals
Nums[a;b;c;d].withoutAll(elem:b) //Nums[a;c;d]
Nums[a;b;c;d].withoutLeft(elem:b) //filter out the leftmost b
Nums[a;b;c;d].withoutRight(elem:b) //filter out the rightmost b
]]></pre>
As you notice, there are three different kind of actions:
replace an element ((<span class="code"><![CDATA[with]]></span>),
append an element (<span class="code"><![CDATA[withAlso]]></span>)
and filtering an element out (<span class="code"><![CDATA[without]]></span>).
Then, elements can be specified by (<span class="code"><![CDATA[index]]></span>), by being
the leftmost or the rightmost. To filter elements
out, you can also just provide the element.

</p><p>


Immutable collections (and also mutable ones, as we will see later)
can be accessed with the following methods:

<pre class="l42Big"><![CDATA[
//access
foo.left() //a
foo.right() //d
foo.val(2Size) //c
foo.size() //4Size
foo.isEmpty() //not holds
]]></pre>





</p><h2> (2/5) Suggested parameter values using "\" </h2> <p>

In 42 is possible to use <span class="code"><![CDATA[\]]></span> while calling a method or using the square brackets,
to ask the receiver for a suggestion about the parameter values.
The library designer have full freedom to implement those suggestion in the more opportune way, however we
recognize three important common patterns:
</p><p>
When setting/updating a value, the old value is suggested.
</p><p>
When adding a new value, the factory is suggested.
</p><p>
When the parameter is a number from zero to a max, the maximum is suggested.
</p><p>
For example:
<pre class="l42Big"><![CDATA[
Nums[a;b;c;d].withAlso(left:42\) //the \ is Num
Nums[a;b;c;d].without(index:\ - 1Size) //remove the last (the right-most)
Nums[a;b;c;d].with(left:\ * 2Num) //the leftmost is now a*2

Points[\(x:12\ y: 0\)]==Points[Point(x:12Num, y:0Num)]
]]></pre>
Sometime, using <span class="code"><![CDATA[\]]></span> makes a huge difference,
for example, for the animal example of before:
<pre class="l42Big"><![CDATA[
horse.location(\.with(x:\+20\)
//is equivalent to the much longer
horse.location(horse.location().with(
  x:horse.location().x()+20Num)
]]></pre>

Is also possible to use <span class="code"><![CDATA[\]]></span> followed by an identifier, that will denote the method
with the same name on the receiver.
For example, if we want to reflect a point, and invert x and y coordinate, we can write

<pre class="l42Big"><![CDATA[
p=point.with(x:\y, y:\x)
//is equivalent to
p=point.with(x:point.y(), y:point.x())
]]></pre>

The <span class="code"><![CDATA[\]]></span> is very convenient also while initializing list/set of enumerated values.
For example

<pre class="l42Big"><![CDATA[
Direction=Enumeration"north, east, south, west"
Direction.Set[\north;\east] //the bitflag corresponding
//to the set of north and east.
//is equivalent to the much longer
Direction.Set[Direction.north();Direction.east()]

p=point.with(x:point.y(), y:point.x())
]]></pre>








</p><h2> (3/5) Mutable sequences </h2> <p>


Mutable sequences can be more efficient that 
immutable ones, and are more general, since they 
can handled mutable objects.
The square brackets creates mutable sequences/collections,
so 

<pre class="l42Big"><![CDATA[
foo=Nums[a;b;c;d]
//equivalent to 
mut Nums foo=Nums[a;b;c;d]
]]></pre>


Now we show some methods over mutable collections, consider each following line independently:
<pre class="l42Big"><![CDATA[
//setting a value in a position
foo(2Size,val:b) //foo.equals(Nums[a;b;b;d])
//setting at left or right
foo.left(b) //foo.equals(Nums[b;b;c;d])
foo.right(b) //foo.equals(Nums[a;b;c;b])

//add a value in a position
foo.add(2Size,val:b) //foo.equals(Nums[a;b;b;c;d])

//add at left or right
foo.add(left:b) //foo.equals(Nums[b;a;b;c;d])
foo.add(right:b) //foo.equals(Nums[a;b;c;d;b])

//removal
foo.remove(index:2Size) //foo.equals(Nums[a;b;d])
foo.removeLeft() //foo.equals(Nums[b;c;d])
foo.removeRight() //foo.equals(Nums[a;b;c])

//removal, if elements implements Concepts.Equals
foo.removeAll(elem:b) //foo.equals(Nums[a;c;d])
foo.removeLeft(elem:b) //remove the leftmost b
foo.removeRight(elem:b) //remove the rightmost b
]]></pre>



Mutable collections can become immutable by promotion; for example,
a method without mutable parameters returning a mutable collection 
can be used to initialize a mutable one.
You may need to explicit the type of the local binding to force the promotion.
For example

<pre class="l42Big"><![CDATA[
Nums myNums=DoIt.getMutableNums() //ok promotions happens, myNums is immutable

myNums=DoIt.getMutableNums() //myNums type is inferred to be mut Nums
]]></pre>

Mutable collections can contains mutable objects.
While this can be useful in special circumstances, it can create aliasing issues similar to the
ones of the animals example of before.
To warn against such issues, methods <span class="code"><![CDATA[left()]]></span>, <span class="code"><![CDATA[right()]]></span> and <span class="code"><![CDATA[val(that)]]></span> return 
readable references of the mutable objects. In order to obtain 
the actual mutable reference, the user need to use the methods
<span class="code"><![CDATA[#left()]]></span>, Wcode(`#right()') and Wcode(`#val(that)').



</p><h2> (4/5) <span class="code"><![CDATA[with]]></span>: a Swiss army knife to encode complex behaviour </h2> <p>


There are two basic usage for the <span class="code"><![CDATA[with]]></span> statement: as for-each and as a typecase.

<pre class="l42Big"><![CDATA[
//as a for each
vec= Strings[S"foo"; S"bar"; S"beer"]
var S result=S""
with myElem in vec.vals() (result:=result++myElem) //like for(myElem:vec){..}
//result==S"foobarbeer"

//as a typecase
with myData=foo.bar() ( //like a typecase/switch/chain of instanceof
  on S  Debug(S"A string "++myData) //print strings
  on Num  void //do nothing if is a number
  on Concepts.ToS Debug(myData) //print stringables that are not numbers. 
  )
]]></pre>

if <span class="code"><![CDATA[myData]]></span> is already declared one can simply write
<pre class="l42Big"><![CDATA[
with myData (
  on S Debug(myData)
  default error WTF"" 
  )
]]></pre>

Those two modes can be combined
<pre class="l42Big"><![CDATA[
vec= Anys[S"foo"; 12Num; S"beer";]
var S result=S""
with myElem in vec.vals() (on S  result:=result++myElem  ) 
//result==S"foobeer", composed by all strings inside vec
]]></pre>

<span class="code"><![CDATA[with]]></span> can be used as list comprehension
<pre class="l42Big"><![CDATA[
vec=Anys[S"foo"; 12Num; S"beer";]
v=Strings[with myElem in vec.vals() (on S use[myElem] )] //filter non strings
//v==Strings[S"foo"; S"beer";]
]]></pre>

for multiple dispatch:

<pre class="l42Big"><![CDATA[
method Num m(Shape x, Person y, Vehicle z) //example of method using with
 with x y z (
 on Square Student Car (..return ..) //x here is a Square
 on Circle Person Airplane (..) //x here is a Circle
 default (..) //default case, here x is just a Shape
  )}
]]></pre>

Or to iterate over multiple collections at once
<pre class="l42Big"><![CDATA[
rs=Nums[1\;2\;3\;]
as= Nums[10\;20\;30\;]
bs= Nums[100\;200\;300\;]
//here a, b and r iterate over my data
with a in as.vals(), b in bs.vals(), var r in rs.vals() (r:=r+a+b)
//now rs==Nums[111\;222\;333\;]
]]></pre>

While iterating on multiple collections, a dynamic error is usually raised if 
<span class="code"><![CDATA[rs]]></span>,
 <span class="code"><![CDATA[as]]></span> and
 <span class="code"><![CDATA[bs]]></span> have different length.
This behaviour can be tuned in many way:
iterators can be parametrized with
<span class="code"><![CDATA[from:]]></span> , <span class="code"><![CDATA[to:]]></span>, <span class="code"><![CDATA[fill:]]></span> and 
<span class="code"><![CDATA[stopOk:]]></span> (I need a better name for this last one).

<span class="code"><![CDATA[from:]]></span> and <span class="code"><![CDATA[to:]]></span> are on default zero and the sequence length,
and can be specified to start from another value, like 1 or 2, and
to end before the very end.

<span class="code"><![CDATA[fill:]]></span> can be used in combination with 
<span class="code"><![CDATA[from:]]></span> and <span class="code"><![CDATA[to:]]></span>
to iterate outside of the sequence range.
If <span class="code"><![CDATA[fill:]]></span> is used without specifying <span class="code"><![CDATA[to:]]></span>, the
sequence is considered infinite and iteration may go on forever.

<span class="code"><![CDATA[stopOk:]]></span> is useful when multiple collections are iterated at once,
and specify the minimal allowed iteration cycles (suggested value is 0).
Let see some examples:
<pre class="l42Big"><![CDATA[
with x in xs.vals(), y in ys.vals(fill:10N)
//will iterate for as long as xs, even if ys is shorter
//will stop after xs.size() cycles, and fail if xs.size()<ys.size()

with x in xs.vals(), y in ys.vals(fill:10N stopOk:\)
//will iterate for as long as xs, even if ys is shorter
//will stop after xs.size() cycles

with x in xs.vals(stopOk:\), y in ys.vals(stopOk:\)
//will iterate for as long as both xs and ys have elements

with x in xs.vals(fill:10N), y in ys.vals(fill:10N)
//will go on forever

with x in xs.vals(stopOk:5N), y in ys.vals(from:1N to: \ - 1N stopOk:3N )
//will extract at least 5 elements from xs, will skip the first 
//and the last element of ys and extract at least 2 elements from ys.
]]></pre>


And, in a case similar of before:
<pre class="l42Big"><![CDATA[
rs=Nums[1\;2\;3\;]
as= Nums[10\;20\;30\;40\;50\;]
bs= Nums[100\;200\;]
with a in as.vals(stopOk:\), b in bs.vals(fill:300Num), var r in rs.vals() (
  r:=r+a+b)
//rs==Nums[111\;222\;333\;]
]]></pre>


</p><h2> Strings interpolation, even better with <span class="code"><![CDATA[with]]></span> </h2> <p>

Alphanumeric classes and strings can be seen as immutable
sequences of Strings of length 1.

All the operators working on immutable sequences works on strings and alphanumerics.

However, they can not be constructed with square brackets, that is <span class="code"><![CDATA[S[a;b;c]]]></span> does not compile.
Square brackets can be used to interpolate strings and alphanumerics; as in:
<pre class="l42Big"><![CDATA[
S"hello "[name]", have a good day, and do not panic!"
]]></pre>
However, also <span class="code"><![CDATA[with]]></span> can be used; this can make code very compact,
for example assume we want to collect some names and numbers in a string:
<pre class="l42Big"><![CDATA[
res=S"your info: "[with name in names.vals(), num in nums.vals()  (
  use[ S"name:"[name]", num:"[num]""]
  )]"" //we always need the ending string, even if empty.
]]></pre>
In order to put a semicolon between elements in our string, we can use <span class="code"><![CDATA[sep:]]></span>
<pre class="l42Big"><![CDATA[
res=S"your info: "[with name in names.vals(), num in nums.vals()  (
  use[ S"name:"[name]", num:"[num]"", sep:S"; "]
  )]"" //we always need the ending string, even if empty.
]]></pre>


</p><h2> (5/5) Collections summary </h2> <p>

<ul><li>
There are a tons of methods and operators to know, but since most code works 
around collections, it is worth the effort to memorize them.
</li><li>
Immutable collections are easy to play with, using operators and with methods.
</li><li>
Mutable collections can be more efficient and flexible, but they come with additional
difficulties.
</li><li>
Most methods have a general version that works with an index, and specialized <span class="code"><![CDATA[left]]></span> and
<span class="code"><![CDATA[right]]></span> variants.
</li><li>
<span class="code"><![CDATA[/]]></span> can help remove a lot of boilerplate, but is not trivial to get used to it.
</li><li>
<span class="code"><![CDATA[with]]></span> is very useful and flexible. It is common to find methods composed be just a large
<span class="code"><![CDATA[with]]></span> statement plus a little pre and post processing around it.
</li></ul>
 </p><p id="Exercises"> </p><h1> Exercises </h1> <p>

A very large class of practically useful programs can be obtained by
just declaring
elemental classes, collections
and simple Data classes.

Let's see some exercses and solutions 
to understand better how 42 code looks like

</p><h2> (1/5) Max method </h2> <p>
write a class method max returning the max from a list of numbers
</p><p>
Solution:
<pre class="l42Big"><![CDATA[
UndefinedOnEmpty:Message.$<<{implements Guard}
//Max is undefined on empty lists.
//Since there was no mention of preconditions,
//we should explicitly handle all the error cases!
class method
Num max(Nums that) {
  if that.isEmpty() (error UndefinedOnEmpty"Max is undefined on empty lists")
  //now that we know we can proceed:
  var Num maxCandidate=that.left()
  //there is no such thing like a minimum number,
  //we need to select one element from the list.
  with n in that.vals() (
    //we could write that.withoutLeft().vals()
    //to avoid cheching on the first again
    if maxCandidate<n (maxCandidate:=n)
    //update the variable to keep track of the max so far.
    )
  return maxCandidate
  }
]]></pre>

</p><h2> (2/5) Merge two lists of strings </h2> <p>
Write a class method map producing a string from to lists of stirngs of the same lenght.
 For example
<span class="code"><![CDATA[map(keys:Strings[S"a";S"b";S"c"],vals:Strings[S"z";S"y";S"z"])]]></span>
should produce <span class="code"><![CDATA[S"[a->z, b->y, c->z]"]]></span>

Solution:
<pre class="l42Big"><![CDATA[
UnequalSize:Message.$<<{implements Guard}
class method
S map(Strings keys, Strings values) (
  if keys.size() != values.size() (error UnequalSize"keys="[keys.size()]", values="[values.size()]"" )
  S"["[with k in keys.vals(), v in values.vals() (
    use[k++S"->"++v, sep:S", "]
    )]"]"
  //no need to use return, the result is the last element in round brakets
  )
]]></pre>

</p><h2> (3/5) Filtering </h2> <p>
Write a <span class="code"><![CDATA[class method Strings upTo(Strings that, Size size)]]></span> that filters out from a list of strings the ones longer
than size.
For example 
<span class="code"><![CDATA[upTo(Strings[S"a";S"ab";S"abc"],size:2Size)==Strings[S"a";S"ab"]]]></span>
Precondition: size is not negative
Solution:
<pre class="l42Big"><![CDATA[
class method
Strings upTo(Strings that, Size size) (
  Assert.Pre[size>=0Size]
  Strings[with s in that.vals() (
    if s.size()<=size (use[s])
    )]
  )
]]></pre>

</p><h2> (4/5) Random mole </h2> <p>
For a longer example, represent a piece of land as a 80*80 bidimensional vector,
where every cell can be full of dirt (90%) or rock (10%).
Then a mole start from the left top corner and attempts to
digs throught dirt randomly.
After 100 steps the mole stops.
declare the opportune classes and write a randomDig
method. You can use the library <span class="code"><![CDATA[L42.is/Random]]></span>
for randomness. You can use <span class="code"><![CDATA[Range(stop)]]></span> to iterate over
all (<span class="code"><![CDATA[Size]]></span>) nubers from 0 to <span class="code"><![CDATA[stop]]></span>-1 included.

A possible solution:
<pre class="l42Big"><![CDATA[
Random:Load<<{reuse L42.is/Random}

Cell:Enumeration"dirt, rock, empty, mole"

Direction:Enumeration"up, down, left, right"

Point:Data<<{implements Concept.Invariant
  Size x,Size y
  method invariant()
    x>=0Size & x<80Size & y>=0Size & y<80Size
  This go(Direction that) {
    if that.isUp() (return this.with(x:\-1Size))
    if that.isDown() (return this.with(x:\+1Size))
    if that.isLeft() (return this.with(y:\-1Size))
    Assert.Bug[that.isRight()]
    return this.with(y:\+1Size)
    catch error Concept.Invariant.Failure err
      return this
    }
  }

Land:Data<<{(mut Cell.List cells)
  
  class method
  mut This ()
    This(cells:Cell.List[
      with i in Range(stop:80Size*80Size) (
        if Random(10Size)==0Size (use[Cell.rock()])
        else (use[Cell.dirt()])
        )
      ])   

  mut method
  Void randomDig() (
    dirs=Directions.List.all()
    var Point current=Point(x:0Size,y:0Size)
    with i in Range(stop:100Size) (
      this.set(current,val:Cell.empty())
      d=dirs.val(Random(4Size))
      newPoint=current.go(d)
      if !this.get(d).isRock() (//no digging in rock
        current:=newPoint
        )
      )
    this.set(current,val:Cell.mole())
    )
  
  //implementation of the matrix as an example,
  //should be imported from a library
  mut method 
  Void set(Point that, Cell val)
    this.#cells()(that.y()*80Size+that.x(), val:val)
    
  read method 
  Cell get(Point that)
    this.#cells().val(that.y()*80Size+that.x())    
  
  toS()(//since we define it explicitly, Data will leave it alone :)
    S""[with x in Range(stop:80Size)
      use[S.nl()]//newline
      with y in Range(stop:80Size) (
        p=Point(x:x,y:y)
        if this.get(p).isRock() (use[S"#"])
        else if this.get(p).isDirt() (use[S"%"])
        else if this.get(p).isEmpty() (use[S" "])
        else (Assert.Bug[this.get(p).isMole()] use[S"M"])         
      )]"")
  }
]]></pre>


</p><h2> (5/5) Examples summary </h2> <p>
<ul><li>
Always think about what can go wrong upfront
</li><li>
Most methods can be completed by first checking for 
errors/issues and then using a <span class="code"><![CDATA[with]]></span>
</li><li>
Before heading into a problem,
spend some time to define your problem domain.
We dogded a lot of headeches by defining
points with invariants.
</li></ul>

Some may argue that in a real object oriented implementation,
directions and cells should be interfaces with subtypes;
so that we can use single dispatch to
avoid the cascades of ifs.
We have mixed feelings about this:
shorter code is better and more maintainable then longer code, and the version with subtyping would have been much longer.

The crucial point is that that code is not designed to be used by other programmers as a library.
Libraries should have well modularize code,
and provide covenient hooks for adaptation.
Metaprogramming and interfaces are the right tool for this task.

We should not counfond adaptability (without touching the original source, make it so that a new problem can be tackled), with maintenability (change the original source to keep it up to date
with the everchaning set of requirements).
 </p><p id="ExamplesOfLibraries"> </p><h1> Example of Libraries </h1> <p>

</p><h2> (1/5)Gui </h2> <p>
42 stands for the primate of libraries, so let see some libraries in action.
We have already see how to chose a towel, and many classes that are likely to be present in such towel, like
<span class="code"><![CDATA[S]]></span> and <span class="code"><![CDATA[Data]]></span>.
Let see now how to load a library from its url:
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Gui: Load<<{reuse L42.is/Gui}
Main:{
  Gui.alert(S"hi!")
  return ExitCode.success()
  }
}
]]></pre>
Load is another decorator, here it modifies the library found in L42.is/Gui
 so that it can be used easily from AdamTowel.

Gui allows to create graphical user interfaces using html.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Gui: Load<<{reuse L42.is/Gui}
MyGui:Gui(
  title:S"My Gui"
  basePath:S"base/path/for/my/files"// use / on all op systems
  x:600Gui.Pixel//seek for index.html in your basePath
  y:400Gui.Pixel
  )<<{
  mut method
  Void event_quit(mut Gui gui, S msg)
    gui.close()

  mut method
  Void event_sayHi(mut Gui gui, S msg)
    Gui.alert(S"hi")

  mut method
  Void event_say(mut Gui gui, S msg) (
    //msg is going to be a multiline string,
    //first line equal to "say", other lines give more info
    Strings ss=msg.split(S.nl())
    Gui.alert(S"hi dear "+ss.val(1\))
    )
  }

Main:MyGui()
}
]]></pre>
And the file <span class="code"><![CDATA[index.html]]></span>
would look like:
<pre class="l42Big"><![CDATA[
//add html, css and javascript formatting
<html>
<head>
</head>
<body>
Hi, buttons here
<Button onclick='event42("quit");'> Quit</Button>
<Button onclick='event42("sayHi");'> Say Hi</Button>
<Button onclick='event42("say\ncaterpillar");'> Say Hi</Button>
</body>
</html>
]]></pre>
Do not forget the two layers of quotes: you need to quote both the call to <span class="code"><![CDATA[event42]]></span>
and the string codifying the event itself.

To make something happen in the gui, you can use 
<span class="code"><![CDATA[gui.executeJs(cmd)]]></span>.
For example
<pre class="l42Big"><![CDATA[
mut method
Void event_writeOnTextArea(mut Gui gui, S msg) (
  Strings ss=msg.split(S.nl())
  js1=Gui.JavaScript"document.getElementById('myTextAreaId').value = 'Hi! event happened';"
  //or, to use information in the message
  js2=Gui.JavaScript"document.getElementById('"[ss.val(1\)]"').value = '"[ss.val(2\)]"';"
  gui.executeJS(js2)
  )
]]></pre>

Gui provide help to visualize datastructures of various kind, 
for example vectors of Data classes can be shown as tables in the following way:
<pre class="l42Big"><![CDATA[
Person:Data<<{Size id, Name name, Name surname, Year age}
Persons:Collections.vector(of:Person)
ShowPersons:Gui.widget(table:Persons)
InputPerson:Gui.input(dialogForm:Person)//rely on JQuery UI
MyGui:Gui(/*..*/)<<{ mut Persons persons //field
  /*..*/
  mut method
  Void eventLoad(mut Gui gui, S msg) ( //no underscore for system events
    gui.add(ShowPersons(this.#persons(), into:Gui.Id"divLeft"))
    //the element with that id will contain the table
    )
  mut method
  Void event_addPerson(mut Gui gui,S msg) (
    Person p=InputPerson(gui,title:S"New Person details")
    catch exception InputPerson.Cancelled void
    this.persons().add(left:p)
    gui.refresh()
    )
  }
Main:MyGui(persons:Persons[])
]]></pre>

</p><h2> (2/5) Files </h2> <p>
In 42 you can import <span class="code"><![CDATA[FSystem]]></span> to read and write files.


<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
FSystem: Load<<{reuse L42.is/FSystem}

Main:{
  files=FSystem()
  files.write(S"foo.txt",S"foo foo foo!")
  S foos=files.read(S"foo.txt")//most likely, it contains 'foo foo foo!'
  return ExitCode.normal()
  }
}
]]></pre>

42 can execute every closed expression early, even at compile time, if it could give 
a performance boost, thus you may want to pass a files object around to functions that do
I/O. Otherwise you may end up with unexpected early effects:

<pre class="l42Big"><![CDATA[

method S readFoo()
 FSystem().read(S"foo.txt") //may read foo once and for all
//at compile time, and then return the same value every time
//it can be useful for loading resources, like image files
//in a simple game.

method S readFoo(mut FSystem that)
 that.read(S"foo.txt") //need the parameter to act, thus
 //will wait until a parameter is provided
]]></pre>

In general, all the system interaction that happens over the same system object are
chronologically sorted with respect to each other, but there is no guarantee 
of ordering between different system objects.

</p><h2> (3/5) Db </h2> <p>
In AdamTowel, databases can be access in two ways:
Raw access (similar to what is supported by
<span class="code"><![CDATA[DBC]]></span> or <span class="code"><![CDATA[JDBC]]></span> libraries) 
and Structured access.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Db: Load<<{reuse L42.is/Db}//Db can do Raw access
UnivDb:Db.importStructure(Db.ConnectionS"...")
QueryCountry:UnivDb.Query"select * from students where country=@country"
Main:{
  connection=UnivDb.connect()
  UnivDb.Student.Table ss=QueryCountry(connection, country:S"Italy")
  /*..*/
  }
}
]]></pre>
Here
we use <span class="code"><![CDATA[Db]]></span> to 
import the structure of the database. This means that 
<span class="code"><![CDATA[UnivDb]]></span> will contain a class for each table-row of the database,
every class will have a nested type representing 
multiple rows (that is, a table).
<span class="code"><![CDATA[UnivDb.Query]]></span> allows prepared queryes.
In the case in the example, we can use
<span class="code"><![CDATA[QueryCountry(that,country)]]></span>
to get the italian students.
Note how <span class="code"><![CDATA[country]]></span> is a parameter of the method: in this way the  query users are informed of the query expectations.
Our query used <span class="code"><![CDATA[*]]></span>, so the type <span class="code"><![CDATA[UnivDb.Student.Table]]></span>
could be reused.
In other cases a new type would be generated.

</p><h2> (4/5) example Gui and Db together </h2> <p>



</p><h2> (5/5) Libraries </h2> <p>
 </p><p id="MetaprogrammingIntro"> </p><h1> A taste of Metaprogramming </h1> <p>

</p><h2> (1/5)Refactor and Introspection </h2> <p>

</p><h2> Refactor </h2> <p>
<span class="code"><![CDATA[Refactor]]></span> is a class supporting modification of
library literals.
For example, you may want to rename the method <span class="code"><![CDATA[importStructure(that)]]></span> in just <span class="code"><![CDATA[import(that)]]></span>.
You can do the following:
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Db:Refactor.RenameMethod(Selector"importStructure(that)" 
  to:Selector"import(that)")<<Load<<{reuse L42.is/Db}
UnivDb:Db.import(Db.ConnectionS"...")
/*..*/
}
]]></pre>
The type <span class="code"><![CDATA[Selector]]></span> represent method selectors;
in the same way the type <span class="code"><![CDATA[Path]]></span> represent 
paths, as in <span class="code"><![CDATA[Path"Refactor.RenameMethod"]]></span> or
<span class="code"><![CDATA[Path"This"]]></span>.

There are a lot of refactoring operations nested under <span class="code"><![CDATA[Refactor]]></span>:
<ul><li>
<span class="code"><![CDATA[RenameSelector]]></span>
and 
<span class="code"><![CDATA[RenamePath]]></span>
rename methods either at top level (as we just did) or
in an arbitrary nested library;
or rename paths in other paths
</li><li>

<span class="code"><![CDATA[Redirect]]></span>
allowing to remove a nested library and redirect all its references to
an external one. This allows to emulate generics, as we will see later.
</li><li>
<span class="code"><![CDATA[UpdateDocumentationSelector]]></span>
and <span class="code"><![CDATA[UpdateDocumentationPath]]></span>
to add to/alter/delete the documentation of methods/paths.
</li><li>
<span class="code"><![CDATA[MakeAbstractSelector]]></span>
and <span class="code"><![CDATA[MakeAbstractPath]]></span>
to remove all the implementation out of a method or path,
leaving only the public skeleton
</li><li>
<span class="code"><![CDATA[HideSelector]]></span>
andWcode(HidePath)
To mark methods or paths as private.
We have not seen details on private members, the main idea is that
they are renamed in invisible names that you can never guess, and automatically renamed on need by refactoring operations.
</li></ul>
</p><p>
In addition to all those nested classes,
<span class="code"><![CDATA[Refactor]]></span> offers <span class="code"><![CDATA[Refactor.compose(left,right)]]></span>
allowing a simmetric sum of two library literals.
The main idea is that members with the same name are recursively summed

</p><h2> Introspection </h2> <p>
<span class="code"><![CDATA[Introspection]]></span> is
a class allowing to explore libraries, to discover what methods they have and so on.

The main classes inside of Introspection are
<span class="code"><![CDATA[Introspection.NestedLibrary]]></span>,
 <span class="code"><![CDATA[Introspection.Method]]></span> and
<span class="code"><![CDATA[Introspection.Type]]></span>.
You can obtain a nested library by calling the factory methods 
<span class="code"><![CDATA[Introspection(lib)]]></span> and <span class="code"><![CDATA[Introspection(classObj)]]></span>,
respectively for library literals or class objects.
We will see later some example of use of <span class="code"><![CDATA[Introspection]]></span>.


</p><h2> (2/5)Traits and Metaprogramming </h2> <p>

Metaprogramming is the most important feature of 42,
all the decorators that you have seen up to now are implemented with metaprogramming, that in 42 offers a good balance of freedom and
safety.
The main idea of 42 metaprogramming is that only library literals can
be manipulated, and that once a library literal has a name, it can not be directly metaprogrammed any more.
Thus, we call traits methods that return reusable (unnamed) code.
For example
<pre class="l42Big"><![CDATA[
Transaction:{
  class method
  Library traitEnsureTransaction() {

    class method //without name: can be called as a functor
    Void(mut Db.Connection connection)
    exception Db.Query.Failure //no body: abstract method

    class method //without name: can be called as a functor
    Void (mut Db.Connection that)
    exception Db.Query.Failure (
      that.openTransaction()
      This(connection:that)//here we call us as a functor
      catch exception Db.Query.Failure x (
        that.rollback()
        exception x
        )
      that.commitTransaction()
      )
    }
  }

MyAction:Refactor.compose(
  left:Transaction.traitEnsureTransaction()
  right:{ //and now the missing implementation
    class method
    Void(mut Db.Connection connection)
    exception Db.Query.Failure {
      /*..my operation..*/
      }
    })

Main:{
  /*..*/
  MyAction(conn)//do the operation in a transaction
  /*..*/
  }
]]></pre>

Note how <span class="code"><![CDATA[traitEnsureTransaction()]]></span> is just a normal 
class method that directly return a library literal.
Traits in 42 are nothing fancier than that.

Now <span class="code"><![CDATA[MyAction]]></span> will execute the operation inside of a transaction.

However, as you can see declaring <span class="code"><![CDATA[MyAction]]></span> using 
<span class="code"><![CDATA[Refactor.compose]]></span> is verbose, we now show how to improve.

Manually declaring a class just to declare a single trait mehtod
returning a library literal is verbose.
In AdamTowel we can use the class <span class="code"><![CDATA[Resource]]></span>
that automate this process.
For example
<pre class="l42Big"><![CDATA[
TraitEnsureTransaction:Resource<<{
  class method
  Void(mut Db.Connection connection)
  exception Db.Query.Failure

  class method
  Void (mut Db.Connection that)
  exception Db.Query.Failure (/*..as before..*/)
  }

MyAction:Refactor.compose(
  left:TraitEnsureTransaction()
  right:{ /*..as before..*/})
]]></pre>

This let us save just a couple of lines. 
We can improve further and make <span class="code"><![CDATA[Transaction]]></span>
into a real class decorator.

<pre class="l42Big"><![CDATA[
Transaction:{
  InvalidAction:Message.$<<{implements MetaGuard}
  //meta guard is the root of all the metaprogramming guards
  class method //using << to define the babelfish operator
  Library << (Library that) 
  exception InvalidAction {
    i=Introspection(lib:that)
    if !i.hasMethod(Selector"(connection)") (exception InvalidAction"Action method missing")
    composed=Refactor.compose(
      left:TraitEnsureTransaction(), right: that)
    exception on MetaGuard
      InvalidAction"
        'Action invalid:type of '(connection)' 
        'do not fit or already defined '(that)'
        "
    return Refactor.HideSelector(Selector"(connection)")<<composed
    error on Metaguard
      WTF"(connection) is there, ready to be hidden"
    }  
  }
MyAction:Transaction<<{
  class method
  Void(mut Db.Connection connection)
  exception Db.Query.Failure {
    /*..my operation..*/
    }
  }

]]></pre>

Note how we check some well formedness of the parameter
in an <span class="code"><![CDATA[if]]></span>, then we catch and wrap the exceptions of <span class="code"><![CDATA[compose(left,right)]]></span>,
and finally we state our assumption that <span class="code"><![CDATA[HideSelector]]></span> can not fail in
that context.

Now we can use Transaction as a decorator.


</p><h2> (3/5)Extend </h2> <p>

<span class="code"><![CDATA[Extend]]></span>
 is a decorator implemented using 
<span class="code"><![CDATA[Refactor]]></span> and
<span class="code"><![CDATA[Introspection]]></span>
and provide in AdamTowel a flexible model of multiple inheritance with super calls.
As an example, in a game we can have a chest, that contains objects in a certain position,
a boat that can host humanoids and
a cargo boat, that can host humanoids and can contains objects like a chest.
We want to reuse the code of chest and boat to obtain the cargo boat.
For example
<pre class="l42Big"><![CDATA[
ChestTrait:Resource<<{
  mut Objects objects
  /*.. methods to validate access to objects..*/
  read method
  Kg weight() {
    var Kg res=0Kg
    with o in this.objects().vals() (res+=o.weight() )
    return res
    }
  }

BoatTrait:Resource<<{
  mut Humanoids crew
  Kg maxCapacity
  /*.. methods to validate access to crew..*/
  read method
  Kg weight() {/*..with-loop on the crew..*/}
  
  read method
  Kg capacityLeft()
    this.maxCapacity()-this.weight()    
  }

Chest:Data<<ChestTrait()
Boat:Data<<BoatTrait()
CargoBoat:Data<<Extend[ChestTrait();BoatTrait()]<<{
  read method @override
  Kg weight() this.#1weight()+this.#2weight()
  }
]]></pre>

As you see, we annotate with <span class="code"><![CDATA[@override]]></span> to 
override the <span class="code"><![CDATA[weight()]]></span> method, and we use 
<span class="code"><![CDATA[#1weight()]]></span> and 
<span class="code"><![CDATA[#2weight()]]></span> to refer to the super implementations.
As an alternative to <span class="code"><![CDATA[@override]]></span>,
we could use <span class="code"><![CDATA[@hide]]></span> to just hide the old methods and put our new
version on top. There are two main difference between <span class="code"><![CDATA[@override]]></span> and 
<span class="code"><![CDATA[@hide]]></span>.
With override internal references will refer to the new implementation,
while with hide they will refer to the old one.
With override the method type must be identical,
while with hide they can be completely different.


</p><h2> (4/5)An intollerant type system </h2> <p>

As an exercise, lets try to use what we learned to add a <span class="code"><![CDATA[sum()]]></span> method to
a vector.

<pre class="l42Big"><![CDATA[
Nums:Extends[Collections.vector(of:Num)]<<{
  read method
  Num sum(){
    var Num res=0Num
    with n in this.vals() (res+=n )
    return res
    }
  }
]]></pre>

Easy.
However, note that we are calling <span class="code"><![CDATA[this.vals()]]></span> to
do the iteration, and we are not declaring a <span class="code"><![CDATA[vals()]]></span>
method.
The idea is that while computing <span class="code"><![CDATA[Nums]]></span>, the type system is temporarly allowing for incomplete/untypable code at the right of the '<span class="code"><![CDATA[:]]></span>'.
The typesystem will check that all is ok when the declaration of <span class="code"><![CDATA[Nums]]></span> is complete.
</p><p>
However, we have done an extension only on our specific Nums vector, we would have to repeat
such code for each vector.
Can we produce vectors that will have a <span class="code"><![CDATA[sum()]]></span> method?
Well, this can only work for vectors of elements with a <span class="code"><![CDATA[+]]></span> operator, and a zero concept. Luky, all numeric classes offers a <span class="code"><![CDATA[zero()]]></span> and <span class="code"><![CDATA[one()]]></span> method.


A good, partial solution would be the following:
<pre class="l42Big"><![CDATA[
MyCollection:{
  class method
  Library traitSum(){
    T:{
      class method T zero()
      method T +(T that)
      }
    read method
    Num sum(){
      var T res=T.zero()
      with n in this.vals() (res+=n ) //error here, vals() undefined
      return res
      }
    }
  class method
  Library vector(class Any of) {
    oldPart=Collection.vector(of:of)
    newPart=Refactor.Redirect(Path"T" to:of)<<this.traitSum()
    return Refactor.compose(left:oldPart, right:newPart)
    }
]]></pre>

Conceptually, we declare a new trait for the sum method,
and we make it general introducing <span class="code"><![CDATA[T]]></span> and our
needed requirements.
Sadly, this is not going to compile, since 
in the method <span class="code"><![CDATA[sum()]]></span> we call <span class="code"><![CDATA[this.vals()]]></span>,
and there is no definition for such method.
Similar code worked in the former example, but here
the definition of <span class="code"><![CDATA[MyCollection]]></span> get completed,
and the code in the method <span class="code"><![CDATA[traitSum()]]></span> is still 
incomplete.
We could just repeat there the definition of <span class="code"><![CDATA[vals()]]></span>,
but that would be duplicating code; moreover, <span class="code"><![CDATA[vals()]]></span> return an iterator, that have its methods too...

<span class="code"><![CDATA[Collection]]></span> does offer a solution: a trait contaning
the minimal code scheleton to make <span class="code"><![CDATA[vals()]]></span>, the idea is that
the composition of <span class="code"><![CDATA[traitSum()]]></span> and
<span class="code"><![CDATA[Collection.traitVals()]]></span> is complete code.
However, even declaring <span class="code"><![CDATA[traitSum()]]></span> as
<pre class="l42Big"><![CDATA[
class method
Library traitSum() 
  Extend[Collections.traitSequence()]<<{/*as before*/}
]]></pre>
Whould not work: the <span class="code"><![CDATA[<<]]></span> method would
be called when <span class="code"><![CDATA[traitSum()]]></span> runs, leaving incomplete code in the source.
We need to force the computation to happen before
<span class="code"><![CDATA[MyColleciton]]></span> is completed.
A solution is to use <span class="code"><![CDATA[Resource]]></span>.

<pre class="l42Big"><![CDATA[
TraitSum:Resource<<Extend[Collections.traitSequence()]<<{ /*as before traitSum()*/}
MyCollection:{
  class method
  Library vector(class Any of) (
    oldPart=Collection.vector(of:of)//surelly works
    {newPart=Refactor.Redirect(Path"T" to:of)<<TraitSum()
    return Extend[oldPart]<<newPart
    catch exception MetaGuard g return oldPart
    })
]]></pre>

By the way, before we also forgot to handle exceptions!
In case our parameter does not support zero and plus,
we will just return a normal collection. We need to insert additional brakets otherwise the 
binding <span class="code"><![CDATA[oldPart]]></span> would not be visible in the catch body.

As you may notice there is some incoherence in our programming style:
should trait be methods in a class or funtor classes?
should we use 
the more primitive
<span class="code"><![CDATA[Refactor.compose(left,right)]]></span>
or the more flexible <span class="code"><![CDATA[Extend[]<<]]></span>?
At the current state we do not have an answer to what is the best in 42. Indeed, we still do not understand the quesiton.


</p><h2> (5/5)Metaprogramming summary </h2> <p>
<ul><li>
Metaprogramming is hard, 42 tries to make it simpler, but not trivial.
</li><li>
Error handlying is important while writing decorators.
More then half of decorators code should be dedicated
to handle errors and lift them into a more understendable
form for the sake of the final user.
</li><li>
we are just scratching the surface of what we
can do with metaprogramming.
If you are interested to become a Magrathean
refer to the metaprogramming painful guide (link);
otherwise just use metaprogramming libraries 
and use <span class="code"><![CDATA[Refactor]]></span> only when all the other options feel more painful.
</li></ul>



 </p><p id="DeployCode"> </p><h1> Deploy 42 </h1> <p>

</p><h2> (1/5)Deploy programs </h2> <p>
In 42 libraries can be directly manipulated, and
a possible manipulation is to convert it in 
another format, like an executable jar or a native program
and then save the result somewhere, like on the website where you users can download it.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
ToDeploy:Resource<<{
  reuse L42.is/AdamTowel
  //yes, we repeat the reuse
  /*..lots of code here..*/
  }
Task:DeployOut.asExecutableJar(
  main:Selector"aClassMethod"
  location:URL"..."
  )<<ToDeploy()
}
]]></pre>

Note that we reuse adamTowel both outside <span class="code"><![CDATA[MyProgram]]></span>
and inside of it;
The two towels do not need to be the same.
The outermost just have to support the deployment process
<span class="code"><![CDATA[DeployOut]]></span>, while the inner one is needed to make
<span class="code"><![CDATA[MyProgram]]></span> a close library: only libraries that do not refer to external classes can be deployed.

</p><h2> 42 projects </h2> <p>
In order to write any sizable program, it would be great
to be able to organize our code in multiple files spanning a hierarcky of folders.
In 42, we can obtain this by using '<span class="code"><![CDATA[...]]></span>'.
A 42 project can be either a file
with upper case name and extension <span class="code"><![CDATA[.L42]]></span>
or a folder containing a file called <span class="code"><![CDATA[This.L42]]></span>.
Folders can contain other files <span class="code"><![CDATA[.L42]]></span> or folders containing other <span class="code"><![CDATA[This.L42]]></span> and other files.

</p><p>
In the 42 code, when using '<span class="code"><![CDATA[...]]></span>' we refer
to a folder/file with the name of the innermost nested library and we import its content.

For example in the following, we refer to the file/folder <span class="code"><![CDATA[MyProgram]]></span>.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
ToDeploy:Resource<<{
  reuse L42.is/AdamTowel
  Main:...
  class method
  Void main()
    Main.runStuff()
  }
Task:DeployOut.asExecutableJar(
  location:URL"...")<<ToDeploy()
}
]]></pre>

A common way to use 42 is to have a folder <span class="code"><![CDATA[ProjectName]]></span> containing
a folder <span class="code"><![CDATA[Main]]></span> with all the actual code,
and then various files providing testing and deploying functionalities.

In general, for medium size projects is a good idea to keep executing the tests before the deployment; for example
directly under <span class="code"><![CDATA[Main:...]]></span> we could add
<span class="code"><![CDATA[TestsRunner: ...]]></span>
Do not panick, If the test are not reachable from <span class="code"><![CDATA[myMainMethod]]></span>, they are not going to be included in the
executable jar.
</p><p>
42 can support varius kinds of unit testing and mocking,
but there is no support at this stage in AdamTowel.

</p><h2> (2/5)Towels embroidery </h2> <p>
A towel is about the most massively useful thing a programmer can have.
A towel has immense psychological value, and you should always know where your towel is.
All the classes we have used up to now without defining them, are defined in AdamTowel.
They are all normal classes/libraries.

You can code without a towel, but this means starting from first principles,
witch could be quite unpleasant; especially since the only
primitive things that 42 offers are Library literals
(code as first class entities), the constant <span class="code"><![CDATA[void]]></span>,
and the types <span class="code"><![CDATA[Library]]></span>, <span class="code"><![CDATA[Void]]></span> and <span class="code"><![CDATA[Any]]></span>.
</p><p>

The distinction between towels and other libraries is just psicological;
we generally call towels libraries that are expected to provide standard
functionalities and types, such as numbers, booleans Bool,
strings S and various kinds of decorators and system errors.

</p><p>
However, we do not expect all L42 programs to reuse the same towel.
For hygienic reasons, in real life everyone tends to use their own towel.
For similar reasons, any sizable 42 program will use its own towel.

</p><p>

We expect different programs to use massively different libraries for
what in other languages is the standard library.
That is, there is no such thing as 'the L42 standard library'


</p><h2> Using multiple Towels </h2> <p>

Towels shines when multiple towels are used at the same time.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamsTowel
//here you can access to lots of
//utility classes declared inside the towel
//including numbers, strings and so on.
C:{reuse L42.is/FordTowel
//here you can access a different set of classes.
//For example, Num would refer to the number in FordTowel
//and to see the number declared in AdamsTowel
//you have to write This1.N
  }
}
]]></pre>

Different code parts reason about different set of classes;
including those predefined in other languages.

Useful for code that reasons on code; that is a very common task
in L42. 

</p><h2> Define and deploy our own towel </h2> <p>
If you are writing a sizable program, 
or many similar programs, it make sense to
deploy you own towel, when you can 
pre load import some libraries and define your basic classes.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
ToDeploy:Resource<<{
  reuse L42.is/AdamTowel
  Gui:Load<<{reuse L42.is/Gui}
  Kg:Units.of(Num)
  Meter:Units.of(Num)
  /*..*/  
  }
Task:DeployTowel(
  url:Url"https://github.com/MyProjectName/MyTowel.L42"
  permissions:S".."
  )<<ToDeploy()
}
]]></pre>

The former code would create your towel and update it
on your github repository every time you
run it.
</p><p>
The idea of modifying a towel to create a variation is caled
<span style="color:#ff1111; font-weight: bold;"> Towel Embroidery </span>.
<span class="code"><![CDATA[MyTowel]]></span>
 is just a variation of AdamTowel, with more stuff added at the bottom.
We can do much more than that.

One useful tool to modify the content of a towel
is <span class="code"><![CDATA[Extend.patch(that)]]></span>.
The idea is that we extend a library using a part of itself
as a path. As an example
<pre class="l42Big"><![CDATA[
Code:Extend.patch(Path"Fix")<<{
  class method
  S sayHi()
    S"Hi"
  Fix:{
    class method @override
    S sayHi()
      S"Say "++this.#1sayHi()
    }
  }
]]></pre>

<span class="code"><![CDATA[Code.sayHi()]]></span> will return <span class="code"><![CDATA[S"Say Hi"]]></span>.
This also works for nested classes. If for example
you wish to add a reverse method to <span class="code"><![CDATA[S]]></span> in your towel, you could do the following:

<pre class="l42Big"><![CDATA[
ToDeploy:Resource<<Extend.patch(Path"Fix")<<{
  reuse L42.is/AdamTowel
  Fix:{S:{
    method S reverse() {/*..*/}
    }}
  }
]]></pre>

The advantage with respect to compose two separated
libraries is that the scope is the same,
that is the implementation of <span class="code"><![CDATA[reverse()]]></span> will be able to use <span class="code"><![CDATA[Bool]]></span>, <span class="code"><![CDATA[Num]]></span> and so on.




</p><h2> (3/5)Library deployment </h2> <p>

If you start writing in 42, you will soon feel the need
of factorizing your project into libraries, that could
be independently tested, deployed and loaded.
While successfull libraries are used by multiple 
independent projects and developers,
most libraries exists just as a developement tool in 
order to keep under control the complexity of big projects.
In 42 is easy to code with multiple libraries.
In 42 is possible to employ a programming model where every developer (or every pair of developers in a pair programming style) is the
only responsable of one (or more) library and its mainentence process, while the group leader give specifications and tests to be met to the varius library developers and will glue all the code together.

</p><p>

Most L42 libraries are not towels.
All 42 libraries are closed code.
Thus, most non-towel 42 library are generic
(have abstract classes/methods) that can be rebinded
to a moltitute of towels.

Libraries can be deployed in a way similar to towel deployment.
<span class="code"><![CDATA[Load]]></span> is used to load libraries,
but it also contains all the knowledge to deploy
them.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
ToDeploy:Resource<<{
  reuse L42.is/MyTowel
    MyLib:...
  }
}
Task:Load.DeployLibrary(
  path:Path"MyLib",
  url:Url".."
  )<<ToDeploy()
}
]]></pre>

If there was any nested library unreachable from public classes
in <span class="code"><![CDATA[MyLib]]></span>, it will be pruned away.

Note how in this example we use towels <span class="code"><![CDATA[AdamTowel]]></span>
 and <span class="code"><![CDATA[MyTowel]]></span>.
<span class="code"><![CDATA[Load]]></span> used in
<span class="code"><![CDATA[Task]]></span> comes from 
<span class="code"><![CDATA[AdamTowel]]></span>, thus has no idea of the 
embrowdery process that created.
This means that all classes already present 
in <span class="code"><![CDATA[AdamTowel]]></span> will be attempted to be abstracted away, while all the newly introduced classes will become private.
Thus, in our example, 
<span class="code"><![CDATA[Gui]]></span>,
<span class="code"><![CDATA[Kg]]></span> and
<span class="code"><![CDATA[Meter]]></span>
would become an implementation detail of the exposed library.

if <span class="code"><![CDATA[MyTowel]]></span> had some non trivial embrowdery, like
the string <span class="code"><![CDATA[reverse()]]></span> shown before,
then it needs to be loaded on similarly embrowdered towels.

</p><p>
If we wish to expand the Loading/deployment process, we
need to patch <span class="code"><![CDATA[ConceptMap]]></span>
as in the following example:
<pre class="l42Big"><![CDATA[
ToDeploy:Resource<<Extend.patch(Path"Fix")<<{
  reuse L42.is/AdamTowel
  Kg:Units.of(Num)
  Gui:Load<<{reuse L42.is/Gui}
  Fix:{
    ConceptMap:{interface 
      method Kg _Kg()
      method Gui _Gui()
      }
    }
  }
]]></pre>

In this simple case, we can just use the class name to encode the
<span style="color:#ff1111; font-weight: bold;"> conceptual names </span> for the newly added classes.
For more flexible library loadings, you can use semantic URI as ontological nodes.
</p><p>
Our fixed towel can be used now to deploy and load libraries wrote in
this new towel, and libraries deployed and loaded in this way will 
share a unique definition for <span class="code"><![CDATA[Kg]]></span> and <span class="code"><![CDATA[Gui]]></span>.






 <!--

<pre class="l42Big"><![CDATA[
Observer:{interface
  mut method update()
  }
Observers:Collection.vector(ofMut:Observer)

Traits:{

  class method
  Library subject(){
    mut Observers observers

    class method
    mut Observers #default_observers()
      Observers[]

    mut method
    Void register(Observer that)
      this.#observers().add(right:that)

    mut method
    Void notify() 
      with Observer o in this.#observers().vals() (
        o.update()
        )
  }
  class method
  Library widget(){ /*..*/}

}

MyObservableWidget:Extends[Traits.subject(); Traits.widget()] <<{
  mut method @override
  Void repaint() (this.#2repaint() this.notify())
  }
]]></pre>

It is possible to iterate over a range of numbers:

<pre class="l42Big"><![CDATA[
with i in 4Size.vals() (
  Debug(i)//prints 4,5,6,7 and so on forever
  )
]]></pre>

<pre class="l42Big"><![CDATA[
with i in 4Size.upTo(42Size) (
  Debug(i)//prints 4,5,6,7 and so on up to 42 excluded
  )
]]></pre>


Resources used within an iteration can be released after the iteration 
since collections are notified when the iteration ends.

<pre class="l42Big"><![CDATA[
//a contains "foo1 \n foo2 \n foo3"
//b contains "bar1 \n bar2"
with 
  input in LineStream.readFile(S"a"), 
  var output in LineStream.readWriteFile(S"b",fill:S"None") (
    output:= output +" : "+input)//line by line, add input in the file
//b contains "bar1 : foo1 \n bar2 : foo2 \n None : foo3"
]]></pre>


    
<pre class="l42Big"><![CDATA[ Library myCode={ method Int foo()} ]]></pre>
A local binding of type Library initialized with a class with a single <span class="code"><![CDATA[foo()]]></span> method. Since there is no body, it is an abstract method.
 -->	 

 <!--</p><h2> Simpler complete program </h2> <p>

Let now starts showing the simplest 42 program: an empty library.

<pre class="l42Big"><![CDATA[ {} ]]></pre>

If we save this valid program in a file <span class="code"><![CDATA[Test.L42]]></span> and we run <span class="code"><![CDATA[L42 Test]]></span>, we get an error.
</p><p>
As you see 42 is very intuitive, as you would expect from your former life experiences, most simple things just does not work.
Note how valid programs can produce errors.
We will soon learn how to produce errors in controlled and elegant ways.
-->
<!--A 42 program execution <span style="color:#ff1111; font-weight: bold;"> is </span> the generation of all its nested classes/interface.
, code is simply executed from top to bottom as in 
Python, Javascript or Php. However, the
top level expression is a Library, and code can go in libraries 
as an initializer for you need to put the code into an expression
-->

<!-- LATER?
<span class="code"><![CDATA[MyCode.hello(..)]]></span> 
use directly the <span class="code"><![CDATA[MyCode]]></span> class instance as
receiver. We can also give it a name 
e se vuoi puoi anche salvarlo su un binding locale, 
tipo x=MyCode  x.hello(...)
-->

        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <!--<li style='display:inline;'><a href="http://ecs.victoria.ac.nz/Main/MarcoServetto" >Contact Us</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/disclaimer">Mailing list</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/accessibility" >Site Accessibility</a></li>
			-->
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>

