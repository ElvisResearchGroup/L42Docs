<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="https://www.googletagmanager.com/gtag/js?id=G-M0E4M0XH2Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-M0E4M0XH2Z');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-212820693-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-212820693-1');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=AW-10810288706"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'AW-10810288706');
    </script>
WConversion
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logoBlue.png' alt='42' width='120' height='120'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90"> Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="#Basics"> Basic concepts </a></li>
 <li><a href="#ModifiersIntro"> Introduction to modifiers </a></li>
 <li><a href="#BasicClasses"> Basic Classes </a></li>
 <li><a href="#ErrorsAndExceptions"> Errors and Exceptions </a></li>
 <li><a href="#Caching"> Caching </a></li>
 <li><a href="#CachingMut"> Caching on Mutable objects </a></li>
 <li><a href="#InterfacesAndMatching"> Interfaces and Matching </a></li>
 <li><a href="#Sequences"> Collections and Sequences </a></li>
 <li><a href="#InputOutput"> Input Output </a></li>
 <li><a href="#Exercises"> Exercises </a></li>
 <li><a href="#MetaprogrammingIntro"> Metaprogramming Introduction </a></li>
 <li><a href="#Refactoring"> Programmatic Refactoring </a></li> 
 <li><a href="#MoreDecorators"> More Decorators </a></li>
 <li><a href="#ExampleOfProgram"> Example of a 42 Program </a></li>
 <li><a href="#DeployCode"> Deploy code </a></li>
</ol>
</div></div><div class="finishFloat"></div></div>

 </p><p id="Basics"> </p><div style="break-after:page"></div><h1> Target audience </h1> <p>
This tutorial is design for expert programmers, already knowledgeable in 
at least two or three of the languages Java, C#, C++ and Python.
This tutorial lays out the basic knowledge for programming in 42 using AdamsTowel, but
does not explore the foundational theory behind 42,
or the mathematical rationale for the correctness of 42.
<br/>
The language 42 and many 42 metaphors are inspired by
 The Hitchhiker's Guide to the Galaxy by Douglas Adams.


</p><h2 id="Download"> Downloading and running </h2> <p>

Currently, you can download and run 42 as a 
Java program.
<ul>
<li>
  For windows download here <a href="L42PortableWin.zip">L42PortableWin.zip</a>
  </li>
<li>
  For Linux download here <a href="L42PortableLinux.zip">L42PortableLinux.zip</a>
  </li>
<li>
  For Mac download here <a href="L42PortableMac.zip">L42PortableMac.zip</a>
</li>
    <li>  Run <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42]]></span><it style="font-style: bold; color:green;">&#187;</it>
        to start the IDE.
</li>
<li>
  Run <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42 ProjectName]]></span><it style="font-style: bold; color:green;">&#187;</it>
    to run the 42 program inside of the folder <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ProjectName]]></span><it style="font-style: bold; color:green;">&#187;</it> from the command line.
</li>
</ul>
</p><div style="break-after:page"></div><h1> Basics </h1> <p>
</p><h2> (1/5)Simple hello world program </h2> <p>
Let's look at a simple hello world program: 

<pre class="l42Big"><![CDATA[ 
reuse [L42.is/AdamsTowel]
Main = Debug(S"Hello world")
]]></pre>
<br/>
When we write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse [L42.is/AdamsTowel]]]></span><it style="font-style: bold; color:green;">&#187;</it> we are asking 42 to
reuse the code of the library found in the internet address 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
AdamsTowel is our <it style="font-style: italic;">towel</it>, that is the set of classes and interfaces that we wish to start from.
A <it style="font-style: italic;">towel</it> usually plays the role of "the standard library" of most languages.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is]]></span><it style="font-style: bold; color:green;">&#187;</it> is the main website of 42, where most commonly used libraries are hosted. To reuse code you 
need an internet connection; but this also means that you will never have to manually import any code.
Required code will be downloaded and cached on your machine, so you need not to be aware of the existence of this mechanism.
</p><p>
We do not need to always start from AdamsTowel; there are many interesting towels out there, and you may also become skilled in the 
advanced technique of towel embroidery.
In this tutorial, all of our examples are expressed reusing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>

At the right of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main = ]]></span><it style="font-style: bold; color:green;">&#187;</it> we write the expression that
we wish to execute; in this case we just print out using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug]]></span><it style="font-style: bold; color:green;">&#187;</it> class.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> is not a method, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> is not special name either. You can replace it with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Task]]></span><it style="font-style: bold; color:green;">&#187;</it> or any other valid
upper-case name. In 42 there is no concept of main method as in
Java or C. 
For now you can think of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main = ]]></span><it style="font-style: bold; color:green;">&#187;</it> as a top level command. We will understand later how this fits with the general language design.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a simple class whose most important method print a message on the terminal.
</p><p>
In 42, when a class has a <span style="color:#ff1111; font-weight: bold;"> most important </span> method, it is conventional to use the empty name, so that can be used with the short syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug(S"Hello world")]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of a more verbose <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Debug.println(..)]]></span><it style="font-style: bold; color:green;">&#187;</it>. 

<br/>
In 42, Strings and numbers need to be created using their type, as in
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"Hello world"]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[12Num]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[12Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is just a convenience syntax equivalent to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"1"]]></span><it style="font-style: bold; color:green;">&#187;</it>; the syntax with quotes is needed to express negative or fractional number literals, as for example <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"-12"]]></span><it style="font-style: bold; color:green;">&#187;</it>
 or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num"53/21"]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>

</p><h2> (2/5)Method declaration and call </h2> <p>
Let's now define a method and call it.
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
MyCode = {
  class method
  S hello(S nickName) = { //we can use usual if/while
    if nickName.isEmpty() (return S"Hello!")
    return S"Hello %nickName!"
    } 
  }
Main = Debug(MyCode.hello(nickName=S"Marvin"))
//will print "Hello Marvin!"
]]></pre>
<br/>
Here we define a class to host our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hello(nickName)]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
We write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it> to define a method that can be called on the class object, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode.hello(nickName=S"Marvin")]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is roughly equivalent to a static method in languages like Java or C++ , or class methods in Python.
Note that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[%]]></span><it style="font-style: bold; color:green;">&#187;</it> inserts a value into a string.
</p><p>
Note that the method is called using the parameter name explicitly.
We believe this increases readability.
</p><p>
You may also notice how there are two different usages for curly brackets:  if there is at least one <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword then the expression is a block of statements,
otherwise the expression is a library literal, which can contains methods and nested libraries.
A <span style="color:#ff1111; font-weight: bold;"> nested library </span>
is denoted by an upper-case name, and can be created from a library literal or from an expression producing a library literal.
A library literal can be a class (default case) or an interface (starts with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword).
A nested library in 42 is similar to a static inner class in Java, or a nested class in C++. It is just a convenient way to separate the various components of our program and organize them into a tree shape.
</p><p>
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode]]></span><it style="font-style: bold; color:green;">&#187;</it> from before offers a single class method, has no fields and you can not create instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyCode]]></span><it style="font-style: bold; color:green;">&#187;</it>, since no factory is present.
In 42 we do not have constructors. Objects are created by <it style="font-style: italic;">factory methods</it>, that are just normal methods that happen to return an instance of their class. We believe this is a much simpler and more consistent approach to object initialization than having special syntax that encourages programmers to make assumptions about the behaviour of the operations.

</p><h2> (3/5)Simple class with internal state </h2> <p>
Now we show a class with state and a factory method: 
<pre class="l42Big"><![CDATA[
Point = Data:{
  Num x
  Num y
  method
  Point add(Num x) = //long version
    Point(x=x+this.x(), y=this.y())
  method
  Point add(Num y) = //shorter
    this.with(y=y+this.y())
  method
  Point sum(Point that) =
    Point(x=this.x()+that.x(), y=this.y()+that.y())
  }
]]></pre>
<br/>
Here you can see we define a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> class with coordinates <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
unlimited precision rational number.

In addition to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> will offer many other useful methods, since it has been declared using
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.
 </p><p>
Indeed, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is a decorator. Decorators are classes/objects that offer an operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it>, called the decorator operator,
whose goal is to translate a library into a <span style="color:#ff1111; font-weight: bold;"> better </span> library.
In this case, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is translating the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{Num x, Num y .....}]]></span><it style="font-style: bold; color:green;">&#187;</it>
 into a much longer class, with
a factory method taking in input the fields and initializing them; but also containing
 boring but useful definitions for
equality, inequality, conversion to string and many others.
<!--from and to human readable strings, XML and binary representations for (de)serialization.-->
</p><p>
Finally, we define a methods to add to each of the coordinates.
For very short methods we can omit the curly brackets and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Indeed, method bodies are just expressions, and the curly brackets turn a block of statements into one expression. 

In the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> we show how to create a new 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> instance and how to call <it style="font-style: italic;">getter methods</it>.
In the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it> we show an improved version, using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with]]></span><it style="font-style: bold; color:green;">&#187;</it> method, another gift of Data, which allows us to easily create a clone with one or more fields updated.
We can define two methods, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it> with the same method name, if parameter names are different.
</p><p>
Note that we always use getters and we never access fields directly.
In many other languages we can use write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.fieldName]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.fieldName= newValue]]></span><it style="font-style: bold; color:green;">&#187;</it>. Such syntax does not exists in 42. The same goes for object instantiation; in many languages there is a dedicated  <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[new ClassName(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> syntax, while in 42 it is just a method call.
</p><p>
Also, similarly to what happens in Python, we need to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.methodName()]]></span><it style="font-style: bold; color:green;">&#187;</it> to call methods when the receiver is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While it makes some code more verbose, naming the receiver avoids ambiguities about scoping and nesting for method resolution.


</p><h2> Decorators </h2> <p>
Decorators, such as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, are one of the main concepts used by 42 programmers. We will encounter many decorators in this tutorial.
For now, just get used to the pattern of writing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> to go from a minimal chunk of code, with method declarations for the application specific bits, to a fully fledged usable class.

</p><h2> The backslash <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> </h2> <p>
In 42, we can use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> character as a shortcut.
There are two different ways to use the backslash:
as a keyword or immediately followed by a lowercase identifier.
</p><p>
As a keyword, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> represents the expected type of the surrounding expression.
The slash searches outwards on super expressions until it finds a place with an easily guessable type:
the return type of the method, a method parameter or a local binding with an explicit type.
For example:
<pre class="l42Big"><![CDATA[
method Point add(Num x) = Point(x=x+this.x(), y=this.y())
]]></pre>
could be shortened as 
<pre class="l42Big"><![CDATA[
method Point add(Num x) = \(x=x+this.x(), y=this.y())
]]></pre>
Consider these other examples:
<pre class="l42Big"><![CDATA[
method Num foo() = 1\+2\ // \ is Num
method class Num bar() = \ // \ is Num
method Num baz() = \.zero().toS().size() // \ is Num
]]></pre>
</p><p>
Followed by a method name (and method parameters if any)
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> represents the receiver of the innermost method invocation.
Thus, for example
<pre class="l42Big"><![CDATA[
method Point add(Num y) = this.with(y=y+this.y())
]]></pre>
could be shortened as 
<pre class="l42Big"><![CDATA[
method Point add(Num y) = this.with(y=y+\y)
]]></pre>
Consider this other example:
<pre class="l42Big"><![CDATA[
method Point bar(Point that) = that.with(y=\sum(that).y())
method Point bar(Point that) = that.with(y=that.sum(that).y())//equivalent
]]></pre>

</p><p>
In the rest of the tutorial, we will use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> when it saves space. This shortcut seems unusual at first, but with a little of experience becomes very clear. 42 is a pure OO language, where the method call is the central operation. 
This syntax allows for the expressions of the method parameters to depend on the method receiver. We will see that this enables many interesting micropatterns.

</p><h2> (4/5)Collection.list </h2> <p>

Lists can be defined using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(_)]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the example below,

<pre class="l42Big"><![CDATA[
Nums = Collection.list(Num) //declaration for vectors of nums

Points = Collection.list(Point) //same for points

Main1 = Debug(Nums[ 10\; 20\; 30\ ]) //here \ is Num
Main2 = Debug(Points[\(x=10\ y=20\);\(x=1\ y=2\)]) //here the outer \ is Point
]]></pre>
where we define new classes <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points]]></span><it style="font-style: bold; color:green;">&#187;</it>. Note that those are new classes in a nominal type system, so in
<pre class="l42Big"><![CDATA[
Nums1 = Collection.list(Num)
Nums2 = Collection.list(Num)
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums1]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Nums2]]></span><it style="font-style: bold; color:green;">&#187;</it> denote different classes, with different types.
As you can see, lists can be initialized with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_;_;_]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this case, this syntax is equivalent to creating a new empty list and then calling the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method
one time for each of the expressions separated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[;]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Of course, the parameter type of that method is the element type of the list, so
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> finds it as an easily guessable type.

</p><p>

Consider now the following code:
<pre class="l42Big"><![CDATA[
xs = Nums[ 10\; 20\; 30\ ]
ys = Nums[ \"-1"; \"2/3"; 3\ ]
points = Points[]
for x in xs, y in ys (
  points.add(\(x=x, y=y))// here \ is Point
  )
Debug(points) //prints
//[Point(x=10, y="-1"); Point(x=20, y="2/3"); Point(x=30, y=3)]
]]></pre>
As you can see, we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> to iterate on multiple collections at once.
<br/>
In 42 as in most other languages you can have blocks of code where multiple
<it style="font-style: italic;">local bindings</it> are introduced by associating a lowercase name with an initialization expression.
Similarly, the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> introduces local bindings whose values will range over collection elements by associating them with initialization expressions for iterators.


</p><h2> (5/5)First summary </h2> <p>

<ul><li>
At the start of your program, import a towel using 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse _]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse [L42.is/AdamsTowel]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
To define a simple class exposing its state and 
some methods working with those, use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point = Data:{Num x, Num y}]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
You can define methods in classes with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[method]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword.
Use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it> for methods that can be called on the class object directly.
</li><li>
To introduce the concept of list for a certain type, use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(_)]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/> as in the class declaration
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points = Collection.list(Point)]]></span><it style="font-style: bold; color:green;">&#187;</it>
</li></ul>

</p><div style="margin-left: 30px;">
<h2> Object creation summary </h2> <p>
42 supports many different syntactic forms that are convenient for creating objects: 
<ul><li>
12Num:  from a numeric representation
</li><li>
S"foo":  from a string representation
</li><li>
Point(x=_,y=_):  from the parameter values
</li><li>
Points[_;_;_]:  from a variable length sequence of values.
</li></ul>

Note that in 42 these are all just expressions, and represent one or more methods in the named class.
This means that even concepts quite different from numbers, strings and collections may benefit from this syntactic support.
</p></div>
<p>
</p><h2> Digressions / Expansions </h2> <p>
Here, after the summaries, we will digress and expand
on topics related to the chapter. 
Digressions/expansions may be more technical and challenging, and may refer to any content in any of the other chapters, including the forward ones.
For example, we are now going to make some more precise remarks about:
</p><h2> Method selector </h2> <p>
In 42 a method selector is the method name plus the list of all the parameter names, in order.
Methods in a class must be uniquely identified by their method selectors.
This provides a good part of the expressive power of overloading, while avoiding all the complexities of type driven overloading resolution.

 </p><p id="ModifiersIntro"> </p><div style="break-after:page"></div><h1> Keep control:  Modifiers, kinds of references and objects </h1> <p>

</p><h2> (1/5)Kinds of objects </h2> <p>
In object oriented languages, objects can form complex networks of dependencies by referring to each other using their fields.
The Reachable Object Graph (ROG) of a given object is the set of all objects reachable from it, including itself.
</p><p>
An object is <span style="color:#ff1111; font-weight: bold;"> mutated </span> if a field of an object in its ROG is <span style="color:#ff1111; font-weight: bold;"> updated </span>.
A <it style="font-style: italic;">mutable object</it> is an object that can be mutated.
The 42 type system is able to ensure that some objects can not be mutated. We call those <it style="font-style: italic;">immutable objects</it>.

All instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> are immutable.
The ROG of a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> object contains the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> itself and the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> coordinates.
Fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> can not be updated and the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> objects are immutable.

Immutable objects are very easy to use but may be inadequate when representing entities whose state can change across time.
</p><p>
Let's now define a mutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>, whose location can be updated:
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location //getter: this.location()
                     //setter: this.location(newVal)
  mut method
  Void run() =
    this.location(\location.add(x=20Num))//update the field with a new point
    //here \location == this.location()
  }
]]></pre>
There are two new keywords used here: 
<ul><li>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> field is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>.
  This is called a <it style="font-style: italic;">variable field</it>: a field that can be <span style="color:#ff1111; font-weight: bold;"> updated </span> by calling a setter.
  Non-variable fields can not be updated.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[run()]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut method]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
We have seen a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method]]></span><it style="font-style: bold; color:green;">&#187;</it> already, and we have seen methods 
such as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(y)]]></span><it style="font-style: bold; color:green;">&#187;</it>
showing no modifier;
they implicitly have the default modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Similarly, whenever a type does not specify a modifier,
it has the default modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
  <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> methods can mutate the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> object. If you have experience with C++
  you can see the contrast with const methods.
  Immutable (default) methods works only on immutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> objects.
  Later, we will see much more about modifiers.
</li></ul>

</p><p>
As you see, we are using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> method from before.
Also notice that we are calling the setter <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> without providing the parameter name.
While this is usual in other languages, in 42 parameters are selected by name.
Sometimes writing down all the parameter names can get tedious.

If the first parameter is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can omit it:
Writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(that=c)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(c)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This works also for methods with multiple parameters, if the first one is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(that=c, x=d)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b(c, x=d)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
We can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> by writing, for example: 

<pre class="l42Big"><![CDATA[
mut Animal dog1 = Animal(location=\(x=0\, y=0\))
dog2 = Animal(location=\(x=0\, y=0\)) //type 'mut Animal' inferred for dog2
dog2.run()
]]></pre>

</p><h2> (2/5)Interaction between mutable and immutable </h2> <p>

We now explore some interaction between mutable and immutable objects.
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  mut Points path
  mut method
  Void move() = (
    this.location(\path.left())
    this.#path().removeLeft()
    )
  }
]]></pre>
Here we use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Points path]]></span><it style="font-style: bold; color:green;">&#187;</it> to denote a mutable list of points.
Note the absence of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>; this is conceptually similar to a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Points * const path;]]></span><it style="font-style: bold; color:green;">&#187;</it> in C++  or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[final Points path;]]></span><it style="font-style: bold; color:green;">&#187;</it> in Java.
To contrast, the declaration <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var Point location]]></span><it style="font-style: bold; color:green;">&#187;</it> is similar to
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point const * location;]]></span><it style="font-style: bold; color:green;">&#187;</it> in C++  or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ImmPoint location;]]></span><it style="font-style: bold; color:green;">&#187;</it> in Java, for an opportune <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ImmPoint]]></span><it style="font-style: bold; color:green;">&#187;</it> class.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> references always refer to mutable objects.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> references always refer to immutable objects.

Fields can be declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> independently from their modifier:
In the code above, you can see that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var Point location]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> field of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> type.
On the other hand, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Points path]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a non-<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> field of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> type.

</p><p>
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move()]]></span><it style="font-style: bold; color:green;">&#187;</it>
first uses the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> setter method to update the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> field
with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm Point]]></span><it style="font-style: bold; color:green;">&#187;</it> leftmost element of the field <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Points path]]></span><it style="font-style: bold; color:green;">&#187;</it>.
By the way, collections in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> are primarily designed to store and retrieve
immutable objects; later we will show also how to manipulate mutable ones.
<br/>
The method then uses the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#path()]]></span><it style="font-style: bold; color:green;">&#187;</it>
 <span style="color:#ff1111; font-weight: bold;"> exposer </span> method and 
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[removeLeft()]]></span><it style="font-style: bold; color:green;">&#187;</it> method to mutate the list of points.
Both exposers and getters provide access to the value of a field;
exposers are used to access the values of mutable fields.
Exposers should be used with care: 
long term handling of references 
to (parts of) a mutable object could cause 
spooky action at a distance.
<br/>
In general, methods starting with # should be used with care.
</p><p>
This code models an animal following a path. It can be used like this:
<pre class="l42Big"><![CDATA[
zero = Point(x=0\, y=0\)
ps1  = Points[\(x=12\, y=20\); \(x=1\, y=2\)]
ps2  = Points[zero; \(x=1\, y=2\)]
dog1 = Animal(location=zero, path=ps1)
dog2 = Animal(location=zero, path=ps2)
dog1.move()
dog2.move()
]]></pre>

In this code the first dog goes to 12: 20.
The second dog goes to 0: 0. 

This code involves a mutable animal with a mutable field. This is often
a terrible idea, since its behaviour may depend on aliasing:  what happens if two dogs follow the same path?
<pre class="l42Big"><![CDATA[
zero = Point(x=0\, y=0\)
ps   = Points[\(x=12\, y=20\); \(x=1\, y=2\) ]
dog1 = Animal(location=zero, path=ps)
dog2 = Animal(location=zero, path=ps)
dog1.move()
dog2.move()
]]></pre>
The first dog moves and consumes the path for the second one as well.
That is, the first goes to 12: 20 and the second goes to 1: 2.

This is because <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> is <span style="color:#ff1111; font-weight: bold;"> deeply mutable </span>: a mutable object with mutable fields. 
An amazing amount of bugs is caused by deep mutability.

Note that we are using the exposer method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#path()]]></span><it style="font-style: bold; color:green;">&#187;</it>
in a safe pattern: it is only called over <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it>, and the returned reference does not leak out of the method.
The problem here arises since the object was shared to begin with. 

</p><h2> (3/5)Capsules:  Keep aliasing graphs untangled </h2> <p>

In 42 we can change <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> to prevent this aliasing issue.
<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  capsule Points path
  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )
  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  }
]]></pre>
Now we use the modifier <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>; this requires the value of the field to be encapsulated.
Immutable objects are also encapsulated since
they do not influence aliasing, so they are free from aliasing limitations.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>
 modifier <span style="color:#ff1111; font-weight: bold;"> forces </span> the users to provide <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> values,
 and <span style="color:#ff1111; font-weight: bold;"> ensures </span>
 that instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> have <it style="font-style: italic;">encapsulated state</it>;
 that is, the values of all fields in an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> are encapsulated.
<br/>
A mutable object with encapsulated state can only be mutated by calling one of its methods.
This allows for the same kind of local reasoning as if all of the fields were immutable.
</p><p>
A <span style="color:#ff1111; font-weight: bold;"> capsule mutator </span> is a class method whose first parameter is the capsule field as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
It is a way to mutate the value of a capsule field without exposing it.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> recognizes only the methods annotated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> as capsule mutators.
Those methods can then be safely accessed as instance methods with the same name.
<br/>
The annotation is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> because
capsule mutators also clear all the object based caches. Automatic caching is one of the coolest features of 42 and we will explore it later in this tutorial.
</p><p>
Note that we cannot have <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> exposers (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#path()]]></span><it style="font-style: bold; color:green;">&#187;</it>) for capsule fields:
other code could keep those references and then 
mutate the ROG of the field,
breaking local reasoning about Animals.

With <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule Points path]]></span><it style="font-style: bold; color:green;">&#187;</it>, we are forced to initialize two animals using different paths:
<pre class="l42Big"><![CDATA[
zero = Point(x=0Num, y=0Num)
capsule Points ps = Points[\(x=12\, y=20\);\(x=1\, y= 2\)]
dog1 = Animal(location=zero, path=ps)
//dog2= Animal(location=zero, path=ps) Does not compile
dog2 = Animal(location=zero, path=\[\(x=12\, y=20\); \(x= 1\, y=2\)])
dog1.move()
dog2.move()
]]></pre>
where the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ps]]></span><it style="font-style: bold; color:green;">&#187;</it> local binding is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>; 
it can satisfy the Animal.path requirement, but it can be used only once.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[dog2]]></span><it style="font-style: bold; color:green;">&#187;</it>
has to use another capsule. It is okay to just write the object creation in place as is done.
Alternatively, lists offer a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clone()]]></span><it style="font-style: bold; color:green;">&#187;</it> method,
so in this case we could write

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[dog2= Animal(location: zero, path: dog1.path().clone())]]></span><it style="font-style: bold; color:green;">&#187;</it>


</p><h2> (4/5)Handle mutability </h2> <p>

</p><h2> Immutable objects of any class </h2> <p>

How can we get an immutable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>?
When an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> is created using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal(location=_,path=_)]]></span><it style="font-style: bold; color:green;">&#187;</it> we create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>.

In most cases you can promote such reference to immutable/capsule; just make the type of the local binding explicit.
 The type system will take care of the rest.
If a reference can not be safely promoted to immutable/capsule, you may have to clone some data or to refactor your code.
<pre class="l42Big"><![CDATA[
mut Animal dog1 = Animal(__) //no promotion here
Animal dog2 = Animal(__) //promotion mutable->immutable
dog1.move()
//dog2.move()  //ill-typed, requires a mut Animal
]]></pre>

We will not explain in this tutorial the exact rules for promotion, but the main idea is that if the initialization expression uses local bindings in a controlled/safe way, then promotion can be applied.
For example, a mutable expression using only capsule or immutable references can be promoted to capsule or immutable, as we prefer.

</p><h2> lent and read </h2> <p>
We have seen immutable, mutable, capsule and class.
The are still two modifiers: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
They are hygienic references: they can be read but can not be stored in mutable/capsule/immutable fields.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> is an hygienic mutable reference, allowing mutation but not long term storage.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> is an hygienic read-only reference.
</p><p>
A method with a single mut parameter can still be called using a lent reference in place of it.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> is the common supertype of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>,<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In general, we can 
use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> when we do not care about the mutability of an object.
For example, we could add to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>

<pre class="l42Big"><![CDATA[
read method
Bool hasArrived() =
  this.path().isEmpty()
]]></pre>
This method can be called on both mutable and immutable animals: 

<pre class="l42Big"><![CDATA[
Debug(dog1.hasArrived())
Debug(dog2.hasArrived())
]]></pre>

</p><h2> (5/5) Summary </h2> <p>
  
</p><h2> Kinds of classes, summary </h2> <p>
  
<ul>
<li>
immutable classes:  have only immutable fields.
It is useful to model mathematical concepts.
It is easy to reason about code using immutable classes,
but some properties of real objects can be better modelled with state mutation.
</li><li>
shallow mutable classes:  have only (variable) fields of immutable or capsule type (or class, as we will see later). 
Reasoning with shallow mutable classes is near as easy as reasoning with immutable ones, and often more natural.
</li><li>
deep mutable classes:  have mutable fields.
Reasoning with deep mutable classes can be very hard.
</li></ul>
  
</p><h2> Modifiers: summary </h2> <p>

<ul>
<li>
immutable:  the default. When you omit the modifier,
 you mean immutable. 
An immutable reference points to an object that is never changing. Its whole reachable object graph never changes and is immutable as well.

</li><li>
mutable:  A mutable reference behaves like a normal reference in Java, C#, C++ , Python and many other languages.
Mutable references require mutable objects and allow mutating the referred object.
</li><li>
capsule:  capsule references are used only once and they guarantee that the whole reachable object graph is reachable only through that
capsule reference. 
Capsule references provide a structured way to reason over deep mutable objects.

Fields can be annotated capsule, the meaning is that they need to be initialized/updated with capsule variables.
We will discuss more about capsule fields and how they differ from capsule references later.
</li><li>
read:  A readable reference can not be used to mutate the referred object; but other mutable references pointing to the same object can mutate it.
Read references can point to both mutable and immutable objects.
It is easy to be confused between read and immutable references.
As a rule of thumb, if you are in doubt about whether to use an immutable or a readable reference,
you probably want an immutable reference.

</li><li>
lent:  a hygienic mutable reference allowing mutation but not storage.
Lent and read are useful to handle in controlled way the state of deep mutable classes;
moreover using lent and read on method parameters 
allows to make explicit what are the method intentions and requirements.
</li><li>

class:  class references denote the class object,
  on methods the meaning is the same of static methods in many languages, but it can consistently be used on parameters/local variables/fields
to encode behaviours similar to dependency injection.


</li></ul>



</p><h2> Keep control, summary </h2> <p>

<ul>
<li>
mutable:  mutable objects can be freely aliased and mutated. They allow for a liberal programming style like we can find in Java/C++/C# or Python.
They can be referred to by capsule, mutable, lent and read references.
</li><li>
immutable: immutable objects 
 can be obtained by promoting instances of mutable classes.
 They
can be referred to only by immutable and read references.

</li><li>
class:  class objects can be accessed from anywhere by using the corresponding class name;
It is also possible to 
store them into (class) local binding.
Some programmers found the fact that class objects are instances of themselves deeply concerning
or disturbing, while for others it is just a good story to tell to break the ice at parties.
</li></ul>
 </p><p id="BasicClasses"> </p><div style="break-after:page"></div><h1> Basic classes </h1> <p>

</p><h2> (1/5) Num </h2> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is a general number type,
implemented as an arbitrary precision rational.
When in doubt of what numeric type to use, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>
is a good first guess.
Some examples of usage: 
<pre class="l42Big"><![CDATA[
little      = 123Num
stillLittle = 4567890Num
big         = 100000000000000000Num
bigger      = 100000000000000000.0001Num
fraction1   = Num"1234567/890"
Debug(fraction1) //will print '1234567/890'
Debug(Num"12/4") //will print '3'
]]></pre>

Another useful numeric type is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>, for index and index offsets.
It corresponds to sizes and indexes in sequences.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>s are returned by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> methods
and are expected as parameter by indexing methods.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it> represent 32 bit integers with the usual 
but tricky modulo arithmetic.

</p><h2> Other numeric types </h2> <p>

AdamsTowel offers two other numeric types:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Double]]></span><it style="font-style: bold; color:green;">&#187;</it> (64 bits floating point) and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Math.Long]]></span><it style="font-style: bold; color:green;">&#187;</it> (64 bits integers, rarely used).


</p><h2> Conversions </h2> <p>
Conversions between various numeric classes must be performed explicitly.

AdamsTowel offers a simple way to convert between numeric classes; all numeric  classes implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Math.Numeric]]></span><it style="font-style: bold; color:green;">&#187;</it>
so that they can be converted in to each other using the empty named method. For example we can convert indexes into doubles by writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Double(12I)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This will avoid precision loss as much as possible.

</p><h2> (2/5) Units: An example library </h2> <p>

We will now see how to load and use an interesting 42 Library:<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Consider the following code, where the class decorator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> allows us to load libraries and embed them in the 
current context, while the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword imports the code from the web. 
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
Unit = Load:{reuse [L42.is/Unit]}
Year = Unit(I)
Person = Data:{S name, Year age}
]]></pre>

The library
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>
offers methods to create units out of numeric supports, like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The code above shows how to create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Year]]></span><it style="font-style: bold; color:green;">&#187;</it> unit and use it to represent a person age.

Units can be added to themselves and multiplied by constants; for example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year+2Year == 5Year]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year *2I == 6Year]]></span><it style="font-style: bold; color:green;">&#187;</it> would hold, but <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[3Year * 2Year]]></span><it style="font-style: bold; color:green;">&#187;</it> would not compile.

Units could be used to manually define 
all of the units of the SI system.
Prebuilt reusable code for the SI system is already provided in the library; we simply need to specify the desired support, as shown in the code below:

<pre class="l42Big"><![CDATA[
SI = Class:Unit.TraitSI['Support=>Num]
..
res = (6SI.Meter + 4SI.Meter) * 2Num //20Meter
//wrong = 6SI.Meter + 2SI.Second
]]></pre>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit.TraitSI]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <it style="font-style: italic;">trait</it>; traits contains reusable code and operations to adapt it to the current needs.
We will see more on traits (much) later in this guide.
<br/>
In the case of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit.TraitSI]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can adapt it to many kinds of numeric support and extract the code using 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class:Unit.TraitSI['Support=>Num]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[['Support=>Num]]]></span><it style="font-style: bold; color:green;">&#187;</it> maps the class called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Support]]></span><it style="font-style: bold; color:green;">&#187;</it> inside of the library onto the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> defined outside of the library. We will explain the precise use of such mappings later.

</p><p>
As you can see, we can sum meters together, and we can use the support for multiplication, but we can not mix different units of measure.

Mathematically you can obtain the support out of the unit by
division; that is, 42 meters divided by 2 meters is  21.
Units also provide method  <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#inner()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
which is just extracting the value of the support from the unit.
This can be convenient during programming but 
does not make a lot of sense mathematically and thus 
it should be used with care, similarly to other methods starting with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Num n1 = 42SI.Meter / 2SI.Meter //= 21Num
Num n2 = 42SI.Meter.#inner() //= 42Num
]]></pre>
</p><p>


Some code which uses units in interesting ways:

<pre class="l42Big"><![CDATA[
SI.Meter res1 = (6SI.Meter+4SI.Meter)*2Num //20M

Num res2 = 42SI.Meter/2SI.Meter

Num res3 = (42SI.Meter).#inner()

SI.Velocity fast1 =  42SI.Meter/0.1SI.Second

fast2 = SI.Velocity"420" //equivalent ways to initialize it
fast3 = SI.Velocity"840/2"

distance1 = 60SI.Second * fast1

g = 9.8SI.Acceleration

speedAfter = 10SI.Second * g //98 m/s

t = 10SI.Second

//free fall distance d=(gt^2)/2
distance2 = (g*t*t)/2Num //490 m after 10s free fall

//Newton=Kg*m/s2 = Kg*Acceleration
rocketForce = 900SI.Newton
stackWeight = 60SI.Kg+20SI.Kg //my weight+rocket weight
gForceOnMe = stackWeight*g //little less than 800
myLift = rocketForce-gForceOnMe
if myLift>0SI.Newton (Debug(S"I can fly"))
myAcc = myLift/stackWeight
reachedHeight = (myAcc*t*t)/2Num //after t (10 sec)
//works assuming the rocket fuel burnt in 10 sec is negligible
]]></pre>


</p><h2> (3/5) Alphanumeric </h2> <p>
In the same way <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Units]]></span><it style="font-style: bold; color:green;">&#187;</it> allows easy creation of
arithmetic classes,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Alphanumeric]]></span><it style="font-style: bold; color:green;">&#187;</it> allows easy creation of alphanumeric classes: 
classes that can be instantiated from a string literal that follow certain 
properties.


<pre class="l42Big"><![CDATA[
Email = S.Alphanumeric:{
  S local //fields
  S domain
  
  class method
  This (S string)={
    index= string.indexOf(S"@") //works only for simple emails
    if index==I"-1" (error S.ParseError"@ not found")
    local= string.subString(0I to=index) //string slicing
    domain= string.subString(index+1I to=\size) //string slicing
    if domain.contains(S"@") (error S.ParseError"multiple @ found")
    return This(string,local=local,domain=domain)
    } //call the factory with fields plus the original string
  }
...
myEmail = Email"arthur.dent@gmail.com"
myEmail.local()==S"arthur.dent" //holds
myEmail.domain()==S"gmail.com" //holds
myEmail.toS()==S"arthur.dent@gmail.com" //holds
]]></pre>

Note: we raise an error if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[string]]></span><it style="font-style: bold; color:green;">&#187;</it> does not have the shape we expected.
We will see errors/exception in more detail soon.
We can define fields, and compute their values by parsing the string.
It is common to propagate the original string from the factory into the object; but 
it is not mandatory. For example you could apply some form of normalization, as shown below: 

<pre class="l42Big"><![CDATA[
Email = S.Alphanumeric:{
  S local //fields
  S domain
  
  class method
  This (S string)={
    /*..*/
    local = string.subString(0\ to=index).replace(S"." with=S"")
    domain = /*..*/
    normedEmail = S"%local@%domain"
    /*..*/
    return This(normedEmail, local=local, domain=domain)
    } 
  }
/*..*/
myEmail = Email"arthur.dent@gmail.com"
myEmail.local()==S"arthurdent" //holds
myEmail.toS()==S"arthurdent@gmail.com" //holds
]]></pre>

</p><h2> (4/5) Enumerations </h2> <p>

Enumerations can be obtained with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Enum]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the following code:
<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{
  North={} East={} South={} West={}
  }
/*..*/
Debug(Direction.Vals()) // [North; East; South; West]
n = Direction.North()
s = Direction.South()
if n==s (/* .. dead code .. */)
Debug(n) //North
for d in Direction.Vals() (
  Debug(d) //prints all the directions in order.
  )
n==Direction.Vals(S"North") //holds
]]></pre>

Enumerations allows us to add operations as methods on the cases, as shown below:
<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{
  method This opposite()
  North = {method This1 opposite() = South() }
  East = {method This1 opposite() = West() }
  South = {method This1 opposite() = North() }
  West = {method This1 opposite() = East() }
  }
]]></pre>

</p><h2> (5/5) Summary </h2> <p>

<ul><li>
We had a look at
the most basic features of AdamsTowel.
There is rich support for defining your own specialized data structures instead of having to rely on the ones provided by default.
</li><li>
Use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.Alphanumeric]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Enum]]></span><it style="font-style: bold; color:green;">&#187;</it> to give meaning to your constants.
In this way, the type system will help you to use values with the semantics that you decided.
Be sure to define all of the right base classes to establish a convenient vocabulary
to talk about your problem domain.
</li></ul>
 </p><p id="ErrorsAndExceptions"> </p><div style="break-after:page"></div><h1> Errors and Exceptions: Messages in AdamsTowel </h1> <p>

</p><h2> (1/5)Errors, Messages, Asserts, Guards, .... So much terminology </h2> <p> 
In 42, when something takes an unexpected turn,
you can throw an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is similar to Java unchecked exceptions.
Every immutable object can be thrown as an error.
While it is possible to thrown informative strings, they do no offer enough
structure to fully take advantage of the error mechanism.
AdamsTowel defines the interface <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>:
a structured way to provide a certain kind of message to the user.
There are two main kinds of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>: 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Guard]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While assertions are useful to observe bugs, the application
logic should not depend on them, since they may change
in unpredictable ways during library evolutions, and can be enabled or disabled.
Since program logic can depend on guards being thrown,
guards need to be consistent across library evolution.

Assertions are a convenient tool to prevent the code from proceeding
out of our designed state space. The assertion class called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> 
looks like a road sign
and
 represents a feeling of "NO/PROHIBITED/FORBIDDEN" or something similar.

Assertions are also very convenient for checking pre/post conditions.
The following code show usages of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Pre]]></span><it style="font-style: bold; color:green;">&#187;</it> (for preconditions and, in general, blaming the client of a function)
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> (for postcondition checks in the middle and, in general, blaming the function implementation).

<pre class="l42Big"><![CDATA[
method Num confirmAnswer(Num answer) (
  X.Pre[ //preconditions
    answer>0Num; //simplest form
    answer<10000Num msg=S"here with personalized message answer= %answer";
    actual=answer, expected=42Num //do a better error reporting
    ] //in a bunch of assertions, they are all going to be checked/reported together.
  recomputedAnswer = 6Num*7Num
  X[//postconditions/checks in the middle
    actual=recomputedAnswer
    expected=42Num
    ]
  X[answer==recomputedAnswer]
  if answer>50Num (//how to just throw error X
    error X""
    )
]]></pre>
As you have seen, we have various ways to check for condition:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[answer>0Num;]]></span><it style="font-style: bold; color:green;">&#187;</it> checks a boolean condition,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[answer<.. msg=S"..";]]></span><it style="font-style: bold; color:green;">&#187;</it> checks the condition and uses a custom error message,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[actual=answer, expected=42Num;]]></span><it style="font-style: bold; color:green;">&#187;</it> takes two immutable values
and checks that they are structurally equivalent.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> is often used as last case in a sequence of if-return;
for example, instead of defining <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[opposite]]></span><it style="font-style: bold; color:green;">&#187;</it> inside of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it>, we could compute it externally as shown below:
<pre class="l42Big"><![CDATA[
Direction = Collection.Enum:{
  North = {}, East = {}, South = {}, West = {}
  }
/*..*/
Direction opposite = {
  if d==Direction.North() return Direction.South()
  if d==Direction.South() return Direction.North()
  if d==Direction.East() return Direction.West()
  X[d==Direction.West()] return Direction.East()
  }
]]></pre>
As you can see, since there are only 4 directions, we believe by exclusion that the last case must hold. However, we prefer to
make our assumptions clear and have them checked.


</p><h2> (2/5) Create, throw and capture </h2> <p>

</p><h2> Create and throw </h2> <p>

You can create new kinds of messages using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it>
as a decorator:

<pre class="l42Big"><![CDATA[
AnswerNotUnderstood = Message:{[Message.Guard]}
//this is a new kind of message, implementing Guard.
//you can also add methods to your kind of message.
//you can add fields, we will see this more in detail later.
/*..*/
//throwing an error
if this.ohNoNoNOOO() (error AnswerNotUnderstood"Well, too bad")
]]></pre>

In 42 interfaces can not have implemented methods, not even class ones, so you may be surprised that we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message]]></span><it style="font-style: bold; color:green;">&#187;</it> as a decorator, since decorating is a method call.
When operators are called on a class name directly, they are desugared as a method on one of its
nested libraries. For example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message:{..}]]></span><it style="font-style: bold; color:green;">&#187;</it> becomes
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message.ClassOperators():{..}]]></span><it style="font-style: bold; color:green;">&#187;</it>.
It is very common for an interface to be usable as a decorator, creating new code with a meaningful default implementation for the interface.

</p><h2> Capturing errors and exceptions </h2> <p>

In 42 there is no explicit <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[try]]></span><it style="font-style: bold; color:green;">&#187;</it> statement,
but any block of code delimited by round or curly brackets can contain <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In the code example below, lines 2 and 3 are conceptually inside the implicit <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[try]]></span><it style="font-style: bold; color:green;">&#187;</it> statement.
If nothing is thrown then lines 6, 7 and 8 are executed.
Note that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b3]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b4]]></span><it style="font-style: bold; color:green;">&#187;</it> can see <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b1]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b2]]></span><it style="font-style: bold; color:green;">&#187;</it>; this would not naturally happen in a language with explicit <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[try]]></span><it style="font-style: bold; color:green;">&#187;</it> statements; <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b1]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b2]]></span><it style="font-style: bold; color:green;">&#187;</it> would become local bindings inside the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[try]]></span><it style="font-style: bold; color:green;">&#187;</it> statement.
<pre class="l42Big"><![CDATA[
res = (
 b1 = CanGoWrong()
 b2 = CanGoWrong() //see b1
 catch error Wrong msg1  S"hi 1" //does not see b1, b2
 catch error Message.Guard msg2  S"hi 2" //does not see b1, b2
 b3 = CanGoWrong(b1) //does see b1, b2
 b4 = CanGoWrong(b2) //does see b1, b2, b3
 S"hi 3" //does see b1, b2, b3, b4
 )
]]></pre>
The catches above do not see local variables <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b1]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b2]]></span><it style="font-style: bold; color:green;">&#187;</it> because they may be capturing an error raised by the execution of the initialization of such variable.
L42 never exposes uninitialized data.
If a catch is successful, then the result of its catch expression
will be the result of the whole code block.
In this way, blocks with catches behave like conditionals.
That is, the code above can assign to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[res]]></span><it style="font-style: bold; color:green;">&#187;</it> either 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 1"]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 2"]]></span><it style="font-style: bold; color:green;">&#187;</it> or
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"hi 3"]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> Strong error safety </h2> <p>

In 42, error handling guarantees a property called strong error safety
(strong exception safety in the Java/C++ terminology).
This means that the body of a catch must not be able to observe
state mutated by the computation that threw the error.
This is enforced by disallowing catching errors in some situations.
<br/>
That is, the following code do not compile
<pre class="l42Big"><![CDATA[
p = Person(name=S"Bill" age=23Year)
res = (
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Message.Guard msg2 (
   /*could see p with 23 or 24 years*/)
 p
 )
]]></pre>

While the following is accepted.

<pre class="l42Big"><![CDATA[
res = (
 p = Person(name=S"Bill" age=23Year)
 p.age(p.age()+1Year)
 p.age(p.age()+1Year)
 catch error Message.Guard msg2 (/*can not see p*/)
 p
 )
]]></pre>

As you can see, in the first version of the code, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared outside of the block
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p.age(p.age()+1Year)]]></span><it style="font-style: bold; color:green;">&#187;</it> mutates it.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p]]></span><it style="font-style: bold; color:green;">&#187;</it> would be visible after the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch]]></span><it style="font-style: bold; color:green;">&#187;</it> is completed.
In the second version instead, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p]]></span><it style="font-style: bold; color:green;">&#187;</it> is out of scope after the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch]]></span><it style="font-style: bold; color:green;">&#187;</it> is completed, and the whole mutable ROG reachable from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p]]></span><it style="font-style: bold; color:green;">&#187;</it> is ready to be garbage collected.
</p><p>
Intuitively, a programmer who does a bunch of sequential operations on some mutable objects
would expect them all to be executed.
They expect the intermediate states of those objects not to be relevant to the surrounding program. Consider the following example:
<pre class="l42Big"><![CDATA[
method Void birthDay(mut Person bob) = (
  bob.age(\age+1\)
  bob.drunkCount(\drunkCount+1\)
  bob.partyCount(\partCount+1\)
  )
]]></pre>
Reading this code, most programmers would expect this method to keep the 3 counters aligned.
</p><p>
Exceptions and errors violate this intuition, since they can be raised in the middle of the sequence and prevent the later operations.
For example, if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bob.drunkCount(\drunkCount+1\)]]></span><it style="font-style: bold; color:green;">&#187;</it> fails, then Bob will miss his party, possibly because he is too drunk.
This violates the programmers' expectations
outlined above.
</p><p>
Exceptions can be accounted for, since the type system knows about them; so the programmer can be expected to plan for them.
On the other hand, errors can be raised
 anywhere and human programmers often
 account for them only as a last resort.
</p><p>
Thanks to strong error safety, this natural attitude of human programmers is somewhat mitigated: while it is true that Bob will miss his party, the program will never observe him in this sorry state. Bob is, indeed, ready to be garbage collected.
<br/>
Without strong error safety, we could simply catch the error and keep observing Bob in his distress.

</p><h2> (3/5) Exceptions and errors </h2> <p>

Exceptions are like checked exceptions in Java.
As with errors, every immutable object can be thrown as an exception.
You can just write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it> while throwing or catching. When catching, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it> is the default, so you can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch Foo x]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch exception Foo x]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
Exceptions represent expected, documented and reliable behaviour;
they are just another way to express control flow.
They are useful to characterize multiple outcomes of an operation,
where it is important to prevent the programmer from forgetting about
the many possible outcomes while focusing only on their preferred one.
Exceptions are checked, so methods leaking exceptions have to
mention it in their headers, as in the following.
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
mut method
S promptUser(S text)[CancelPressed] = {
  /*implementation to open a text dialog*/
  }
]]></pre>
The programmer using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[promptUser]]></span><it style="font-style: bold; color:green;">&#187;</it> has to handle 
the possibility that the cancel button was pressed.
However, L42 supports exception inference; to simply propagate the exceptions leaked out of the methods called in a method body, you can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[_]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown below:
<pre class="l42Big"><![CDATA[
/*somewhere in a GUI library*/
mut method
S promptUser(S text)[_] = {
  /*implementation to open a text dialog*/
  }
]]></pre>
Exceptions do not enforce strong exception safety as errors do,
so they can be used more flexibly, and since they are documented in
the types, we can take their existence in account while writing programs.
</p><p>
Often, the programmer wants to just turn exceptions into errors.
While this can be done manually, L42 offers a convenient syntax: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoops]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<pre class="l42Big"><![CDATA[
//long version
Res foo = {
  return DoStuff()
  catch FileNotFound fnf 
    error fnf
  catch FileCorrupted fc
    error fc
  }

//short version
Res foo = {
  return DoStuff()
  whoops FileNotFound, FileCorrupted
  }
]]></pre>

The two snippets of code behave nearly identically: 
in the second, the thrown objects are also notified of the 
position in the code where they are whoopsed.
This is conceptually similar to the very common
Java patten where checked exceptions are wrapped in unchecked ones.
<br/>

As we have shown before,  we can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> to mark branches of code
that the programmer believes will never be executed.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>, so code capturing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> is unreliable: as explained before, AdamsTowel programmers are free
to change when and how assertion violations are detected.
In particular, the programmer may recognize that
such a branch could be actually executed, and thus replace the error with correct behaviour.
</p><p>
Assertions should not be thrown as exceptions, but only as errors.


</p><h2> (4/5) Return </h2> <p>

As we have seen, we have used <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it> to exit  
from the closest surrounding pair of curly brackets.
Also curly brackets can have 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch exception]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch error]]></span><it style="font-style: bold; color:green;">&#187;</it>, which must complete by throwing a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error]]></span><it style="font-style: bold; color:green;">&#187;</it> or
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[exception]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/> Let's see some examples: 
<pre class="l42Big"><![CDATA[
{
  x = DoStuff()
  catch Stuff e1
    return S"a" //just swallow the exception
  catch Message.Guard e2 (
    obj.doSideEffect()
    return S"b" //do something and return
    )
  catch error Message e3
    error X"not supposed to happen"
  (//example of a nested block
    y = DoStuff(x)
    return y
    whoops Message.Guard
    )
  }
]]></pre>

Moreover, curly brackets can be used
to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[return]]></span><it style="font-style: bold; color:green;">&#187;</it> a different result if some computation fails: 

<pre class="l42Big"><![CDATA[
res = {
  return PlanA()
  catch error Message.Guard x
    return PlanB()
  }
]]></pre>

</p><h2> Return looks similar to error/exception </h2> <p>
Return is actually another thing that can be thrown and captured.
While only immutable values can be thrown as errors/exceptions,
return can throw any kind of value, but returns can not leak
outside of the scope of a method.
Hold your head before it explodes, but curly brackets are just a syntactic sugar
 to capture returns; these two snippets of code are equivalent: 
<div class= "compare">
<pre class="l42Big"><![CDATA[
Num res = {
  if bla ( return e1 )
  return e2
  
  }
]]></pre>
<pre class="l42Big"><![CDATA[
Num res = (
  if bla ( return e1 )
  return e2
  catch return Num x ( x )
  )
]]></pre>
</div>
</p><p>
Depending on how your brain works,
knowing the mechanics of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{..return..}]]></span><it style="font-style: bold; color:green;">&#187;</it>
can help you to use return better and understand why you can omit 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{..return..}]]></span><it style="font-style: bold; color:green;">&#187;</it> for simple method bodies, and why you can
write multiple groups of curly brackets and have local returns.
Or it may just be very confusing. If you are in the second group, just
never ever write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[catch return]]></span><it style="font-style: bold; color:green;">&#187;</it> explicitly and continue
on with your 42 experience.

</p><h2> (5/5) Errors, exceptions and return, summary </h2> <p>
<ul><li>
Always detect misbehaviour in your code, and 
terminate it with an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Assert]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
Whenever something outside your
 control happens, give it a name and throw it as an error, as in:
<pre class="l42Big"><![CDATA[
NameOfIssue = Message:{[Message.Guard]}
/*...*/
if /*..*/ ( error NameOfIssue"more info" )
]]></pre>
It just takes 2 lines, and will make debugging your code so much 
easier.
</li><li>
Use errors intensively, but use exceptions sparingly:
 they are needed only in a few 
cases, mostly when designing public libraries.
</li><li>
To convert exception into errors, use the convenient short
syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoops T1,..,Tn]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
Instead of manually writing long lists of leaked exceptions, 
you can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_]]]></span><it style="font-style: bold; color:green;">&#187;</it>. This is particularly convenient for small auxiliary methods.
</li><li>
It is sometimes possible to write elegant and correct code
that is not covered in layers upon layers of error/exception checking,
but often is not possible or not convenient.
Up to half of good 42 code will be composed of
just error/exception handling, repackaging and lifting.
Do not be scared of turning your code into it's own policemen.
</li></ul>
 </p><p id="Caching"> </p><div style="break-after:page"></div><h1> Caching </h1> <p>
</p><h2> (1/5) Normalization </h2> <p>
One of the big advantages of deeply immutable objects is that two structurally identical objects are referentially transparent, that is, you can not distinguish whether they are represented in memory by one object or two.
This means that it is possible to reuse the same objects to save memory. While in other languages the programmer would have to implement some specific support to reuse objects, in L42 this is supported directly in the language, by a process called <span style="color:#ff1111; font-weight: bold;"> normalization </span>.
An immutable object can be turned into its normalized version using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.norm()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Person = Data:{S name}
..
var bob1 = Person(S"Bob")//one bob in memory
var bob2 = Person(S"Bob")//two bobs in memory
bob1:=bob1.norm()
bob2:=bob2.norm()//most likely now bob2 refers to
//the same object of bob1.
//The object originally pointed to by bob2 is now inaccessible and
//can be garbage collected.
bob2:=bob2.norm()//repeating normalization has no effect; normalization is idempotent.
//The second calls to norm is as fast as a field access.
]]></pre>
As you can see, objects are born not normalized and can be normalized manually by the programmer.
Normalization is cheap but it is not free, so it is not convenient to apply it on short lived objects.
The programmer can express that all objects of a class are normalized during creation by passing parameters to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
Person = Data('This,autoNorm=\.true()):{S name}
..
var bob1 = Person(S"Bob")//one bob in memory
var bob2 = Person(S"Bob")//still only one bob in memory
bob2:=bob2.norm()//no-op, bob2 was already normalized
]]></pre>
Normalization starts by checking if another structurally equivalent object has ever been normalized.
Normalization normalizes all the sub objects
and also supports circular objects.
<br/>
Consider the following richer example:
<pre class="l42Big"><![CDATA[
Person = Data:{S name}//no more autoNorm!
Dog = Data:{S name, Person owner}
..
bob1 = Person(S"Bob")//one bob in memory
bob2 = Person(S"Bob")//two bobs in memory
dog1 = Dog(S"Grunthos", bob1)
dog2 = Dog(S"Agrajag", bob2)//two Dogs in memory
//dog1.owner() is a different object from dog2.owner()
//albeit they are structurally identical and we
//can not tell them apart using 42.
dog1.norm()//note: we do not reassign dog1 or dog2
dog2.norm()
//dog1 and dog2 are different objects, but
//dog1.owner() is now the same object as dog2.owner()
]]></pre>
Normalizing an object normalizes the whole ROG.
In the example, normalizing the two dogs also normalizes their owners, to the same normalized object.
All of the dogs' fields are then replaced with the normalized versions, so the two dogs now share an owner object.
Note that bob1 and bob2 are still two different objects.
</p><p>

The logic needed for normalization is the same needed to check if two arbitrary objects are structurally equal, to print an object to a readable string and to clone objects.
Thus data allows for all of those operations indirectly relying on normalization.
Those are all operations requiring to scan the whole ROG of the object, so the cost of normalization is acceptable in context.

</p><h2> (2/5) Lazy Caching </h2> <p>

Some methods may take a long time to compute, but they are deterministic, and thus we could cache the result and reuse it many times.
A typical example is Fibonacci:
<pre class="l42Big"><![CDATA[
class method Num slowFibo(Num n) = {
  if n==0Num || n==1Num (return n)
  return This.slowFibo(n=n-1Num)+This.slowFibo(n=n-2Num)
  }
]]></pre>
This Fibonacci implementation would take a very long time to run, since it would require recomputing the same
results an exponential amount of times.

This tweaked implementation relying on caching is much faster.
<pre class="l42Big"><![CDATA[
ComputeFibo = Data:{
  Num that
  @Cache.Lazy method Num () = {
    n = this.that()
    if n==0Num||n==1Num ( return n )
    This fibo1 = This(n-1Num)//a 'computation object'
    return fibo1()+This(n-2Num)()
    }
  }
//...
//usage example
ComputeFibo(42\)() == 267914296Num
]]></pre>
As you can see, instead of a method with parameters we can declare a class with fields and an empty named method doing the actual computation.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> is an annotation recognized by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> that works only on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> methods with no arguments and with an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> result.

That is, 42 does not directly recognize the annotation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Decorating the surrounding library with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> translates <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> into
an actual implementation.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ComputeFibo fibo1]]></span><it style="font-style: bold; color:green;">&#187;</it> is a <span style="color:#ff1111; font-weight: bold;"> computation object </span>: an imm object whose only goal is to support one (or more) computationally intense methods.
Thanks to normalization, the cache of computation objects is centrally stored, and thus recursive calls computing Fibonacci will be able to reuse the cache from other objects.
That is, the method result is cached on the normalized version of the receiver. In this way, 
all the redundant Fibonacci calls are avoided.

</p><p>
As you can see, the caching is is completely handled by the language and is not connected with the specific algorithm. This pattern is general enough to support any method from immutable data to an immutable result.

</p><h2> (3/5) Automatic parallelism </h2> <p>
When decorated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> caches the results of methods after they have been called the first time.
However, why wait for the methods to be called?
Once the receiver object is created, the method could be computed <span style="color:#ff1111; font-weight: bold;"> eagerly </span> in a separate worker, so that when we call the method, we may get the result without waiting at all.
That is, if we use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> we can get automatic parallelism: the language will handle a set of parallel workers to execute such method bodies.

</p><p>
An important consideration here is that both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> are unobservable; that is, the observed result of the code is not impacted by lazy or eager cache.

Consider the following code:

<pre class="l42Big"><![CDATA[
Task = Data:{ //Tasks are also computation objects
  S text
  @Cache.Eager method Bool isPolite() = ( .. )
  @Cache.Eager method Bool isGrammatical() = ( .. )
  }
Tasks = Collection.list(Task)

Main=(
  tasks=Tasks[
    \(text=S"..");
    ..
    \(text=S"..");
    ]
  for t in tasks (
    Debug( t.isPolite() )
    )
  )
]]></pre>
Here we declare a Task object with a string field and two eager methods: one will check if the text in the string is polite and another will check if the string is grammatically correct.
This can take quite a while. By using eager methods, it is sufficient to just create the objects to start those computations in parallel.
When we need the results, we can just iterate on those task objects and call the methods.
Objects with eager methods are automatically normed during creation, as if we used 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data('This,autoNorm=\.true())]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.

As you can see, in 42, parallelism and caching are just two sides of the same coin.

</p><h2> (4/5) Invariants and derived fields </h2> <p>
We have seen that cached behaviour can be computed lazily or eagerly on immutable objects.
But we can bring caching even earlier and compute some behaviour <span style="color:#ff1111; font-weight: bold;"> at the same time </span> 
as object instantiation.
This allows us to encode derived fields: 
fields whose values are completely determined
by other values in the same object.
Consider the following example:
<pre class="l42Big"><![CDATA[
Point = Data:{//not ok, the three-arg factory still exists
  Double x
  Double y
  Double distanceFromOrigin
  //should always be the square root of x^2+y^2
  class method This (Double x, Double y) = \(
    x=x
    y=y
    distanceFromOrigin=((x*x)+(y*y)).pow(exp=\"0.5")
    )
  }
]]></pre>
where the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> has 3 fields, but the value of the third one should depend only on the other two.
In 42, the code above would simply define a class with three unrelated fields, and while we are offering a factory that conveniently takes <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> and initialize the third field with 
the computed value, the user could easy create invalid instances by calling the factory method with three arguments.
As we will see later, in 42 we can prevent this from happening by making such a method private.
However, we would still be able to create an invalid <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> inside of other <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
Ideally, we would like to truly have only two fields, and have the third one as a precomputed derived value.

In 42, we can encode such concept using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
Point = Data:{
  Double x
  Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  }
]]></pre>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> class defined above has a single factory method taking just <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it>. In this way there is no need to have multiple ways to build the object and then hide the dangerous ones after the fact.

The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distanceFromOrigin(x,y)]]></span><it style="font-style: bold; color:green;">&#187;</it> is computed when a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> object is created.
Moreover, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> adds a method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read method Double distanceFromOrigin()]]></span><it style="font-style: bold; color:green;">&#187;</it>, allowing us to read the computed/cached value as we would if it were a field.
Note that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> makes a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> method calling the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> one.

If the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distanceFromOrigin(x,y)]]></span><it style="font-style: bold; color:green;">&#187;</it> leaks an error, it will be propagated out as if the method were manually called during object construction.

This means that any time you receive a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>, it has a valid distance.
</p><p>
We can build on this behaviour to encode class invariants:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> return type
designed to simply throw error if the state is incorrect.
For example, consider this updated version of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
Point = Data:{
  Double x
  Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  @Cache.Now class method Void invariant(Double x, Double y) = 
    if !(x>=0Double && y>=0Double) error X"""%
      | Invalid state:
      | x = %x
      | y = %y
      """
  }
]]></pre>

Now, every time user code receives a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it>, they can rely on the fact that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> are
non-negative and not NaN.

</p><h2> (5/5) Summary </h2> <p>
In 42 immutable objects, can be normalized in order to save memory.
This works also on circular object graphs. In case you are interested in the details, it relies on a variation of DFA normalization.
As a special case, objects without fields (immutable or not) are always represented in memory as a single object.
Results of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it>
 are attached to the normalized version of an object, thus making it possible to recover them simply by building a structurally identical object.
</p><p>
There are three kinds of caching, depending on the time the caching behaviour activates:

<ul><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value when the annotated method is first called.
It works on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> no-arg methods.
An obvious workaround for the no-arg limitation is to define computation objects; this also works well with normalization: computation objects will 
retrieve the cached results of any structurally equivalent object.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value in a separate parallel worker, starting when the object is created. It only works on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> no-arg methods of classes whose objects are all deeply immutable.
Those classes will automatically normalize their instances upon creation.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> computes the cached value during object construction.
Since the object does not exist yet, the annotation can only be placed on a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> method whose parameters represent the needed object fields.
This annotation does influence the observable behaviour.
If there is no error computing the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods,
then the fully initialized object is returned.
But, if an error is raised computing the cache,
instead of returning the broken object, the error is leaked during object construction.
<br/>
This, in turn, allows us to encode class invariants and to provide a static guarantee that users of a class can rely upon.

</li></ul>
 </p><p id="CachingMut"> </p><div style="break-after:page"></div><h1> Caching on Mutable objects </h1> <p>
</p><h2> (1/5) Cache invalidation </h2> <p>
The main advantage of caching methods of immutable objects is that the cache stays valid.
L42 can also cache methods of mutable objects, and discovers on its own when the cache needs to be invalidated.
Consider this trivial variation of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> example above where the fields can be updated:

<pre class="l42Big"><![CDATA[
Point = Data:{
  var Double x
  var Double y
  @Cache.Now class method Double distanceFromOrigin(Double x, Double y) = 
    ((x*x)+(y*y)).pow(exp=\"0.5")
  @Cache.Now class method Void invariant(Double x, Double y) = 
    if x<0Double || y<0Double error X".."
  }
]]></pre>
When a setter for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[x]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[y]]></span><it style="font-style: bold; color:green;">&#187;</it> is invoked, then the two <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods are recomputed.

In other programming languages, this behaviour can be encoded by
making the fields private and customizing the implementations of the setters to recompute the distance when needed. This pattern can grow very complex very fast.
L42 guarantees that a cached value is always structurally equivalent to the value that would be returned by calling the method again.
Moreover, for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, L42 also guarantees that if the computation was re-run then it would terminate without errors.
Thus, when <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> is used to emulate invariants, those invariants are guaranteed to hold for all observable objects, that is, all objects where the annotated method could possibly be called.

This is possible thanks to the strong L42 type system, and we believe this property can not be broken.
That is, we believe this property to hold even in the presence of exceptions, errors, aliasing, input output and non deterministic behaviour.
It is possible to make L42 work together with Java or even with (possibly broken) native code, and we believe our property will continue to hold.

</p><h2> (2/5) Deeply mutable objects </h2> <p>
As discussed above, a deeply mutable object is a mutable object with some mutable fields.
Also deeply mutable objects can support <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, 
but such objects must have <span style="color:#ff1111; font-weight: bold;"> encapsulated </span> state, as we have seen before for the class
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<pre class="l42Big"><![CDATA[
Animal = Data:{
  var Point location
  capsule Points path

  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )

  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  }
]]></pre>

The field <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule Points path]]></span><it style="font-style: bold; color:green;">&#187;</it> is an encapsulated mutable field.
It can be accessed as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> by doing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.path()]]></span><it style="font-style: bold; color:green;">&#187;</it>, but can not be directly accessed as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
However, we can write <span style="color:#ff1111; font-weight: bold;"> capsule mutator </span> methods by using 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Similarly to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, a class method can be annotated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> and can
take parameters representing the object's fields.
In addition, more parameters can be present encoding extra arguments.
To clarify, consider this richer example, where our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Animal]]></span><it style="font-style: bold; color:green;">&#187;</it> has an invariant and another capsule mutator method:

<pre class="l42Big"><![CDATA[
Point = Data:{ Double x, Double y
  method Double distance(Point that) = (
    x = this.x()-that.x()
    y = this.y()-that.y()
    (x*x)+(y*y)).pow(exp=\"0.5")
    )
  }

Points = Collection.list(Point)

Animal = Data:{
  var Point location
  capsule Points path

  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )

  mut method
  Void trim() = 
    this.removeFarthest(location=\location, distance=3Double)

  @Cache.Clear class method
  Void removeLeftPath(mut Points path) =
    path.removeLeft()
  
  @Cache.Clear class method
  Void removeFarthest(mut Points path, Point location, Double distance) = (
    var maxD=distance
    var maxI=I"-1"
    for p in path, i in Range(path.size()) (
      currentD = location.distance(p)
      if currentD>maxD (
        maxI:=i
        maxD:=currentD
        )
      )
    if maxI!=I"-1" path.remove(maxI)
    )

  @Cache.Now class method
  Void invariant(read Points path, Point location) = 
    if path.contains(location) error X"..."
  }
]]></pre>
We added a method to remove the farthest away point if it is over a certain distance.
As you can see, the parameters <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[path]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[location]]></span><it style="font-style: bold; color:green;">&#187;</it> corresponds to fields, while
the parameter <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distance]]></span><it style="font-style: bold; color:green;">&#187;</it> is extra needed information.
When we call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.removeFarthest(distance=3\)]]></span><it style="font-style: bold; color:green;">&#187;</it> we pass only <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[distance]]></span><it style="font-style: bold; color:green;">&#187;</it>; the other parameters are passed automatically.
<br/>
As an invariant, we require that the current location is not in the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[path]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This code, in the current form, has a bug; can you spot it?
Look carefully at the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move()]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
  mut method
  Void move() = (
    this.location(\path.left())
    this.removeLeftPath()
    )
]]></pre>
Here we first set up the location, then we remove it from the path.
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[move()]]></span><it style="font-style: bold; color:green;">&#187;</it> recomputes the invariant twice: one after the field setter 
and one after the call to the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
This first check is going to fail, since the leftmost element of the path has not been removed yet.
In this case we can solve the problem by swapping the lines:

<pre class="l42Big"><![CDATA[
  mut method
  Void move() = (
    left=this.path().left() //store left value
    this.removeLeftPath()   //before removing it
    this.location(left)     //set location to left
    )
]]></pre>

However, this kind of solution does not scale in the general case. 
Next, we will see a 
programming pattern that allows 
 the invariant checks
 (and more generally
    the recomputation of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> methods)
to be delayed in a controlled way.
</p><p>
</p><h2> Cache.Lazy and Cache.LazyRead </h2> <p>
As we have seen before, 
we can annotate <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> methods 
with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> so that 
the result will be computed once, the first time that
the method is called.
We can also annotate <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> methods in the same way.
However, the cache is now stored in the actual objects and not in the normalized versions.
This happens because a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference can refer to either mutable or immutable objects, and only immutable objects
can have normalized versions.
If anything in the ROG of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> object is mutated, then the cache is invalidated,
and the result will be recomputed the next time the method is called.
Indeed this annotation enables lazy caching on mutable data-structures, where the cache is automatically invalidated and removed when a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> method terminates.
Finally, since the type system can not track when the ROG from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> fields is mutated, a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Lazy read method]]></span><it style="font-style: bold; color:green;">&#187;</it> can only be applied to 
classes whose fields are all
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it>;
that is, their instance all have <it style="font-style: italic;">encapsulated state</it>.

</p><p>
If a class has <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> fields, but those are not actually used to compute the cached value,
we can apply the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation to an opportune <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> method instead.
Every method annotated as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> could instead be annotated as 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This annotation is a point in the middle between <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it>; it produces the same behaviour as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> but works similarly to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>: it is applied to
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> methods whose parameters represent fields, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> generates a correspondent no-arg <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Lazy]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> methods all behave as if they where recomputing the result, but with a different performance.
</p><p>
Cache invalidation is considered one of the <a href="https://martinfowler.com/bliki/TwoHardThings.html">great challenges</a> in writing correct programs; L42 can handle it correctly and automatically.
However, there is a cost: you have to encode the algorithm so that the type system accepts your code and so that the caching annotations can be applied.

</p><h2> (3/5) Box patten </h2> <p>

As we have seen, in order to
write mutable objects with encapsulated state,
we need to design them well, using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> to initialize the mutable data, using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> to mutate such state, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> for the invariant.
However, we can also program a naive deeply mutable object and box it up as a second step.
This can require a little more code, but it is more intuitive, and works very well for arbitrarily complex cases.
Consider the following code:

<pre class="l42Big"><![CDATA[
Bike = Data:{
  var mut Wheel front
  var mut Wheel back
  var mut Seat seat
  var mut Chain chain
  mut method Void nail() = this.#front().addHole()
  mut method Void rain(Second time) = this.#chain().addRust(time)
  read method Void invariant() = X[
    this.front().size()==this.back().size();
    this.seat().isComfortable();
    ]    
  }
//components can mutate (get damaged)
//and be updated (replaced with new ones)
]]></pre>
As you can see, the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> is a deeply mutable class, designed with no attention to
correctness: if the programmer is not careful, the same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Wheel]]></span><it style="font-style: bold; color:green;">&#187;</it>
may end up being used for multiple bikes at the same time.
Also, the method called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[invariant]]></span><it style="font-style: bold; color:green;">&#187;</it> only represents a programmer intention, but it is not enforced in any way, so it could be silently broken.

We can easy create a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it> class containing and encapsulating, such a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
BikeBox = Data:{
  capsule Bike box
  
  @Cache.Now class method
  Void invariant(read Bike box) = box.invariant()
  
  @Cache.Clear class method
  Void nail(mut Bike box) = box.nail()
  
  @Cache.Clear class method
  Void rain(mut Bike box, Second time) = box.rain(time=time)

  @Cache.Clear class method
  Void front(mut Bike box, capsule Wheel that) = box.front(that)
  }
..
//user code
b = BikeBox(box=\(front=\(..) back=\(..) seat=\(..) chain=\(..)))
b.nail()
//b.box().nail()/ ill-typed
Debug(b.box().front())//will display the unfortunate wheel
b.front(\(..)) //looks just like a normal setter, but acts on the internal object
]]></pre>

As you can see, no matter how complex some class code is, we can simply wrap it into a box and apply <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> on top of it.
In this way we end up with two types:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>, that does not offers any guarantee,
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it>, ensuring the invariant and
encapsulating the state.



The methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.nail()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.rain(time)]]></span><it style="font-style: bold; color:green;">&#187;</it>
and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox.front(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>
 will check for the invariant exactly one time, at the end of their execution.
Following this pattern, we can perform an arbitrarily long computation before the checks are triggered.

When writing other classes, we can choose to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it>
or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it>, depending on the specific details of our code.
If we chose to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> as a field of another class, we can still check 
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> invariant inside the invariant of the composite class:
<pre class="l42Big"><![CDATA[
FamilyGarage = Data:{
  mut Bike daddyBike
  mut Bike mummyBike
  mut Trike timmyBike  
  ..
  read method Void invariant() = X[
    this.daddyBike().invariant();
    this.mummyBike().invariant();
    this.timmyBike().invariant();
    ]
  }
FamilyGarageBox = Data:{
  capsule FamiliyGarage box

  @Cache.Now class method
  Void invariant(read FamilyGarage box) = box.invariant()  
  }
]]></pre>
</p><p>
As we have seen, with the box pattern we
can have the flexibility of temporarily open invariants without any of the drawbacks.
Of course, programmers will need to keep in mind which values are protected by invariants
and which values are unsupervised by invariants.
In 42 this is under the control of the type system: a value of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> has no special guarantees, while a value of type 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BikeBox]]></span><it style="font-style: bold; color:green;">&#187;</it> will ensure the invariant.

</p><h2> (4/5) Controlling the ROG shape </h2> <p>

An attentive reader may have notice that we would allow for fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[front]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[back]]></span><it style="font-style: bold; color:green;">&#187;</it> to point to the
 same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Wheel]]></span><it style="font-style: bold; color:green;">&#187;</it> object.
A Java programmer may be tempted to just add 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.front()!=this.back();]]></span><it style="font-style: bold; color:green;">&#187;</it> in the invariant,
but this would just use the user defined <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[!=]]></span><it style="font-style: bold; color:green;">&#187;</it> operator, that
on classes created using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is likely to check for structural equality instead of pointer equality.
AdamsTowel offers <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[System.mutReferenceEquality(a and=b)]]></span><it style="font-style: bold; color:green;">&#187;</it> to check for reference equality, but 
this method only works for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> objects.
The wheels are indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> objects,
but the invariant method takes a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> receiver; thus we can only see the wheels as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this case, the inability to use pointer equality is actually a good thing, since it does not correspond to what we really wanted to express: what if the two wheels are different objects but they share the same <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Tire]]></span><it style="font-style: bold; color:green;">&#187;</it> object?
What we want is to check that the mutable objects are not aliased in physically unreasonable ways.
Generally, what we often want is to ensure the tree shape of the mutable part of the object graph.

In 42, we can create classes where all of the instances are guaranteed to follow this property, by making all fields either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> types of classes that recursively respect this property
or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>/<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it>.
However, according to what we have seen up to now, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> fields can only be mutated by defining <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> methods, and those methods will be unable to mutate any other 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> field.
Consider the following code:

<pre class="l42Big"><![CDATA[
Tire = Data:{var Num pressure}
Wheel = Data:{var mut Tire tire}
Seat = Data:{var S description}
Chain = Data:{ var Num damage 
  mut method Void onWheel(lent Wheel that) = (
    lent Tire t=that.#tire()
    t.pressure(\pressure-1\)
    this.damage(\damage+1\)
    )
  }
]]></pre>

Here the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Chain]]></span><it style="font-style: bold; color:green;">&#187;</it> can rub onto the wheel, damaging it.
The parameter of method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it> is
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it>. This guarantees that the object graphs of the chain and the wheel will 
not be mangled together by the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Can we assemble a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bike]]></span><it style="font-style: bold; color:green;">&#187;</it> while being able to both use 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[onWheel]]></span><it style="font-style: bold; color:green;">&#187;</it> and guaranteeing the tree structure?
The trick is to declare <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> exposers manually:
<pre class="l42Big"><![CDATA[
Bike = Data:{
  var capsule Wheel front
  var capsule Wheel back
  lent method lent Wheel #front() //lent exposer
  lent method lent Wheel #back() //lent exposer
  var capsule Seat seat
  var capsule Chain chain
  lent method lent Chain #chain()//lent exposer
  mut method Void chainOnWheel() = 
    this.#chain().onWheel(this.#back())
    
  }
BikeBox = Data:{..}//as before
]]></pre>
That is, by declaring lent exposers manually we gain the possibility of writing methods that mutate the capsule fields without using the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> pattern.
In exchange for this extra flexibility, 
those fields do not count as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> fields for the sake of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.LazyRead]]></span><it style="font-style: bold; color:green;">&#187;</it> annotations.
However, we can still use through the box pattern, as show before.



</p><h2> (5/5) Summary </h2> <p>

Representation invariants and lazy caching
can be applied to mutable objects as well as immutable ones.

Proving properties on mutable
 objects requires us to know and apply various patterns.
Historically, in software verification, representation invariants where small 
units of code, mostly focusing on the direct content of the fields and mostly relying on either pointer equality or the binary value of primitive datatypes, where the invariants could be deliberately  broken while the program was still able to observe the broken object.
None of this is possible in 42; in particular, 42 guarantees that no broken objects can be observed.
The box pattern allows us to divide the value into two types:
the one with an enforced invariant and the raw object state.
This recovers 
the flexibility of temporarily open invariants
without any of the drawbacks.

Note that a sound language with normalization and caching/invariants
can not offer pointer equality tests on immutable objects.

Consider the example of a list whose invariant requires all
 of its elements to have a distinct pointer values.
A list with such an invariant may contain two structurally equal but not pointer equal elements.
Suppose such a list became immutable and was
normalized.
Now those two elements
would be pointer equal, and the invariant would have been broken by normalization.
</p><p>
It can be hard to remember the differences between all of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.***]]></span><it style="font-style: bold; color:green;">&#187;</it> annotations.
Below, we show a table summarizing them.

<table>
<tr>
<th>&nbsp;&nbsp;annotation&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;recType&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;parameters&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;transformedInto&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;storage&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;timing&nbsp;&nbsp;</th>
</tr>
<tr>
<td>Cache.Lazy</td>
<td>class</td>
<td>zero</td>
<td></td>
<td>class</td>
<td>first call</td>
</tr>
<tr>
<td>Cache.Lazy</td>
<td>imm</td>
<td>zero</td>
<td></td>
<td>norm</td>
<td>first call</td>
</tr>
<tr>
<td>Cache.Lazy</td>
<td>read*</td>
<td>zero</td>
<td></td>
<td>instance</td>
<td>invalidation</td>
</tr>
<tr>

<td>Cache.Eager</td>
<td>imm*</td>
<td>zero</td>
<td></td>
<td>norm</td>
<td>parallel</td>
</tr>
<tr>

<td>Cache.LazyRead</td>
<td>class</td>
<td>fields</td>
<td>read0</td>
<td>instance</td>
<td>invalidation</td>
</tr>

<tr>
<td>Cache.Now</td>
<td>class</td>
<td>fields</td>
<td>read0</td>
<td>instance</td>
<td>invalidation+</td>
</tr>
<tr>
<td>Cache.Clear</td>
<td>class</td>
<td>fields+</td>
<td>mut+</td>
<td>instance-</td>
<td>when called</td>
</tr>
</table>

</p><p>
Notes:
<ul>
<li>
imm* = applicable only on classes with all fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>/<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> and not <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li>
<li>
read* = applicable only on classes with all fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>/<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li>
<li>
fields  = method parameters are field names.
Capsule fields are seen as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li>
<li>
fields+ = the first parameter is a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> field, seen as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>. Additional parameters can be <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>,<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li>
<li>
invalidation = the method is executed on the first call, or the first call after invalidation.
</li>
<li>
invalidation+ = the method is executed during the factory, and immediately after any invalidation.
</li>
<li>
instance- = caches in the instance are invalidated.
</li>
<li>
read0 = a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> method with zero parameters.
</li>
<li>
mut+ = a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> method with the additional parameters as for fields+.
</li>
<li>
parallel = executed in a parallel worker starting after the factory.
</li>
</ul>

</p><h2> Digressions / Expansions </h2> <p>
As we have seen, parallel programming can be viewed as a form of caching.
In some cases, we need parallel programming on mutable data.
In our experience, this is not very common; the cost of copying data around is much smaller that most programmers assume.
Let us repeat this very clearly: there are many other ways to optimize software, and they are much easier and much,
much more rewarding than avoiding copying the few mutable parts of your data structure a couple of times.

We think that only highly skilled and motivated programmers 
can discover and hunt down all of those other much more pressing algorithmic issues that
often spoil performance.
Only after approaching the performance limits of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> with good algorithms,
it could make sense to adopt parallel programming on mutable data to avoid some
extra clones.

However, if you are in such a situation,
you can use the annotation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.ForkJoin]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below.
Again, the 42 type system will ensure that parallelism is not observable.
</p><p>
<pre class="l42Big"><![CDATA[
Example = Data:{
  @Cache.ForkJoin class method capsule D foo(capsule A a,capsule B b, capsule C c) = (
    mut A a0=a.op()
    mut B b0=b.op()
    mut C c0=c.op()
    a0.and(b0).and(c0)
    )
  }
]]></pre>
Like other <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.***]]></span><it style="font-style: bold; color:green;">&#187;</it> annotations, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.ForkJoin]]></span><it style="font-style: bold; color:green;">&#187;</it> is translated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> 
into an actual implementation.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.ForkJoin]]></span><it style="font-style: bold; color:green;">&#187;</it> works only on methods whose body is exactly a round parenthesis block.
The initialization expressions for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a0]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b0]]></span><it style="font-style: bold; color:green;">&#187;</it>, and 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[c0]]></span><it style="font-style: bold; color:green;">&#187;</it> are run in parallel, and the final expression is run only when 
all of the initialization expressions are completed.
The method itself can take any kind of parameters, and they can all be used in the final expression, but the initialization expressions need to fit one of the following three safe parallel patterns:

</p><h2> Non-Mutable computation </h2> <p>
In this pattern, none of the initialization expressions can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters.
In this way nothing can be mutated while the forkjoin is open, thus parallelism is safe.
This is more expressive than <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> since it allows us to run parallel code on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> references of mutable objects.

</p><h2> Single-Mutable computation </h2> <p>
In this pattern, a single initialization expression can use any kind of parameter, while the other ones can not 
use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters.
This pattern allows the initialization expression that can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> to recursively explore a complex mutable data structure and to command updates to immutable elements arbitrarily nested inside of it.
Consider for example this code computing in parallel 
new immutable string values for all of
the entries in a mutable list:

<pre class="l42Big"><![CDATA[
UpdateList=Public:Data:{
  @Public class method S map(S that)=that++that//could be any user defined code
  @Public class method Void (mut S.List that) = this(current=0I,data=that)  
  class method Void (I current, mut S.List data) = (
    if current<data.size() 
      this(current=current,elem=data.val(current),data=data)
    )
  @Cache.ForkJoin class method Void (I current, S elem, mut S.List data) =(
    S newElem=this.map(elem)
    this(current=current+1I,data=data)
    data.set(current,val=newElem)
    )
  }
MainUpdate = (
  mut S.List data = S.List[S"a";S"b";S"c";S"d";S"e";]
  Debug(data)
  UpdateList(data)
  Debug(data)//["aa"; "bb"; "cc"; "dd"; "ee"]
  )
]]></pre>
As you can see, we do not need to ever copy the whole list. We can update the elements in place one by one.
If the operation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[map(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> is complex enough, running it in parallel could be beneficial.
As you can see, it is trivial to adapt that code to explore other kinds of collections, like for example a binary tree.
Or, in other words, if you are unsure on how to adapt that code to work on a tree, you should stick with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> and accept that you are not (yet) one of the few elite programmers with enough skill to take advantage of the 42 fork join.

AdamsTowel could use metaprogramming features to define code that parallelises user defined operations on lists, maps and other common datastructures. However, we think this is beyond the responsibility of AdamsTowel, and should instead be handled by some user defined library.

</p><h2> This-Mutable computation </h2> <p>
In this pattern, the 'this' variable is considered specially.
The method must be declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, and the 
initialization expressions
can not
use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters.
However, the parameter <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to directly call
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> methods. 
As we have seen before, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> methods can mutate a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> field; thus different initialization expressions must use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Clear]]></span><it style="font-style: bold; color:green;">&#187;</it> methods updating different <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> fields.

In this way, we can make parallel computation processing arbitrary complex mutable objects inside well encapsulated data structures .
Consider the following example, where <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Foo]]></span><it style="font-style: bold; color:green;">&#187;</it>s could be arbitrarily complex; containing complex (possibly circular) graphs of mutable objects.
<pre class="l42Big"><![CDATA[
Foo=Data:{.. /*mut method Void op(I a, S b)*/ ..}

Tree={interface [HasToS]    mut method Void op(I a, S b) }

Node = Data:{[Tree] 
  capsule Tree left, capsule Tree right
  @Cache.ForkJoin mut method Void op(I a, S b) = (
    this.leftOp(a=a,b=b)
    this.rightOp(a=a,b=b)
    void//this void is needed so that the two lines
    )    // above are both declarations
    @Cache.Clear class method Void leftOp(mut Tree left,I a, S b) = left.op(a=a,b=b)
    @Cache.Clear class method Void rightOp(mut Tree right,I a, S b) = right.op(a=a,b=b)
    }
Leaf = Data:{[Tree]
  capsule Foo label
  @Cache.Clear class method Void op(mut Foo label,I a, S b) = label.op(a=a,b=b)
  }
MainTree = (
  mut Tree top = Node(
    left=Node(
      left=Leaf(label=\(..))
      right=Leaf(label=\(..))
      )
    right=Node(
      left=Leaf(label=\(..))
      right=Leaf(label=\(..))
      )
    )
  Debug(top)
  top.op(a=15I b=S"hello")
  Debug(top)
  )
]]></pre>

This pattern relies on the fact that using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> fields we can define arbitrary complex data structures composed of disjointed mutable object graphs.
Note that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> aliases to parts of the data structure can be visible outside.
This is accepted since we can not access them when the forkjoin is open. The declarations can not use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters.
 </p><p id="InterfacesAndMatching"> </p><div style="break-after:page"></div><h1> Interfaces, subtypes and matching </h1> <p>

</p><h2> (1/5)Interfaces, Basis and Details </h2> <p>
</p><h2> Interfaces Basis </h2> <p>
Interfaces in 42 are quite similar to interfaces in other OO languages.
There are however a couple of important differences.

</p><p>

While implementing an interface method, you can avoid the
type signature.
For example, in the following code, to implement <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape.draw(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> inside
of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it>, the types <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Canvas]]></span><it style="font-style: bold; color:green;">&#187;</it> are not repeated.
<pre class="l42Big"><![CDATA[
Shape = {interface
  method Void draw(mut Canvas that)
  }
Square = {[Shape]
  method draw(that) = /*..*/
  }
]]></pre>

In 42, we say that the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[draw(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>
<it style="font-style: italic;">implemented</it> in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it>
is <it style="font-style: italic;">declared</it> by
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it>. 
Each method is <it style="font-style: italic;">declared</it> at a single point. 
Method declarations include parameter and return types.
A method can be 
<it style="font-style: italic;">defined</it> (that is, declared and implemented)
in the same class;
or declared in a (transitively) implemented interface and
then just implemented.
This means that a class cannot 
satisfy multiple interfaces declaring methods
with the same method selector.
For example, this code is ill-typed: 
<pre class="l42Big"><![CDATA[
Card = {interface
  method Num draw() //the value of the drawn card
  }
Gun = {interface
  method Num draw() //the time it takes to drawn the gun
  }
Wrong = {[Card,Gun] //not allowed
  }
]]></pre>


Note that would be bad 42 code anyway; you should define an enumeration (or an alphanumeric)
for your cards and use a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Second]]></span><it style="font-style: bold; color:green;">&#187;</it> unit of measure
for the time,
which would make the unavoidable type error more obvious.

</p><p>

Interface diamonds are allowed; that is, the following code is correct: 
<pre class="l42Big"><![CDATA[
Shape = {interface
  method Void draw(mut Canvas that)
  }
Animal = {interface [Shape]
  method Meter run()
  }
Noisy = {interface [Shape]
  method Void play(mut Audio that)
  }
LoudCat = {[Animal, Noisy]
  method draw(that) = /*..*/
  method run() = /*..*/
  method play(that) = /*..*/
  }
]]></pre>

</p><p>

You can refine the return type of an interface method, by repeating the full type signature with the desired return type.
On the other hand, the parameter types cannot be refined.
<pre class="l42Big"><![CDATA[
Monster = {interface
  method Monster spawnMinion()
  }
BigMonster = {[Monster]
  method BigMonster spawnMinion() = /*..*/
  }
]]></pre>


</p><h2> (2/5) Interfaces and class methods </h2> <p>

Interface methods in 42 are all abstract; that is, without bodies.
A version of the body will be provided by all classes implementing the interface.
<span style="color:#ff1111; font-weight: bold;"> This also includes class methods. </span>
<br/>
For example, consider the following code: 
<pre class="l42Big"><![CDATA[
Shape = {interface
  class method 
  Num numberOfSides()
  class method
  This newShape(Color that)
  method
  Void draw(Canvas that)
  }

Square = {[Shape]
  Color color
  method numberOfSides() = //class method implemented
    4Num
  method newShape(that) = //class method implemented
    This(color=that)
  method draw(that) = //immutable method implemented
    /*..*/
  }
/*..*/
class Shape kindOfShape = Square
X[kindOfShape.numberOfSides()==4Num] //holds
Shape s = kindOfShape.newShape(Color.red())
]]></pre>

The pattern in the code above encodes the abstract factory 
pattern in a much simpler way: 
the binding <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[kindOfShape]]></span><it style="font-style: bold; color:green;">&#187;</it> serves the role of
an instance of an abstract factory, and can create instances of
a specific kind of shape.
</p><p>

In 42 interfaces do not have 
implemented class methods.
Sometimes we want to semantically associate some behaviour with an interface.
For example we could check intersections between shapes using
the draw method.
What we would need, is a traditional (non dynamically dispatched) static method.
In 42, static methods are just nested classes with a single class method with the empty name. In 42 adding new classes is very common, so do not be scared of adding a new class just to host a method.

<br/>
For example
<pre class="l42Big"><![CDATA[
Shape = {interface
  /*..*/
  Intersect = {class method
    Bool (Shape left, Shape right) = 
      /*..*/
    }
  }
]]></pre>

</p><h2> (3/5)Subtyping </h2> <p>
Dynamic dispatch is the most important feature of object oriented languages.
Subtyping is the main feature supporting dynamic dispatch; for example 
we can iterate over a list of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[draw()]]></span><it style="font-style: bold; color:green;">&#187;</it> them without the need to explicitly handle in the code all the possible kinds of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape]]></span><it style="font-style: bold; color:green;">&#187;</it> on a case by case basis.
 
Note that modifiers (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>,..)) offer subtyping but not dynamic dispatch.

</p><p>
Interfaces and classes represent two fundamentally alternative compromises between
the providers and users of objects:
<ul><li>
Interfaces allows client code to be implicitly parametric on the behaviour of individual objects.
The client code can make no assumption on the specific implementation of the interface.
</li><li>
Classes allow client code to rely on their invariants.
The user code is forced to pass only a specific kind of implementation.
</li></ul>

</p><p>
In simpler terms, if we have a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Shape s]]></span><it style="font-style: bold; color:green;">&#187;</it> interface,
and we call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[s.draw()]]></span><it style="font-style: bold; color:green;">&#187;</it>, we will get the right kind of drawing behaviour for that shape.
On the other hand, we can not statically predict what kind of shape and behaviour we will execute.
<br/>
If instead we have a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square s]]></span><it style="font-style: bold; color:green;">&#187;</it> class,
then we can
statically predict what kind of behaviour <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[s.draw()]]></span><it style="font-style: bold; color:green;">&#187;</it> will execute, and that the width and height of the drawn shape are going to be equal, as for the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it> invariant.
On the other hand, our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Square]]></span><it style="font-style: bold; color:green;">&#187;</it> using code can only be used with squares, not any of the other kinds of shape.

</p><h2> (4/5)Matching </h2> <p>

It is possible to inspect the runtime type of an object by using matching.
We will now provide various examples of matching and explain the behaviour.
</p><p>
<pre class="l42Big"><![CDATA[
method Square example1(Shape s1, Shape s2) = {
  if s1 <: Square ( return s1 )//s1 is of type Square in the if body
  if Square y = s1.bar() ( return y ) //if bar returns a Square, we call it y
  if s1<: Circle, s2<:Square ( return s2.with(side=s1.radius()) )
  error X""
  }
]]></pre> 
We can use an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if]]></span><it style="font-style: bold; color:green;">&#187;</it> to check for the type of a local binding or an expression.
We can also check for more then one local binding at a time.
When an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if]]></span><it style="font-style: bold; color:green;">&#187;</it> checks for types it cannot have an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[else]]></span><it style="font-style: bold; color:green;">&#187;</it> branch.
This <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if-return]]></span><it style="font-style: bold; color:green;">&#187;</it> pattern allows us to write complex dispatch in a compact way, without the need of an explicit <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[else]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>
The syntax <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[<:]]></span><it style="font-style: bold; color:green;">&#187;</it> can also be used in expressions when the type system needs help with figuring out
the type, usually because some information will be generated by a decorator at a later stage. Sometimes we may have to write code like the following
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(a.bla()<:mut Foo).baz()]]></span><it style="font-style: bold; color:green;">&#187;</it>:
the method 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[baz()]]></span><it style="font-style: bold; color:green;">&#187;</it> is called on the result of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.bla()]]></span><it style="font-style: bold; color:green;">&#187;</it>, that we expect to return a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Foo]]></span><it style="font-style: bold; color:green;">&#187;</it>.
While <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if _ <: _]]></span><it style="font-style: bold; color:green;">&#187;</it> will check the type at run time,
the explicit (sub-)type annotation with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[<:]]></span><it style="font-style: bold; color:green;">&#187;</it> is checked at compile time, as if we wrote 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(mut Foo tmp = a.bla(), tmp.baz())]]></span><it style="font-style: bold; color:green;">&#187;</it>

</p><p>
The code below:
<pre class="l42Big"><![CDATA[
method Point example2(Point left,Point right) = {
  (x1,y1) = left
  (x2,y2) = right
  return Point(x=x1+x2,y=y1+y2)  
  }
]]></pre>
is equivalent to:
<pre class="l42Big"><![CDATA[
method Point example2(Point left,Point right) = {
  x1=left.x()
  y1=left.y()
  x2=right.x()
  y2=right.y()
  return Point(x=x1+x2,y=y1+y2)  
  }
]]></pre>
That is: we can match out the result of any no-arg method into a variable with the same name, plus an optional numeric suffix.
This syntax can also be used inside of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[if]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is often done for fields. Of course it works also to extract a single field:

<pre class="l42Big"><![CDATA[
method Square example3(Shapes ss) = {
  (size) = ss //extracts the 'size' from ss
  (I size1) = ss//same but with explicit type
  if (Square left) = ss ( return left )//matches if the leftmost element of the list is a Square
  if (Triangle left, Square right) = ss ( return right )//matches if the leftmost and the
    //rightmost elements are a Triangle and a Square.
  if Circle(Point center) = ss.left() ( return center.squareAround() ) //matches if the leftmost
    //is a Circle and the method center() returns a Point. Both checks are dynamic.
  error X""
  }
]]></pre>

As we have seen, matches are a form of syntactic sugar allowing more compact code for extracting subcomponents and taking decisions about their dynamic types.

</p><h2> (5/5)Interfaces, subtypes and matching, summary </h2> <p>

Interfaces in 42 serve the same role that they serve in other languages,
with a little bit of a twist in the details.

The big news is that decorators (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> in our examples) can
provide the boilerplate implementations for free.
This is much more powerful than traits, multiple inheritance or
Java 8 default methods, since the implementation can be generated by examining the class.
 
<br/>
In the right conditions, matching is a useful tool to reduce code size and complexity.
However, dynamic dispatch is still the preferred option in the general case. On the other hand type matching works only on a finite
number of hard-coded cases, making it fragile with respect to code evolution.
 </p><p id="Sequences"> </p><div style="break-after:page"></div><h1> Collection: list, map, set, optional and their operations </h1> <p>

</p><h2> (1/5)lists manipulation </h2> <p>

As we have seen before, lists can be defined using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.list(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, as in the example below.

<pre class="l42Big"><![CDATA[
Nums: Collection.list(Num) //declaration for a list of nums
/*..*/
xs0 = Nums[10\;20\;30\] //xs0 <: mut Nums
Nums xs1 = Nums[10\;20\;30\] //xs1 <: imm Nums == //xs1 <: Nums
imm xs2 = Nums[10\;20\;30\] //xs2 <: imm Nums == //xs2 <: Nums
xs3 = Num.List[10\;20\;30\] //xs3 is another kind of list of nums
]]></pre>
As you can see above, many of the most common <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> classes have a nested class
called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.List]]></span><it style="font-style: bold; color:green;">&#187;</it> as a convenience feature, to avoid having to define your own in most programs.

<br/>

Lists can be created with square brackets; they are born mutable but can become immutable 
if they are directly assigned to an immutable local binding or parameter, or by other forms of promotion; for example,
a method without <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> parameters returning a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference
can be used to initialize an immutable binding.
You need to specify the type of the local binding to force the promotion.
<br/>
For example: 

<pre class="l42Big"><![CDATA[
imm myNums = DoIt.getMutableNums() //ok promotions happens, myNums is immutable

myNums = DoIt.getMutableNums() //myNums type is inferred to be mut Nums
]]></pre>

Immutable lists can be combined with operators.
The general idea is that operators 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+,-]]></span><it style="font-style: bold; color:green;">&#187;</it> work 
on one sequences and one element,
while the corresponding doubled-up operators
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[++,--]]></span><it style="font-style: bold; color:green;">&#187;</it>
work on two sequences.
You can see the details of this below.
<pre class="l42Big"><![CDATA[
X[
  //element addition
  Nums[a;b;c]+d == Nums[a;b;c;d];
  //element addition works both ways
  k+Nums[a;b;c]+d == Nums[k;a;b;c;d];
  //sequence concatenation
  Nums[a;b]++Nums[c;d] == Nums[a;b;c;d];
  //element removal
  Nums[a;b;b;c]-b == Nums[a;c];
  //sequence subtraction
  Nums[a;b;b;c]--Nums[b;c] == Nums[a];
  ]
]]></pre>
In addition of operators, immutable lists also support a plethora of methods:
<pre class="l42Big"><![CDATA[
X[
  //replacement
  Nums[a;b;c;d].with(2I,val=e) == Nums[a;b;e;d];
  Nums[a;b;c;d].with(left=e) == Nums[e;b;c;d];//equivalent to Nums[..].with(0I val=e)
  Nums[a;b;c;d].with(right=e) == Nums[a;b;c;e];//equivalent to Nums[..].with(\size-1I val=e)
  //insertion
  Nums[a;b;c;d].withAlso(2I,val=e) == Nums[a;b;e;c;d];
  Nums[a;b;c;d].withAlso(left=e) == Nums[e;a;b;c;d];
  Nums[a;b;c;d].withAlso(right=e) == Nums[a;b;c;d;e];
  //skipping/filtering
  Nums[a;b;c;d].without(2I) == Nums[a;b;d];
  Nums[a;b;c;d].withoutLeft() == Nums[b;c;d];
  Nums[a;b;c;d].withoutRight() == Nums[a;b;c];
  Nums[a;b;c;b;d].withoutAll(val=b) == Nums[a;c;d]; // like '--'
  Nums[a;b;c;b;d].without(left=b) == Nums[a;c;b;d]; //filters out the leftmost b
  Nums[a;b;c;b;d].without(right=b) == Nums[a;b;c;d]; //filter out the rightmost b
  ]
]]></pre>
As you notice, there are different kind of actions: 
replace an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with]]></span><it style="font-style: bold; color:green;">&#187;</it>),
insert an element (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[withAlso]]></span><it style="font-style: bold; color:green;">&#187;</it>)
and skipping/filtering elements out (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[without]]></span><it style="font-style: bold; color:green;">&#187;</it>).
Then, elements can be specified by index, by being
the leftmost or the rightmost.
To filter elements out,
you can also just provide the element.

</p><p>


Immutable collections (and also mutable ones, as we will see later)
can be accessed with the following methods: 

<pre class="l42Big"><![CDATA[
X[
  //access
  Nums[a;b;c;d].left() == a;
  Nums[a;b;c;d].right() == d;
  Nums[a;b;c;d].val(2I) == c;
  Nums[a;b;c;d].size() == 4I;
  !Nums[a;b;c;d].isEmpty();
  ]
]]></pre>

</p><h2> Mutate sequences </h2> <p>

Mutable sequences can be more efficient that 
immutable ones, and are more general, since they 
can store mutable objects.
<br/>


Now we show some methods over a mutable list <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[foo = Nums[a;b;c;d]]]></span><it style="font-style: bold; color:green;">&#187;</it>; consider each following line independently: 
<pre class="l42Big"><![CDATA[
//setting a value in a position
foo.set(2I val=e) //foo == Nums[a;b;e;d]
//setting at left or right
foo.left(e) //foo == Nums[e;b;c;d]
foo.right(e) //foo == Nums[a;b;c;e]

//add a value in a position
foo.add(2I val=e) //foo == Nums[a;b;e;c;d]

//add at left or right
foo.add(left=e) //foo == Nums[e;a;b;c;d]
foo.add(right=e) //foo == Nums[a;b;c;d;e]

//removal
foo.remove(2I) //foo == Nums[a;b;d]
foo.removeLeft() //foo == Nums[b;c;d]
foo.removeRight() //foo == Nums[a;b;c]

//removal
foo.removeAll(val=b) //foo == Nums[a;c;d]
foo.remove(left=b) //remove the leftmost b
foo.remove(right=b) //remove the rightmost b
]]></pre>


</p><h2> (2/5) Iterations on lists and views </h2> <p>

We now show various pattens to iterate on lists.
First some usual foreach:
<pre class="l42Big"><![CDATA[
vec = S.List[S"foo"; S"bar"; S"beer"]
var result = S""
var max = 0I
for myElem in vec (
  result++=myElem 
  max:=max.max(myElem.size())
  )
X[result==S"foobarbeer";max==4I]
]]></pre>

In 42 foreach allows to iterate on multiple collections at once, and also to update the collections:
<pre class="l42Big"><![CDATA[
rs = Nums[  1\;  2\;  3\]
as = Nums[ 10\; 20\; 30\]
bs = Nums[100\;200\;300\]
for a in as, b in bs, var r in rs ( r:= r+a+b )
X[ rs==Nums[111\;222\;333\] ]
]]></pre>

In the example above, a dynamic error would be raised if 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[rs]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[as]]></span><it style="font-style: bold; color:green;">&#187;</it> and
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bs]]></span><it style="font-style: bold; color:green;">&#187;</it> have different length.
We believe this is the right default behaviour.
To allow, for example, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[bs]]></span><it style="font-style: bold; color:green;">&#187;</it> to be longer then <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[as]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[rs]]></span><it style="font-style: bold; color:green;">&#187;</it>,the programmer can 
use some variants of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>; a method producing an iterator on a subsequence of the original sequence.
The following variants are available: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[vals(to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(that,to)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#vals(to)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In the example below we use them to control iteration:
<pre class="l42Big"><![CDATA[
for a in as, b in bs.vals(to=as.size()), var r in rs ( r:= r+a+b )
//will give error if bs.size()<as.size() or as.size()!=rs.size()

for a in as.vals(1I), b in bs.vals(1I to=as.size()), var r in rs ( r:= r+a+b )
//will skip the first element of as and bs. Will skip any extra element of bs.
//will give error if as.size()!=rs.size()+1I
]]></pre>

The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.View]]></span><it style="font-style: bold; color:green;">&#187;</it> provides flexible iterators and sub-sequences.
Consider the following code examples:
<pre class="l42Big"><![CDATA[
NView = Collection.View(Num.List).cut()
MainCut = {
  xs= Num.List[..]
  ys= Num.List[..]
  for x in xs, y in NView(ys) ( .. )
    //will iterate as long as xs, even if ys is longer.
    //will stop after xs.size() cycles, and fail if xs.size()>ys.size()
  for x in NView(xs), y in NView(ys) ( .. )
    //will iterate for as long as both xs and ys have elements.
    //similar to a functional zip
  }
NViewM = Collection.View(Num.List).more()
MainMore = {
  xs= Num.List[..]
  ys= Num.List[..]
  for x in xs, y in NViewM(ys, more=30Num) ( .. )
    //will iterate as long as xs, even if ys is shorter.
    //y = 30Num when the iteration get over ys.size()
  for x in NViewM(xs, more=10Num), y in NViewM(ys, more=30Num) ( .. )
    //will iterate for as long as either of xs and ys have elements, and values
    //x = 10Num, y = 30Num are used when the collections exhausted their elements.
  for x in NView(xs), y in NViewM(ys, more=30Num) ( .. )
    //behaves as in the "x in xs" case: a 'cut' view will consume 'more' elements
    //if they are available
  }
]]></pre>

</p><h2> The power of the \ </h2> <p>

There are various methods taking advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> syntactic sugar.
They provide an expressive power similar to what list-comprehensions provide in python and streams in Java, but by just using simple control flow like for/if:

<pre class="l42Big"><![CDATA[
as =  Num.List[1\;2\;3\;4\;]

//mapping
bs0 = Num.List()( for a in as \add(a*10Num) )
X[ bs0==Num.List[10\;20\;30\;40\] ]

//filtering
bs1 = Num.List()( for a in as if a>2Num \add(a) )
X[ bs1==Num.List[3\;4\] ]

//flatmapping
bs2 = Num.List()( for a in as for b in bs0 \add(a+b) )
X[ bs0==Num.List[11\;21\;31\;41\;12\;22\;32\;42\;13\;23\;33\;43\;14\;24\;34\;44\;] ]

//reduce to string
str0 = S"the content is: ".builder()( for a in as \add(a) )
X[ str0 == S"the content is: 1234" ]
str1 = S"[%as.left()".builder()( for n in as.vals(1I) \add(S", %n") )++S"]"
X[ str1 == S"[1, 2, 3, 4]" ]

//reduce/fold
acc  = ( var x = 0Num, for a in as ( x+=a ), x )
acc1  = 0Num.acc()( for a in as \add(a) ) //also \addIf, \times, \val ..
X[ acc==acc1; acc1 == 10Num ]

//checks a property; great in an if or an X[]
ok0 = Match.Some()( for a in as \add(a>3Num) )
X[ ok0 ]

X[ !Match.All()( for a in as \add(a>3Num) ) ]

X[ !Match.None()( for a in as \add(a>3Num) ) ]

X[ 0I.acc()( for a in as \addIf(a>3Num) )==2I ]

asContainsAllBs = Match.All()( for b in bs \add(b in as) )

asIntersectBs = Match.Some()( for b in bs \add(b in as) )

asDisjointBs = Match.None()( for b in bs \add(b in as) )
//Note: b in as == as.contains(b)
]]></pre>
The language 42 is expression based. Expressions that look like statements are just expressions with the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> return type.
Those methods that take advantage of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> are simply methods with a single parameter 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void that]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method in the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match.**]]></span><it style="font-style: bold; color:green;">&#187;</it> examples short circuit when appropriate, so that the for can terminate as soon as the result is known.


</p><h2> (3/5) Lists with mutable and immutable elements </h2> <p>

Mutable sequences can contain mutable objects.
While this can be useful in special circumstances, it can create aliasing issues similar to the
ones of the animals example of before.
To warn against such issues, methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left()]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> return 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> references to mutable objects. In order to obtain 
a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, the user needs to use the methods
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#left()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#right()]]></span><it style="font-style: bold; color:green;">&#187;</it>
 and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>

Up to now we focused on lists of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>, but 
all instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> are immutable; we now discuss what happens where
mutable lists contains a mixture of mutable and immutable elements.
Consider the following code:
<pre class="l42Big"><![CDATA[
Point  = Data:{var Num x, var Num y}
Points = Collection.list(Point)
..
imm p0 = Point(x=0\,y=0\) //an imm point
p1 = Point(x=1\,y=1\) //a mut point
ps = Points[p0;mutVal=p1] //a mut list with both points
X[
  p0==ps.val(0I);
  p0==ps.left();
  p1.readEquality(ps.#val(1I)); // '==' only works on imms, and check on norms
  p1.readEquality(ps.#right()); // readEquality checks for structural equality
  p0.readEquality(ps.readVal(0I)); // .readVal generalizes over imm/mut values
  p1.readEquality(ps.readVal(1I));
  ]
for read p in ps ( Debug(p) )
]]></pre>

As you can see, to insert a mutable point we need to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mutVal]]></span><it style="font-style: bold; color:green;">&#187;</it> and to
take the point out we have to add the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it> to the method.
When iterating on a list, if we expect a mixture of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> values we must add <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>
to avoid a runtime error.
If we expect all values to be <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> instead.
When a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> collection is promoted to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, it still remembers what values were originally inserted as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
To make it so that all values can be read as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, we can use the method
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.immNorm()]]></span><it style="font-style: bold; color:green;">&#187;</it>. In addition of normalizing the collection, it also marks all values
accessible as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown in the code below:

<pre class="l42Big"><![CDATA[
Points immPs=(
  imm p0=Point(x=0\,y=0\) //an imm point
  p1=Point(x=1\,y=1\) //a mut point
  Points[p0;mutVal=p1] //a mut list with both points
  ).immNorm()
for p in ps ( Debug(p) ) //works, it would fail without 'immNorm()'
]]></pre>

</p><h2> (4/5) Map, set, opt.. </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> also support maps, sets, optional and enumerations.
We will add more kinds of collections in the future.

</p><h2> Optional </h2> <p>
In 42 there is no concept of null, and all the values are always intentionally initialized before
they can be read.
There are two main reasons programmers rely on nulls: optional values and circular/delayed initialization.
Circular initialization can be solved with a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd]]></span><it style="font-style: bold; color:green;">&#187;</it> types, an advanced typing feature that we do not discuss here.
Optional values are a staple of functional programming and are logically equivalent to a collection of zero or one element, or, if you prefer, a box that may or may not contain an element of a certain type.
Optionals values can be obtained with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.optional(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below.
Optionals are also optimized so that they do not require the creation of any new objects at run time.

<pre class="l42Big"><![CDATA[
Point = Data:{ var Num x, var Num y }
OPoint = Collection.optional(Point)
Main = (
  imm p00 = Point(x=0\ y=0\)//an imm Point in 00
  mut p01 = Point(x=0\ y=1\)//a mut Point originally in 01
  var imm p00Box = OPoint(p00) //immutable Optional Point
  var mut p01Box = OPoint(p01) //mutable Optional Point
  X[
    p00 in p00Box; //the in syntax checks if an object is in the box
    p00Box.val()==p00; //Data defines == only for imm references
    p01Box.val().readEquality(p01);//here .val() gives us a read reference
    ]
  if p00Box ( Debug(S"printing %p00Box") )//printing [Point(x=0, y=0)]
  //we can just check if a box is not empty as if it was a boolean
  p01Box.#val().x(50\)//updates the x value of the point
  Debug(S"printing %p01")//printing Point(x=50, y=1)
  p00Box:= OPoint()//updates the local variables with empty boxes
  p01Box:= OPoint()
  if !p00Box ( Debug(S"printing %p00Box") )//printing []
  X[
    !(p00 in p00Box);
    !p00Box;//using isPresent() or not is just a matter of style
    !p00Box.isPresent();
    ]  
  )
]]></pre>
At this point in the tutorial, some readers will be confused that we can update the local variable binding 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> even if it is immutable.
Other readers instead will remember that immutability is a property of the reference and not of the binding/field: a local binding and fields declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> can be updated.
The updated value needs to respect the modifier of the field/binding type: if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> it needs to be updated with another <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it>; if it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> then it can be updated with either
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Oh, yes, another reader will realize ... and a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> reference can be assigned to any of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Note how both local bindings are updated using the same exact expression:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00Box:= OPoint()    p01Box:= OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it>
In 42 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint()]]></span><it style="font-style: bold; color:green;">&#187;</it> can be either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> (or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it> indeed)
On the other side, consider 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p00)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OPoint(p01)]]></span><it style="font-style: bold; color:green;">&#187;</it>: the first one is immutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p00]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>,
while the second one is mutable since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[p01]]></span><it style="font-style: bold; color:green;">&#187;</it> is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>
Optionals can be combined with the short circuting operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[&&]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[||]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Many interesting patterns emerge from this:
<pre class="l42Big"><![CDATA[
S.Opt o1 = ..
S.Opt o2 = ..

if o1 && o2 (/*executed only if both are present*/)

o3 = o1 || o2 //o3==o1 if o1 is present, otherwise o3==o2; thus
//o3 is empty only if they are both empty. Very useful pattern

o4 = o1 && o2 //o4==o2 if also o1 is present, otherwise o4 is empty

Bool b = !!o1 //hacky but effective conversion to bool :-P

s1 = o1.val() //dynamic error if o1 is empty
s2 = o1.val(orElse=S"default") //with a default value if o1 is empty.

//what if computing the default value is a slow operation?
(val) = o1 || S.Opt(MakeDefault.lotsOfTime())
//This pattern computes the default value only if o1 is empty
]]></pre>

</p><h2> Map </h2> <p>
Thanks to normalization 42 can have very fast and most reliable hash sets and hash maps.
The values of sets and the keys of maps must be immutable, and are normalized just before being inserted in the collection.
Then, the value of the normalized pointer is used to check for equality and hashcode.
This has various positive effects:

<ul><li>
The user does not need to write equality and hashing behaviour
</li><li>
There is no risk of mistake in the equality and hashing behaviour
</li><li>
The intrinsic invariants of the hashmap/hashset are never violated/corrupted.
</li><li>
The equality is a perfect structural equality, but is as fast as pointer equality; for maps with large keys this can make a massive performance difference.
</li></ul>

Maps and sets have less methods than lists, but they can still be iterated upon, as shown in the following code:

<pre class="l42Big"><![CDATA[
Point = Data:{var Num x, var Num y}
Points = Collection.list(Point)
PointToString = Collection.map(key=Point, val=S)
Roads = Collection.map(key=S, val=Point)
Main = (
  map = PointToString[
    key=\(x=3\ y=4\), val=S"MyBase";
    key=\(x=0\ y=0\), val=S"Source";
    key=\(x=5\ y=8\), val=S"EnemyBase";
    ]
  for (key,val) in map ( Debug(S"%key->%val") )
  //we can use (..) to extract the key/val fields from PointToString.Entry
  //this iteration is straightforward since all values are imm
  roads = Roads[
    key=S"Kelburn Parade", val=\(x=0\ y=0\); //immutable to immutable
    key=S"The Terrace", mutVal=\(x=0\ y=0\);//immutable to mutable
    key=S"Cuba Street", mutVal=\(x=0\ y=0\);//immutable to mutable
    ]
  for read (key, val) in roads ( Debug(S"%key->%val") )
  //we add 'read' in front to be able to read mixed imm/mut values
  //if all the values were mutable, we could just add 'mut' in front
  )
  mut Roads.OVal optPoint = roads.#val(key=S"Cuba Street"))
  optPoint.#val().x(50\)//update the field of the object inside the map
  ]]></pre>

As you can see, when objects are retried from the map, we obtain an optional value; this is because statically we can not know if a key is mapped to a value or not.
We can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(orElse)]]></span><it style="font-style: bold; color:green;">&#187;</it> or the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[||]]></span><it style="font-style: bold; color:green;">&#187;</it> pattern to provide a default value if the key is not contained in the map.
<br/>
In addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
maps offers the following methods:
<ul><li>
To extract a value using the key:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>; to extract an optional
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference, respectively.
As for lists, it is always safe to extract a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference. An empty optional will be produced when attempting to extract as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm/mut]]></span><it style="font-style: bold; color:green;">&#187;</it> a value that was inserted as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut/imm]]></span><it style="font-style: bold; color:green;">&#187;</it> instead, so to reliably ask if a key is contained in the map we should write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[map.readVal(key=myKey).isPresent()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</li><li>
Mutable maps can be modified by
inserting immutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it> and mutable values with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#put(key,val)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Finally, an association can be removed using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(key)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.map(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> creates a class remembering the insertion order.
This is needed to make the iteration deterministic.
The keys can be retrieved with their order using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[key(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> passing the desired <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I index]]></span><it style="font-style: bold; color:green;">&#187;</it>, from zero to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\size-1I]]></span><it style="font-style: bold; color:green;">&#187;</it>
The corresponding value can be retrieved by methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readVal(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> 
to extract a
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> (not optional) reference to the value, respectively.
</li></ul>
     

</p><h2> Set </h2> <p>
Sets behave a lot like maps where the values are irrelevant, and have differently named methods.
In particular, in addition to conventional <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
sets offer methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[add(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[remove(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> to add and remove an element,
and elements can be extracted in the insertion order by using method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[val(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>

We are considering adding operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+,-,++,--]]></span><it style="font-style: bold; color:green;">&#187;</it> to sets, as supported by lists.
On the other side, boolean methods like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[intersect(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[disjoint(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[containsAll(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> can already be easily emulated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match]]></span><it style="font-style: bold; color:green;">&#187;</it> as we shown for lists.

</p><h2> (5/5) Collection summary </h2> <p>

<ul><li>
There are tons of methods and operators to know, but since most code works 
around collections, it is worth the effort to memorize them.
</li><li>
Immutable collections are easy to play with, using operators and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with**]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
</li><li>
Mutable collections can be more efficient and flexible, but they come with additional difficulties.
</li><li>
Most methods have a general version that works with an index, and specialized <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[left]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[right]]></span><it style="font-style: bold; color:green;">&#187;</it> variants.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it> can help remove a lot of boilerplate, but is a concept unique to 42, and require some effort to get used to.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> is very useful and flexible. It is common to find methods composed from just a large
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> statement plus a little pre and post processing around it.
</li></ul>

</p><h2> Digressions / Expansions </h2> <p>
Collections support iteration with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> syntax.
Iteration in 42 is way more flexible than in most other languages, and it is delegated on method calls.
Iteration in 42 is designed to support two main iteration strategy:
explicit indexes and iterator objects.
For example, the code

<pre class="l42Big"><![CDATA[
for read a in as, var b in bs ( b:=b.foo(a) )
]]></pre>
would expand to
<pre class="l42Big"><![CDATA[
aIt = as.#iterator()
bIt = bs.##iterator()
var ai = as.#startIndex()
var bi = bs.#startIndex()
while aIt.#hasElem(ai).#itAnd(bIt.#hasElem(bi)) (
  var a=aIt.#elem#read(ai)
  var b = bIt.#elem#default(bi)
  b := bIt.#update#default(bi,val=b.foo(a))
  ai := ai.#succ()
  bi := bi.#succ()
  ) 
]]></pre>
Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#elem#read]]></span><it style="font-style: bold; color:green;">&#187;</it> is used instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#elem#default]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[b]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it> <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.##iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> is used instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Iteration methods in detail </h2> <p>

<ul>
<li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[##iterator]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
They return an object able to provide the elements of the list. The second variant
returns a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> object, this is needed to provide the mutable version of those elements, and to update those elements in the list.
The second variant is used if the local binding is explicitly declared either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[var]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it>,<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[lent]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[capsule]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For complex bindings, like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(key, mut val)=e]]></span><it style="font-style: bold; color:green;">&#187;</it>, the second variant is used if any binding component would require it.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
The initial iteration hint is produced by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> and moved forward by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#itAnd]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#more]]></span><it style="font-style: bold; color:green;">&#187;</it>
<br/>
The iterator checks if it has more elements to provide by calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since iterations in 42 can work on multiple collections at the same time,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> results can be combined with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#itAnd]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This design offers a lot of flexibility;
special kinds of collections may return special data types to coordinate termination in some way.
The AdamsTowel collections opt for an efficient solution where 
there are four logical results for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustContinue]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canContinue]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canStop]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The iteration will stop if all the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[canStop]]></span><it style="font-style: bold; color:green;">&#187;</it>,
and an error is raised if some <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustContinue]]></span><it style="font-style: bold; color:green;">&#187;</it> and some other returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mustStop]]></span><it style="font-style: bold; color:green;">&#187;</it>.

With this design, the result of the single <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> method coordinates the various iterators to check if more elements are possibly available, and to decide how strongly to insist for those elements to be visited.
</li></ul>

</p><h2> Possible implementations of Iteration methods </h2> <p>

The iterator methods allows for a range of possible options.
The simplest one, and possibly the most efficient, is to delegate everything to the collection object:
in this case, there is no need to create a new object to serve as an iterator, since
the collection itself is able to simply access/update its elements by index, thus 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#varIterator]]></span><it style="font-style: bold; color:green;">&#187;</it> may simply return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> returns the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> returns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it> if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that<this.size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I"-1"]]></span><it style="font-style: bold; color:green;">&#187;</it> otherwise.
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#close]]></span><it style="font-style: bold; color:green;">&#187;</it> will throw error if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#hasElem]]></span><it style="font-style: bold; color:green;">&#187;</it> would return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[0I]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
Another option would be the one of a linked list, where it would be inefficient to
rely on the index to access the elements.
In this case,
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#iterator]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#varIterator]]></span><it style="font-style: bold; color:green;">&#187;</it> may simply return a singleton object
delegating the behaviour to the index object.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#startIndex]]></span><it style="font-style: bold; color:green;">&#187;</it> can simply expose the first internal
node, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#succ]]></span><it style="font-style: bold; color:green;">&#187;</it> can produce the next node.
The singleton object may be able to see private methods of those
internal nodes, thus even if we expose the internal nodes, they will be 
just unusable black boxes to the library user, and all the interactions can be mediated, and checked by the singleton iterator object.
</p><p>
Iterators in Java and other languages will throw an error if the collection is somehow modified during the iteration. This could be supported by providing a specialized sublist object that can remember its version; but it is unclear if this is a good idea in 42, where most collections would be iterated while they are immutable.
The few cases of iteration on mutable collections
may be the ones where there are good reasons to perform mutation during iteration.
While adding elements at the start of a collection under iteration is most likely a bug, other operations have very reasonable use cases.
For example, 
appending elements at the end of a list while computing a fixpoint, removing tasks from the end of a list if they are now unneeded,
or replacing already visited elements with new ones.
 </p><p id="InputOutput"> </p><div style="break-after:page"></div><h1> Input Output with Object Capabilities </h1> <p>
</p><h2> (1/5) Controlling non determinism </h2> <p>
Traditionally, in imperative languages I/O and side effects can happen everywhere, while
in pure functional languages like Haskell they are kept in check by monads.

In 42 we have type modifiers to keep mutation and aliasing under control.
With only the features shown up to now, 42 is a deterministic language, thus
every expression that only takes immutable objects
can be called multiple times with the same values and will produce the same result.

<br/>
The whole caching system relies on this property to work.
<br/>
Thus input output, random numbers and any other kind of observable non determinism must preserve this property.
Introducing object capabilities:
<br/>
An <it style="font-style: italic;">object capability</it> is a mutable object whose methods can do some non deterministic, or otherwise privileged operation.
If a method is given a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> reference to an object capability, then it can be non deterministic,
otherwise it will be deterministic.
Creation of new object capabilities is only possible by either relying on an existent object capability
or by using a <it style="font-style: italic;">capability method</it>: a method whose name starts with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$]]></span><it style="font-style: bold; color:green;">&#187;</it>; however those specially named methods can only be called from a main, from another capability method or from a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> method of a capability object.

</p><h2> (2/5) Example: File System </h2> <p>

To read and write files we need to load a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FileSystem]]></span><it style="font-style: bold; color:green;">&#187;</it> library as shown below:
<pre class="l42Big"><![CDATA[
Fs = Load:{reuse [L42.is/FileSystem]}
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs]]></span><it style="font-style: bold; color:green;">&#187;</it> is the local name for the library located at <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[L42.is/FileSystem]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator embeds the library in the current environment.
We can now use our file system:
<pre class="l42Big"><![CDATA[
Main1 = (
  mut Fs f = Fs.Real.#$of()
  f.write(on=Url"data.txt",content=S"SomeContent0") //non deterministic operation
  S s=f.read(Url"data.txt") //non deterministic operation
  //the result depends on the current file content
  f.write(on=Url"data.txt",content=S"SomeContent") //non deterministic operation
  //the operation could go in error if there is not enough space to write the content on disk.
  Debug(s)
  )
]]></pre>
The crucial point in the former code example is the call to 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs.Real.#$of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This instantiates a capability object using the capability method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

We could write the code inside a method in the following way:
<pre class="l42Big"><![CDATA[
ReadWrite = { class method Void (mut Fs f)[_] = (
  S s=f.read(Url"data.txt")
  f.write(on=Url"data.txt",content=S"SomeContent")
  Debug(s)
  ) }
Main1 = ReadWrite(f=Fs.Real.#$of())
]]></pre>
Note how we pass the capability object explicitly to the method.
This is the most common style, and have great testing advantages:
Indeed, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs]]></span><it style="font-style: bold; color:green;">&#187;</it> corresponds to the following interface:
<pre class="l42Big"><![CDATA[
interface
mut method Void delete(Url that)[Fs.Fail]
mut method Void makeDirs(Url that)[Fs.Fail]
mut method S read(Url that)[Fs.Fail]
mut method S readBase64(Url that)[Fs.Fail]
mut method Void write(Url on, S content)[Fs.Fail]
mut method Void write(Url on, S contentBase64)[Fs.Fail]
]]></pre>
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs.Real]]></span><it style="font-style: bold; color:green;">&#187;</it> is simply an implementation of such interface connected with the real file system.
Thus, we can write a simple mock to check that the function behaves as expected:
<pre class="l42Big"><![CDATA[
Mock = Data:{[Fs]
  var S log=S""
  method delete(that) = error X""
  method makeDirs(that) = error X""
  method read(that) = (
    X[actual=that expected=Url"data.txt"]
    this.log(\log++S"read")
    S"oldContent"
    )
  method readBase64(that) = error X""
  method write(on,content) = ( 
    X[actual=on expected=Url"data.txt";
      actual=content expected=S"SomeContent";]
    this.log(\log++S"write")
    )
  method write(on,contentBase64) = error X""
  }
Test1= (
  m=Mock()
  ReadWrite(f=m)
  {}:Test"ReadWriteOk"(actual=m.log() expected=S"readwrite")
  )
]]></pre>

</p><h2> (3/5) Object capabilities programming patterns </h2> <p>

The advantage of the division of the file system in an interface and a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Real]]></span><it style="font-style: bold; color:green;">&#187;</it> implementation are not limited to testing.
For example, the user could embed some security and on some restrictions in an alternative implementation of a file system.
Consider the following code:

<pre class="l42Big"><![CDATA[
OnlyTxt = Public:{[Fs]
  mut Fs inner
  
  read method Void checkTxt(Url that) = X.Guarded[
    that.toS().endsWith(S".txt")
    ]
  method makeDirs(that) = error X""
  method write(on,contentBase64) = error X""
  method readBase64(that) = error X""
  method delete(that) = (
    this.checkTxt(that)
    this.#inner().delete(that)
    )
  method write(on,content) = ( 
    this.checkTxt(on)
    this.#inner().write(on=on, content=content)
    )
  method read(that) = ( 
    this.checkTxt(that)
    this.#inner().read(that)
    )
  @Public class method mut This #$of() = //example user declared #$ method, that can
    This(inner=Fs.Real.#$of())   //use $# methods inside its body
  @Public class method mut This(mut Fs inner)
  }
SaferMain = (
  fs = OnlyTxt.#$of()
  ReadWrite(f=fs)
  Debug(S"done")
  )
]]></pre>
Any code that would take in input a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> would have a limited access to the file system; only able to read and write onWcode(*.txt) files.
Here we see for the first time the decorator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> explores all the nested classes of the decorated code, and if there is at least a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Public]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation, all the other members of such nested class will become private.
Methods implemented from interfaces are left untouched.
In the example above, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> leaves the two factory methods visible and hides the field getter and exposer.
We discuss <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> more in the detail later.
<br/>
Instances of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> are capability objects; note how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it> can even declare a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$of]]></span><it style="font-style: bold; color:green;">&#187;</it> method. In this way for the user there is no syntactical difference between using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs.Real]]></span><it style="font-style: bold; color:green;">&#187;</it> or using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[OnlyTxt]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Capability objects are a useful abstraction and can be designed and implemented by normal 42 programs; they are not just a way for the language implementation to expose native code.
We have just shown that new object capabilities can easy be defined by simple wrapping over existing capability objects.

<br/>
Since inner is of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Fs]]></span><it style="font-style: bold; color:green;">&#187;</it>, this programming patterns allows us to layer many levels of security / restrictions on top of a capability object, as shown below:
<pre class="l42Big"><![CDATA[
fs = OnlyTxt(inner=OnlySmallFiles(inner=Fs.Real.#$of()))
]]></pre>


</p><h2> (4/5) Connection with other languages </h2> <p>
In general, all the  non determinism in 42 is obtained by communicating with other languages.
42 allows us to connect with Java, and Java allows us to connect with C/assembly.
The best way to connect with java is to use the library <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JavaServer]]></span><it style="font-style: bold; color:green;">&#187;</it> as shown below:
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
J0 = Load:{reuse [L42.is/JavaServer]}
J = J0(slaveName=S"mySlave{}")
]]></pre>
The code above loads the library <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JavaServer]]></span><it style="font-style: bold; color:green;">&#187;</it>. It is a generic library: before being used we need to provide a name for the Java slave.
A 42 program is not a single process but a cluster of intercommunicating Java processes.
There is one master process where the 42 computation is actually running and many other slave processes allowing safe input output and safe interaction with arbitrary code.
Such slave processes have their own name: in this case <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mySlave]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Slaves also have a set of options, that can be specified between the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{}]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We do not describe the details of those options here.
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J]]></span><it style="font-style: bold; color:green;">&#187;</it> can now be used to communicate with the Java slave as shown below:
<pre class="l42Big"><![CDATA[
MainAsk = (
  j = J.#$of()
  j.loadCode(fullName=S"foo.Bar1",code=S"""
    |package foo;
    |import is.L42.platformSpecific.javaEvents.Event;
    |public record Bar1(Event event){//class Bar1 will be instantiated by 42
    |  public Bar1{                  //and the Event parameter is provided
    |    event.registerAskEvent("BarAsk",(k,id,msg)->
    |      "any string computed in Java using "+id+" and "+msg);
    |    }
    |  }
    """)
  S.Opt text = j.askEvent(key=S"BarAsk", id=S"anId",msg=S"aMsg")
  {}:Test"OptOk"(actual=text, expected=S"""
    |["any string computed in Java using anId and aMsg"]
    """.trim())
  )
]]></pre>
This code asks the event <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["anId"]]></span><it style="font-style: bold; color:green;">&#187;</it> on the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarAsk"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The Java code registers the capacity of answering to the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarAsk"]]></span><it style="font-style: bold; color:green;">&#187;</it> and
computes an answer parameterized over <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[id]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[msg]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[askEvent]]></span><it style="font-style: bold; color:green;">&#187;</it> is synchronous: it will wait for Java to provide an answer as an optional string; optional since Java can return <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[null]]></span><it style="font-style: bold; color:green;">&#187;</it> as a result.

As you can see, you can embed arbitrary Java code in 42 and communicate back and forth serializing data and instructions as strings.

Synchronous communication is sometimes undesirable. 
For example, to use Java to open a GUI it would be better to have asynchronous communication and a queue of events.
You can do this with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J.Handler]]></span><it style="font-style: bold; color:green;">&#187;</it>, as shown below:
<pre class="l42Big"><![CDATA[
Model = Data:J.Handler:{
  var I count, mut J j
  @J.Handler mut method Void fromJavaToL42(S msg)=(
    this.count(\count+1\)
    Debug(S"pong received %msg with count=%this.count()")
    if this.count()<40I (
      this.#j().submitEvent(key=S"BarIn", id=S"ping", msg=S"the message %this.count()")
      whoops J.Fail
      )
    else this.#j().kill()
    )
  }
MainPingPong = (
  j=J.#$of()
  j.loadCode(fullName=S"foo.Bar2",code=S"""
    |package foo;
    |import is.L42.platformSpecific.javaEvents.Event;
    |public record Bar2(Event event){
    | public Bar2{
    |    event.registerEvent("BarIn","ping"(k,id,msg)->{
    |      System.out.println("Ping Event received "+id+" "+msg);
    |      event.submitEvent("BarOut","fromJavaToL42","pong");
    |      });
    |    event.registerEvent("Kill",(k,id,msg)->{
    |      System.out.println("Doing cleanup before slave JVM is killed");
    |      System.exit(0);
    |      });
    |    }
    |  }
    """)
  model=Model(count=0I, j=j)
  model.fromJavaToL42(msg=S"Initial message")
  keys=S.List[S"BarOut"]
  models=J.Handler.Map[key=S"BarOut" mutVal=model]
  for e in j(keys) ( e>>models )
  Debug(S"Completed")
  )
]]></pre>
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Model]]></span><it style="font-style: bold; color:green;">&#187;</it> handles the events inside of 42:
if Java send an event with id <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["fromJavaToL42"]]></span><it style="font-style: bold; color:green;">&#187;</it> then the method
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Model.fromJavaToL42(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it> will be called.
In turn, such method
sends to java the message 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["ping"]]></span><it style="font-style: bold; color:green;">&#187;</it> on channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut method J.submitEvent(key,id,msg)]]></span><it style="font-style: bold; color:green;">&#187;</it>
up to 40 times, and kills the slave JVM after that.

In <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MainPingPong]]></span><it style="font-style: bold; color:green;">&#187;</it> we initialize the slave JVM to respond to two channels:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Kill"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In our example Java will submit an asynchronous event to 42 as a response to
the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn":"ping"]]></span><it style="font-style: bold; color:green;">&#187;</it> event and will terminate the slave on any <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Kill"]]></span><it style="font-style: bold; color:green;">&#187;</it> event.
The slave should always terminate its JVM when receiving a kill, but can do any kind of clean-up before that.
After a JVM is terminated, it can be restarted by simply calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[J.loadCode(fullName,code)]]></span><it style="font-style: bold; color:green;">&#187;</it> again.

Finally, we set up the event loop:
An event loop will collect events from a list of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and dispatch them
to a map of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it>, mapping every key to a specific <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[model]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Note that both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it> are mutable objects. In this way we can dynamically
register and unregister keys/models by mutating <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[keys]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[models]]></span><it style="font-style: bold; color:green;">&#187;</it>.
If the JVM is killed or the list of keys becomes empty, the event loop <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for e in j(keys)]]></span><it style="font-style: bold; color:green;">&#187;</it> will terminate.
The operation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[e>>models]]></span><it style="font-style: bold; color:green;">&#187;</it> dispatches the event to the model.
<br/>
We need to use two different channels (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarIn"]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["BarOut"]]></span><it style="font-style: bold; color:green;">&#187;</it>) to distinguish if an event is should be handled by 42 or by Java.


</p><h2> (5/5) Object capabilities summary </h2> <p>
<ul><li>
While most languages run in a single process, 42 runs in a cluster of processes; this is needed so that the master process is protected from any slave process going into undefined behaviour.
This is the final piece of the puzzle allowing the correctness properties of 42 to be ensured in any circumstance.
</li><li>
To enable non deterministic behaviour we need to call those specially named <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#$]]></span><it style="font-style: bold; color:green;">&#187;</it> methods.
Since they can only be called in a few controlled places, we can control what parts of the code can perform non determinism by explicitly passing capability objects.
</li><li>
Capability objects are a very convenient centralized point of control to inject security or other kinds of restrictions.
</li></ul>

</p><h2> Digressions / Expansions </h2> <p>

</p><h2> Non deterministic errors </h2> <p>

When discussing errors, we did not mention how to handle errors happening in a non deterministic way; for example, how to recover when the execution run out of memory space.
In 42 this is modelled by non deterministic errors. They can only be caught in a main, in another capability method or in a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> method of a capability object. 
AdamsTowel offers a single non deterministic error: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[System.NonDeterministicError]]></span><it style="font-style: bold; color:green;">&#187;</it>. When a non deterministic error happens, we can recover it by catching an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[error System.NonDeterministicError]]></span><it style="font-style: bold; color:green;">&#187;</it>.

The code below shows how to cause a stack overflow and to recover from it.
<pre class="l42Big"><![CDATA[
Looping={
  class method Void loop() = this.loop()
  class method Void #$loopStop() = (
    Looping.loop()
    catch error System.NonDeterministicError e (
      Debug(S"This is printed")
      )
    Debug(S"And then this is printed")
    )
  }
Main1=Looping.#$loopStop()
]]></pre>

That is, to recover from a non deterministic error we need to satisfy both the requirements of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['#$']]></span><it style="font-style: bold; color:green;">&#187;</it> non determinism and of strong error safety.

</p><h2> Aborting wasteful cache eagers </h2> <p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@Cache.Eager]]></span><it style="font-style: bold; color:green;">&#187;</it> methods may return a cached result; such result is guaranteed to be the same that would be computed if we were to directly execute the method.
How does this work if the method is non terminating or simply outrageously slow?
Those eager cache methods will eagerly spend precious machine resources. If the results of those computations are ever needed by a main, the whole 42 process will get stuck waiting, as it would indeed happen if we were to directly execute the method. All good: in this case 42 correctly lifted the behavioural bug into caching.
However, if the result is never needed by a main, it would be nice to be able to stop those runaway pointless computations.
We can obtain this by calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.#$stopCacheEager()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
This works no matter if they are in loop, simply slow, or stuck waiting on another cache being slowly computed.
In some cases, we can even have multiple computations stuck waiting on each other in a circular fashion.
 </p><p id="Exercises"> </p><div style="break-after:page"></div><h1> Exercises </h1> <p>

A very large class of practically useful programs can be obtained
just by declaring
basic classes, collections
and simple Data classes.

Let's see some exercises and solutions 
to better understand what 42 code looks like.

</p><h2> (1/5) Max method </h2> <p>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MaxOfList]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the max from a list of numbers
</p><p>
Basic Solution: 
<pre class="l42Big"><![CDATA[
MaxOfList = {//static method pattern
  UndefinedOnEmpty = Message:{[Message.Guard]}
  //Max is undefined on empty lists.
  //Since there was no mention of preconditions, we should explicitly handle all the error cases as Guards
  class method
  Num (Num.List that) = {
    if that.isEmpty() ( error UndefinedOnEmpty"Max is undefined on empty lists" )
    //now that we know we can proceed: 
    var Num maxCandidate= that.left()
    //there is no such thing like a minimum Num, we need to select one element from the list.
    for n in that (
      //we could write 'that.withoutLeft()' to avoid checking on the first again
      if maxCandidate<n (maxCandidate:= n)
      //update the variable to keep track of the max so far.
      )
    return maxCandidate
    }
  }
]]></pre>

Solution using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
MaxOfList = {
  class method
  Num (Num.List that) =
    that.reduce()(
      for e in \vals() (
        if \acc < e \add(e) 
        )
      )
  }
]]></pre>
Where the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it>  will already throw a meaningful error in case of an empty list: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.OperationUndefinedOnEmpty]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Defining your own error may still produce more readable errors, so feel free to mix and match the two approaches as show in the next exercise:


</p><h2> (2/5) Merging and filtering </h2> <p>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MapText]]></span><it style="font-style: bold; color:green;">&#187;</it> producing a string from two lists of strings of the same length.

 For example
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MapText(keys=S.List[S"a";S"b";S"c"] vals=S.List[S"z";S"y";S"z"])]]></span><it style="font-style: bold; color:green;">&#187;</it>
should produce <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S"[a->z, b->y, c->z]"]]></span><it style="font-style: bold; color:green;">&#187;</it>
</p><p>
Solution: 
<pre class="l42Big"><![CDATA[
MapText = {
  UnequalSize = Message:{[Message.Guard]}
  class method
  S (S.List keys, S.List vals) = {
    if keys.size() !=  vals.size() error UnequalSize
      "keys= %keys.size(), values= %vals.size()" 
    //the former formatting allows us to keep a whole line for the error message
    res = S.List()(for k in keys, v in vals \add(S"%k->%v"))
    if res.isEmpty() return S"[]"
    text = res.reduce()(for s in \vals \add(\acc++S", %s"))
    return S"[%text]"
    }
  }
]]></pre>
Note how we write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(\acc++S", %s")]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\add(S"%\acc, %s")]]></span><it style="font-style: bold; color:green;">&#187;</it> since 
 string interpolation does not currently support the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it>.

<br/>
Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FilterUpTo{ class method S.List(S.List that, I size)}]]></span><it style="font-style: bold; color:green;">&#187;</it> filtering out from a list of strings the ones longer
than <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[FilterUpTo(S.List[S"a";S"ab";S"abc"] size=2I)==S.List[S"a";S"ab"]]]></span><it style="font-style: bold; color:green;">&#187;</it>
</p><p>
Precondition: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[size]]></span><it style="font-style: bold; color:green;">&#187;</it> is not negative
</p><p>
Solution: 
<pre class="l42Big"><![CDATA[
FilterUpTo = {
  class method
  S.List (S.List that, I size) = (
    X.Pre[size >= 0I]
    S.List()(for s in that if s.size()<= size \add(s))
    )
  }
]]></pre>
Again we see yet another way to handle errors; preconditions are appropriate when it is an observed  bug if the user calls it with wrong parameters.

</p><h2> (3/5) Read/Write files </h2> <p>

Write a static method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ReadSelf]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the content of the file where the current source code is located.
<br/>
<pre class="l42Big"><![CDATA[
FileSystem = Load:{reuse [L42.is/FileSystem]}

ReadSelf = {
  class method
  S (mut FileSystem that)[FileSystem.Fail] = 
    that.read(Url"This.L42")
  }
Test = {}:Test""(expected=ReadSelf(FileSystem.Real.#$of())
    actual=S"reuse [L42.is/AdamsTowel]%S.nl()MaxOfList = [###]end")
//end
]]></pre>

As you can see, In the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[actual]]></span><it style="font-style: bold; color:green;">&#187;</it> parameter of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Test]]></span><it style="font-style: bold; color:green;">&#187;</it> we can use the symbol
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["[###]"]]></span><it style="font-style: bold; color:green;">&#187;</it> to specify holes in the expected string.
This is very useful to make more resilient tests.

</p><h2> (4/5) Random mole (and how to divide you code in multiple files) </h2> <p>

Here we show a larger 42 example.
When writing large programs it is convenient to divide the source in multiple files.
In 42 this can be obtained with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{...}]]></span><it style="font-style: bold; color:green;">&#187;</it> symbol.
That is, if in a given file we write
<pre class="l42Big"><![CDATA[
A = /*..*/{...}/*..*/
]]></pre>
42 will search for a file called either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.L42]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A/This.L42]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Such file has to contain valid 42 code; such code is replaced for the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[...]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this way code can be divided
in multiple files spanning a hierarchy of folders.
</p><p>
More precisely, 
a 42 project must be a folder containing a file called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This.L42]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Folders can contain other files <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.L42]]></span><it style="font-style: bold; color:green;">&#187;</it> or folders containing other <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This.L42]]></span><it style="font-style: bold; color:green;">&#187;</it> and other files.
<br/>
The meaning of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[...]]></span><it style="font-style: bold; color:green;">&#187;</it> depend 
on both the location in the code and 
of the position of the current file in the file system.
To evaluate a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[...]]></span><it style="font-style: bold; color:green;">&#187;</it> 42 locates the nearest enclosing nested
library declaration, and we record its name (<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> in the example).
This identifies either a file or a folder.
If both or neither of these exist, there is an error.
<br/>
Note that the found <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[*.L42]]></span><it style="font-style: bold; color:green;">&#187;</it> file can contain more <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[...]]></span><it style="font-style: bold; color:green;">&#187;</it>, which will be
resolved relative to the file before importing it into the current scope.

</p><p>
We can now design a longer example, represent a piece of land as a 80*80 bi-dimensional map,
where every cell can be full of dirt (90%) or rock (10%).
Then a mole start from the left top corner and attempts to
digs through dirt randomly.
After 3000 steps the mole stops.
Define the opportune classes and write a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[randomDig]]></span><it style="font-style: bold; color:green;">&#187;</it>
method. 
</p><p>
To start, we define some auxiliary classes: 
<pre class="l42Big"><![CDATA[
//file This.L42
Point = Data:{...}
]]></pre>

<pre class="l42Big"><![CDATA[
//file Point.L42
I x, I y

@Cache.Now class method
Void invariant(I x, I y) = X.Guarded[
  x>=0I; x<80I;
  y>=0I; y<80I;
  ]

method This go(Direction that) = {
  return that.go(this)
  catch error X.Guarded _ return this
  }
  
method I index() = 
  (this.y()*80I)+this.x()
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> has an invariant ensuring that the coordinates are inside the 80*80 area.
We use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Guarded]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it> since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X.Guarded]]></span><it style="font-style: bold; color:green;">&#187;</it> implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Guard]]></span><it style="font-style: bold; color:green;">&#187;</it>, thus we can rely on such error to trigger predictably.
We do this in method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>, where we capture the invariant failure in case moving the point would push it outside of the boundary; in that case we keep the point in the original coordinates.

<pre class="l42Big"><![CDATA[
//file This.L42
Direction = Collection.Enum:{interface
  method Point go(Point that)
  Up={[This1] method go(that)=that.with(x=\x-1I)}
  Down={[This1]method go(that)=that.with(x=\x+1I)}
  Left={[This1]method go(that)=that.with(y=\y-1I)}
  Right={[This1]method go(that)=that.with(y=\y+1I)}
  }
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it> is an enumeration, and we leverage on dynamic dispatch to encode the behaviour of the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
Note how in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it> we explicitly declared the top level <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> and
we implemented the outer level <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This1]]></span><it style="font-style: bold; color:green;">&#187;</it> explicitly in all the cases.
Then we could implemented the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[go(that)]]></span><it style="font-style: bold; color:green;">&#187;</it> method without repeating the type signature.

<pre class="l42Big"><![CDATA[
//file This.L42
Cell = Collection.Enum:{
  method S symbol()
  Dirt={method S symbol()=S"#"}
  Rock={method S symbol()=S.percent()}
  Empty={method S symbol()=S" "}
  Mole={method S symbol()=S"M"}
  }
]]></pre>
Instead, while declaring <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cell]]></span><it style="font-style: bold; color:green;">&#187;</it> we omit the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[interface]]></span><it style="font-style: bold; color:green;">&#187;</it> keyword and the explicit implementation.
Then we had to repeat the type signature each time while implementing the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[symbol()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Both ways to declare enumerations work and produce the same result.

Should we used separate files for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Direction]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cell]]></span><it style="font-style: bold; color:green;">&#187;</it>?
Their code is quite short, so we chose not to.
If in the future we had many more kinds of Cells, we could move that code in its own file later.
<pre class="l42Big"><![CDATA[
//file This.L42
Land = Data:{...}
]]></pre>

<pre class="l42Big"><![CDATA[
//file Land.L42
[HasToS]
mut Math.Random rand
mut Cell.List cells

class method
mut Cell.List #default#cells(mut Math.Random rand) = Cell.List[](
  for i in Range(80I*80I) (
    if rand.nextInRange(0I to=10I)==0I \add(Cell.Rock())
    else \add(Cell.Dirt())
    )
  )
mut method 
Void set(Point that, Cell val) =
  this.#cells().set(that.index() val=val)

read method 
Cell val(Point that) =
  this.cells().val(that.index())    
  
mut method
Void randomDig() = (
  var current = Point(x=0I y=0I)
  for i in Range(3000I) (
    this.set(current,val=Cell.Empty())
    d = Direction.Vals().val(this.#rand().nextInRange(0I to=4I))
    newPoint = current.go(d) //no digging in rock
    if this.val(newPoint)!=Cell.Rock() ( current:=newPoint )
    )
  this.set(current,val=Cell.Mole()) //finally, the mole is where we ends up
  )

method toS() = (
  var res=S""
  for x in Range(80I) (
    res++=S.nl()//newline
    for y in Range(80I) res++=this.val(\(x=x,y=y)).symbol()
    )
  res++S.nl()
  )
//since we define 'toS()' explicitly, Data will leave it alone :)
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Land]]></span><it style="font-style: bold; color:green;">&#187;</it> has a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Math.Random rand]]></span><it style="font-style: bold; color:green;">&#187;</it> field and a 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List cells]]></span><it style="font-style: bold; color:green;">&#187;</it> field; a list of cells of size 80*80.
While we expect the user to provide the random object, we wish to provide a way to initialize the 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cells]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In 42, as for most languages, we could provide a default value for a field by writing
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List cells = Cell.List[](..)]]></span><it style="font-style: bold; color:green;">&#187;</it>, but in this case we need to use the provided random object
to complete the initialization, thus we use a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Cell.List #default#cells(mut Math.Random rand)]]></span><it style="font-style: bold; color:green;">&#187;</it>
instead.
As with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.Now]]></span><it style="font-style: bold; color:green;">&#187;</it>,
we take in input parameters with the same name of the fields we wish to use.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is going to rely on this method to initialize the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[cells]]></span><it style="font-style: bold; color:green;">&#187;</it> field.
This is actually a general pattern of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, allowing default values for any method.
<br/>
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[randomDig()]]></span><it style="font-style: bold; color:green;">&#187;</it> is straightforward.
<br/>
Note how we override <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[toS()]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of accepting the implementation provided by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>.

To use the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Land]]></span><it style="font-style: bold; color:green;">&#187;</it> class we can use the code below.
<pre class="l42Big"><![CDATA[
//file This.L42
MainMole = (
  land = Land(rand=\.#$random())
  land.randomDig()
  Debug(land)
  )
]]></pre>


</p><h2> (5/5) Examples summary </h2> <p>
<ul><li>
Always think about what can go wrong upfront
</li><li>
Many methods can be completed by first checking for 
errors/issues and then using a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it>, possibly inside a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reduce()]]></span><it style="font-style: bold; color:green;">&#187;</it> or a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Match]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</li><li>
Before heading into a problem,
spend some time to define your problem domain.
We dodged a lot of headaches by defining
points with invariants.
</li><li>
Well organized code, properly divided in files and folders is much  easier to navigate and maintain.
</li></ul>
 </p><p id="MetaprogrammingIntro"> </p><div style="break-after:page"></div><h1> Finally, Metaprogramming </h1> <p>

Metaprogramming is the most important feature of 42.
All the decorators that you have seen up to now are implemented with metaprogramming, 
which shows that 42 offers a good balance of freedom and safety.
</p><p>

The main idea of 42 metaprogramming is that only library literals can
be manipulated.
Metaprogramming is evaluated top down, most-nested first.
Once a library literal has a name, it can not be independently metaprogrammed; but only influenced
by metaprogramming over the library that contains it.

</p><p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait]]></span><it style="font-style: bold; color:green;">&#187;</it> is a decorator allowing to store code in a reusable format.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class]]></span><it style="font-style: bold; color:green;">&#187;</it> is a decorator that extracts the code from a trait. For example
<pre class="l42Big"><![CDATA[
TraitMsg = Trait:{
  class method S msg() = S"Hello world" 
  }
TraitPrint = Trait:{
  class method Void printMsg() = Debug(this.msg())
  class method S msg()
  }
TraitPrintMsg = TraitPrint:TraitMsg //TraitPrintMsg is another trait
ClassPrintMsg = Class:TraitPrintMsg //produces usable code
ClassPrintMsg = Class:TraitPrint:TraitMsg //equivalent
ClassPrintMsg = {//also equivalent
  class method Void printMsg() = Debug(this.msg())
  class method S msg() = S"Hello world" 
  }
Main0 = ClassPrintMsg.printMsg() //prints Hello world
//Main0 = TraitPrintMsg.printMsg() //does not compile
]]></pre>

In this code we show that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ClassPrintMsg]]></span><it style="font-style: bold; color:green;">&#187;</it> contains all the code of both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[TraitPrint]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[TraitMsg]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Note how the abstract <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class method S msg()]]></span><it style="font-style: bold; color:green;">&#187;</it> in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[TraitPrint]]></span><it style="font-style: bold; color:green;">&#187;</it> is merged with the corresponding implemented method in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[TraitMsg]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Traits allow us to merge code from different sources, as it happens with multiple inheritance.
However, traits are flattened: The code is actually copied in the result.

Traits are boxes containing the code and offering methods to manipulate such code.
A trait can be created by doing either <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait(theCode)]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait:theCode]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The trait object has a method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.code()]]></span><it style="font-style: bold; color:green;">&#187;</it> returning the contained code.
Trait content can be composed using the operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> (as shown above) or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For traits there is no difference in behaviour between <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it>, but the operator precedence and associativity is different.

</p><p>

Simply composing traits allows us to emulate a large chunk of the expressive power of conventional inheritance.
For example, in Java we may have an abstract class offering some implemented and some abstract methods.
Then multiple heir classes can extend such abstract class implementing those abstract methods.
The same scenario can be replicated with traits: a trait can offer some implemented and some abstract methods. Then multiple classes can be obtained composing that trait with some other code implementing those abstract methods.

<pre class="l42Big"><![CDATA[
A = Trait:{/*implemented and abstract methods here*/
  method S exampleMethod1()
  method S exampleMethod2() = this.exampleMethod1()
  }
B = Data:Class:A:{/*more code here, reusing the code of A*/
  method S exampleMethod1() = S"Hi"
  method S exampleMethod3() = this.exampleMethod2()
  }
]]></pre>

</p><h2> (2/5)Trait composition: methods </h2> <p>
Trait composition merges members with the same name. As shown above, this allows method composition.
Also nested classes can be merged in the same way: nested classes with the same name are recursively composed, as shown below:
<pre class="l42Big"><![CDATA[
T1 = 
  Trait({
    Foo = {
      method S hello()
      method S helloWorld() = this.hello()++S" World"
      }
    })
  +
  Trait({
    Foo = {
      method S hello() = S"Hi" 
      }
    })
//it is equivalent to
T1 = 
  Trait({
    Foo = {
      method S hello() = S"Hi" 
      method S helloWorld() = this.hello()++S" World"
      }
    })
]]></pre>

</p><h2> Fields? </h2> <p>
But what about fields? how are fields and constructors composed by traits?
The answer to this question is quite interesting:
In 42 there are no true fields or constructors; they are just abstract methods serving a specific role.

That is, the following code declares a usable <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> class:
<pre class="l42Big"><![CDATA[
TraitGeometryPoint = Trait:{
  Point = {
    read method Num x()
    mut method Void x(Num that)
    read method Num y()
    mut method Void y(Num that)
    class method mut This (Num x, Num y)
    method This double() = \(x=this.x()*2\, y=this.y()*2\)
    }
  }
Geometry1 = Class:TraitGeometryPoint //declaring class Geometry1
..
  imm p = Geometry1.Point(x=3\, y=4\)
  p2 = p.double()//example usage
]]></pre>
That is, any <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> no-arg abstract method can play the role of a getter for a correspondingly named field, and any abstract <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class]]></span><it style="font-style: bold; color:green;">&#187;</it> method can play the role of a factory, where the parameters are used to initialize the fields.
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> methods with one argument called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[that]]></span><it style="font-style: bold; color:green;">&#187;</it> can play the role of a setter.
Candidate getters and setters are connected with the parameters of candidate factories by name.
To allow for more then one getter/setter for each parameter, getters/setters names can also start with any number of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
We call those abstract methods <span style="color:#ff1111; font-weight: bold;"> Abstract State Operations </span>.
In Java and many other languages, a class is abstract if it has any abstract methods.
In 42, a class is coherent if its set of abstract state operations ensure 
that all the callable methods have a defined behaviour; this includes the initialization of all the usable getters. 
<br/>
In more detail, a class is coherent if:
<ul><li>
All candidate factories provide a value for all candidate getters, and all the types of those values
agree with the return type of the corresponding getters.
The parameter type of all candidate setters agrees with the return type of the corresponding getters.
</li><li>
Additionally, any non-class method can be abstract if none of the candidate factories return a value whose modifier allows to call such a method.
</li></ul>
In particular, this implies that if a class has no candidate factories, 
any non class method may be abstract, as shown below:
<pre class="l42Big"><![CDATA[
Foo = {
  class method Void bar()=Debug(S"coherent!") 
  method I answer(Time long)//abstract no problem!
  }
Main = Foo.bar()
]]></pre>

A main can call class methods only on coherent classes that only depend from other coherent classes, thus for example
<pre class="l42Big"><![CDATA[
Foo0 ={class method Void bar0()}
Foo = {class method Void bar()=Foo0.bar0() }
Main = Foo.bar()
]]></pre>
The decorators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> also checks for coherence: the following application of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class]]></span><it style="font-style: bold; color:green;">&#187;</it>
<pre class="l42Big"><![CDATA[
T1 = Trait:{class method Void bar()}
C1 = Class:T1
]]></pre>
would fail with the following message: <span style="color:#ff1111; font-weight: bold;"> The class is not coherent. Method bar() is not part of the abstract state </span>.
We can use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class.Relax]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Relax]]></span><it style="font-style: bold; color:green;">&#187;</it> to suppress this check when needed.
Indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myTrait.code()]]></span><it style="font-style: bold; color:green;">&#187;</it> behaves exactly as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class.Relax:myTrait]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
Earlier in this tutorial we have shown code like
<pre class="l42Big"><![CDATA[
Person = Data:{S name, var I age, mut S.List friends}
]]></pre>
In that code <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S name]]></span><it style="font-style: bold; color:green;">&#187;</it> looks like a conventional field declaration, but it is simply syntactic sugar for the following set of methods:

<pre class="l42Big"><![CDATA[
Person = Data:{
  read method S name()
  read method I age()
  mut method Void age(I that)
  read method read S.List friends()
  mut method mut S.List #friends()
  }
]]></pre>
Then, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> will discover that <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[name]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[age]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[friends]]></span><it style="font-style: bold; color:green;">&#187;</it> are good candidate fields and will add factories
<pre class="l42Big"><![CDATA[
class method mut This(S name, I age, mut S.List friends)
class method This #immK(S name, I age, S.List friends)
]]></pre>
and a lot of other utility methods.


</p><h2> (3/5)Nested Trait composition: a great expressive power. </h2> <p>

Composing traits with nested classes allows us to merge arbitrarily complex units of code.
In other languages this kind of flexibility requires complex patterns like dependency injection, as shown below:

<pre class="l42Big"><![CDATA[
TraitGeometryPoint = Trait:{/*Same as before*/}

TraitGeometryRectangle = Trait:{
  Point = {method Point double()} // Declare only the necessary methods
  Rectangle = {
    method Point upLeft()
    method Point downRight()
    method This This(Point upLeft, Point downRight)
    method This double() = \(
      this.upLeft().double()
      this.downRight().double()
      )
    }
  }
...
Geometry2 = Class:TraitGeometryPoint:TraitGeometryRectangle
]]></pre>
As you can see, we can define more code using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> while only repeating the needed dependencies.
We will use this idea in the following, more elaborated scenario:
Bob and Alice are making a video game. In particular, Alice is doing the code related to loading the game map from a file.

<pre class="l42Big"><![CDATA[
Game = { //example game code, NOT MODULARISED
  Item = {interface 
    Point point
    Item hit
    }
  Rock = {[Item]
    Num weight
    class method This(Point point, Num weight)
    method Item hit() = \(point=this.point(), weight=this.weight()/2\)
    }
  Wall = {[Item]
    Num height
    class method This(Point point, Num height)
    method Item hit() = Rock(point=this.point(), weight=..)
    }
  Map = {..//map implementation by Bob
    class method mut This empty() = ..
    read method Item val(Point that) = ..
    mut method Void set(Item that) = ..
    }
  class method Void #$run() = /*..*/this.load(..)/*..*/ //implemented by Bob
//------------------------------------//Anything under this line is implemented by Alice
  class method Map load(mut FS files, S fileName) = (//Alice writes load(_)
    map = Map.empty()
    ..//read from file and divide in lines,
    for line in lines ( this.load(map=map, line=line) )
    )
  class method Void load(mut Map map, S line) = (
    ..//example line: S"Rock 23 in 12, 7"
    if line.startsWith(S"Rock") (
      map.set(Rock(point=\(x=.., y=..), weight=..))
    if line.startsWith(S"Wall")) ..
    ..
    )
  }
Main = (.. Game.#$run() ..)
]]></pre>

As you can see from the non modularized code above, Alice code is tightly connected with Bob code:
She have to instantiate <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it> and all the kinds of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Item]]></span><it style="font-style: bold; color:green;">&#187;</it>s. In a language like Java, Alice would need to write her code after Bob have finished writing his, or they would have to agree to use dependency injection and all the related indirections.

Instead, in 42 they could simply factorize their code into two independent traits:

<pre class="l42Big"><![CDATA[
TraitBob = Trait:{ //all code is as before, but load is abstract
  Item = {interface 
    Point point
    Item hit
    }
  Rock = {[Item]
    Num weight
    class method This(Point point, Num weight)
    method Item hit() = \(point=this.point(), weight=this.weight()/2\)
    }
  Wall = {[Item]
    Num height
    class method This(Point point, Num height)
    method Item hit() = Rock(point=this.point(), weight=..)
    }
  Map = {..
    class method mut This empty() = ..
    read method Item val(Point that) = ..
    mut method Void set(Item that) = ..
    }
  class method Void #$run() = /*..*/this.load(..)/*..*/
  class method Map load(mut FS files, S fileName)
  }

TraitAlice = Trait:{//here we just repeat the used signatures
  Item = {interface }
  Rock = {[Item] class method This(Point point, Num weight)}
  Wall = {[Item] class method This(Point point, Num height)}
  Map  = { class method This empty(),  mut method Void set(Item that)}
  
  class method Map load(mut FS files, S fileName) = (//the actual Alice code
    map = Map.empty()   //is untouched; it can stay completely identical
    ..
    for line in lines ( this.load(map=map, line=line) )
    )
  class method Void load(mut Map map, S line) = (
    ..//example line: S"Rock 23 in 12, 7"
    if line.startsWith(S"Rock") (
      map.set(Rock(point=\(x=.., y=..), weight=..))
    if line.startsWith(S"Wall")) ..
    ..
    )
  }
Game=Class:TraitBob:TraitAlice
Main = (.. Game.#$run() ..)
]]></pre>

Now that the code of Alice and Bob are separated, they can test their code in isolation:

<pre class="l42Big"><![CDATA[
MockAlice = Class:TraitAlice:{
  Item = {interface, S info}
  Rock = {[Item]
    class method This(S info)
    class method This(Point point, Num weight) = 
      \(info=S"Rock: %point -> %weight")
    }
  Wall = /*..*/
  Map = {
    var S info
    class method mut This (S info)
    class method mut This empty() = \(S"")
    mut method Void set(Item i) = this.info(\info++i.info()++S.nl())
    }
  }
TestAlice = (
  files=FS.#$()
  {}:Test"justARock"(
    actual=MockAlice.load(files=files, fileName=S"justARock.txt")
    expected=S"""
      |Rock: Point(5,6) -> 35
      """)
  {}:Test"rockAndWall"(
    actual=MockAlice.load(files=files, fileName=S"rockAndWall.txt")
        expected=S"""
      |Rock: Point(x=5, y=6) -> 35
      |Wall: Point(x=1, y=2) -> 10
      """)
  ..//more tests here
  )
]]></pre>

</p><h2> (4/5)Typing considerations </h2> <p>

Object oriented programs often contain entangled and circular type definitions.
For example, strings <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S]]></span><it style="font-style: bold; color:green;">&#187;</it> have methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I size()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool isEmpty()]]></span><it style="font-style: bold; color:green;">&#187;</it>, while
both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool]]></span><it style="font-style: bold; color:green;">&#187;</it> offer a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S toS()]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
That is, while circular values are a double edged sword (useful but dangerous), circular/recursive types are unavoidable even in simple programs.
So, how do recursive types interact with metaprogramming?
Path names can only be used in execution when the corresponding nested class is fully typed,
thus the following example code would not work:
<pre class="l42Big"><![CDATA[
Foo = { class method Bar bar(Bar that)=that }
Foos = Collection.list(Foo)
Bar = { class method Foos foos(Foos that)=that }
]]></pre>
We can not start computing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Foos]]></span><it style="font-style: bold; color:green;">&#187;</it> since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Foo]]></span><it style="font-style: bold; color:green;">&#187;</it> depends from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bar]]></span><it style="font-style: bold; color:green;">&#187;</it>, that is defined later.
Swapping lines would not help, since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bar]]></span><it style="font-style: bold; color:green;">&#187;</it>, in turn, depends from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Foos]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Later we will learn how to overcome this issues and still generate code with the intended structure.
As shown below, library literals can instead be manipulated even if
they are not fully typed.
<pre class="l42Big"><![CDATA[
Person = Data:{S name, I age, Dog dog}
Dog = Data:{S name, Person owner}
]]></pre>
Here <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> can be computed even if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Dog]]></span><it style="font-style: bold; color:green;">&#187;</it> is still unavailable.
However, such a manipulation must happen in place: we can not use traits to reuse untyped code; that is, the following would not work:
<pre class="l42Big"><![CDATA[
TraitPerson = Trait:Data:{S name, I age, Dog dog}
Person = Class:TraitPerson //fails
Dog = Data:{S name, Person owner}
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[TraitPerson]]></span><it style="font-style: bold; color:green;">&#187;</it> can not be used before <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Dog]]></span><it style="font-style: bold; color:green;">&#187;</it> is defined.
</p><p>
This also allows us to avoid defining many redundant abstract methods.
Consider the following working code:
<pre class="l42Big"><![CDATA[
TraitPrintName = Trait:{
  class method S name()//abstract
  class method Void printName() = Debug(this.name())
  }
Bob = TraitPrintName:{
  class method S name() = S"Bob"
  class method Void printTwice() = (
    this.printName()
    this.printName()
    )
  }
Main = Bob.printTwice() //prints "Bob" twice
]]></pre>
This code is allowed even if <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bob]]></span><it style="font-style: bold; color:green;">&#187;</it> does not contain an abstract definition for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[printName()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This feature is often used by 42 programmers without even recognizing it, but it is brittle:
when method calls are chained (as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[a.b().c()]]></span><it style="font-style: bold; color:green;">&#187;</it>) or when binary operators or type inference are involved, the system needs to be able to guess the return type of those missing methods.

</p><h2> (5/5)Metaprogramming summary </h2> <p>
Here we have introduced the way that 42 handles metaprogramming and code reuse.
We focused on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Class]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Composing code with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it> we can partition our code-base in any way we need,
enabling simple and natural testing and code reuse patterns.
<br/>
When reusing code, we have to be mindful of missing types and missing methods. Structuring the code-base to avoid those issues will require some experience, and is indeed one of the hardest parts about writing complex 42 programs.

 </p><p id="Refactoring"> </p><div style="break-after:page"></div><h1> Traits and rename </h1> <p>

</p><h2> (1/5)An introduction to Programmatic Refactoring </h2> <p>

Traits allow us to programmatically rename methods and nested classes to other names.
Consider the following example code, defining trait <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Code1]]></span><it style="font-style: bold; color:green;">&#187;</it>, containing many nested classes:
the interface <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>, the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> implementing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>,
the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>, that is similar to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> but does not implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>
and finally the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[D]]></span><it style="font-style: bold; color:green;">&#187;</it> that uses both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
Code1 = Trait:{
  A = {interface,  method S m()}
  B = {[A],        method S m()=S"Hi"                    class method This()}
  C = {            method S m()=S" world"                class method This()}
  D = {            method S callBoth()=B().m()++C().m()  class method This()}
  }
Concrete1 = Class:Code1
Main1 = Debug(Concrete1.D().callBoth())
]]></pre>
We can extract the code into class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Concrete1]]></span><it style="font-style: bold; color:green;">&#187;</it>, and then use it to print 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Hi World"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We show below how we can use the operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_]]]></span><it style="font-style: bold; color:green;">&#187;</it> to programmatically rename elements of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Code1]]></span><it style="font-style: bold; color:green;">&#187;</it> while preserving the semantic:
<pre class="l42Big"><![CDATA[
Concrete2 = Class:Code1['A.m()=>'A.k()]
Concrete2 = {//equivalent to just writing the following directly:
  A = {interface,  method S k()}
  B = {[A],        method S k()=S"Hi"                    class method This()}
  C = {            method   m()=S" world"                class method This()}
  D = {            method S callBoth()=B().k()++C().m()  class method This()}
  }
Main2 = Debug(Concrete2.D().callBoth()) //still prints "Hi World"
]]></pre>
As you can see above, the mapping <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.m()=>'A.k()]]></span><it style="font-style: bold; color:green;">&#187;</it> renamed all
the occurrences of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.m()]]></span><it style="font-style: bold; color:green;">&#187;</it> into <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.k()]]></span><it style="font-style: bold; color:green;">&#187;</it>. This includes all the
declarations refining such method and all the usages of such method, either from the
static type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> or from any nested class implementing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>.
On the other side, you can see how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C().m()]]></span><it style="font-style: bold; color:green;">&#187;</it> was not renamed; the rename is type driven.
We can also rename multiple names at once; in this way we can even swap names:

<pre class="l42Big"><![CDATA[
Concrete2 = Class:Code1[
  'A.m()=>'A.k();
  'B.#apply() =>'B.of();
  'C=>'D;
  'D=>'C;
  ]
Concrete3 = {//equivalent to just writing the following directly:
  A = {interface,  method S k()}
  B = {[A],        method S k()=S"Hi"                       class method This of()}
  C = {            method S callBoth()=B.of().k()++D().m()  class method This()}
  D = {            method   m()=S" world"                   class method This()}
  }
Main3 = Debug(Concrete3.C().callBoth()) //still prints "Hi World"
]]></pre>
Note how the call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B()]]></span><it style="font-style: bold; color:green;">&#187;</it> is now replaced with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B.of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#apply()]]></span><it style="font-style: bold; color:green;">&#187;</it> is the extended name for the method with the empty name.
Also binary operator methods can be renamed by using their extended name;
The complete list of extended names for binary operators is discussed later, but you can also just use the overview feature to see them in any compiled class.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it> sign is a syntactic sugar similar to the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it>;
indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Foo.bar(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\"Foo.bar(x)"]]></span><it style="font-style: bold; color:green;">&#187;</it>; where the text after the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it> has strict syntactic restrictions, requiring it to be either a valid path (as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Beer.Foo]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This]]></span><it style="font-style: bold; color:green;">&#187;</it>, for example), a valid method selector, or 
a path followed by a method selector.
A method selector can also be followed by an argument name, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Foo.bar(x).x]]></span><it style="font-style: bold; color:green;">&#187;</it>
In 42 programmatic refactoring and other tasks requiring us to express paths and method selectors are very common, and writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myTrait['A=>'B]]]></span><it style="font-style: bold; color:green;">&#187;</it> is so much more convenient that writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myTrait[Name"A"=>Name"B"]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> (2/5) Programmatic Refactoring: all kinds of operations </h2> <p>
</p><h2> Single </h2> <p>
Programmatic refactoring of nested classes is transitive by default.
All the nested classes are going to be renamed together with the renamed root.
The code below shows how to specify a single rename instead:
<pre class="l42Big"><![CDATA[
MultiLevel = Trait:{
  A = {
    class method S hi() = S"hi"
    B = {class method S world() = S"world"}
    }
  C = {
    class method Void print() = Debug(A.hi()++D.space()++A.B.world())
    D = { class method S space() = S" " }
    }
  }
MultiConcrete = Class:MultiLevel[ single='C=>'K; 'A=>'D.H ]
MultiConcrete = {//equivalent to just writing the following directly:
  D = {
    H = {
      class method S hi() = S"hi"
      B = {class method S world() = S"world"}
      }
    }
  C = {
    D = { class method S space() = S" " }
    }
  K = {
    class method Void print() = Debug(D.H.hi()++C.D.space()++D.H.B.world())
    }
  }
Main4 = MultiConcrete.K.print() //still prints "hi world"
]]></pre>
As you can see, we did a single rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['C=>'K]]></span><it style="font-style: bold; color:green;">&#187;</it> and a transitive rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>'D.H]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since there were nested classes inside of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>, the single rename has left a shell of
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it> in place so that the nested <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C.D]]></span><it style="font-style: bold; color:green;">&#187;</it> could stay in position.
</p><p>

We can also rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['This]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example, with the code below we can make the original top level into a nested class, and the nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NewTop]]></span><it style="font-style: bold; color:green;">&#187;</it> into the top level:
<pre class="l42Big"><![CDATA[
Res=Class:Trait({
  method S originalTop()=S"originalTop"
  NewTop ={method S newTop()=S"newTop"}
  })[single='This=>'OriginalTop;single='NewTop=>'This]
]]></pre>
</p><p>
On the other side, self rename, for example <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['C=>'C]]></span><it style="font-style: bold; color:green;">&#187;</it> is usually an error, and thus it will raise an exception. However, we can silence such errors and turn self rename into a no-op by using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myCode[ignoreSelfRename='C=>'C]]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myCode[ignoreSelfRenameSingle='C=>'C]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> Hide </h2> <p>
The code below shows how to  hide a method or a class:
<pre class="l42Big"><![CDATA[
MultiConcrete2 = Class:MultiLevel[ hide='A; hide='D.space() ]
MultiConcrete2 = {//equivalent to just writing the following directly:
  A::3 = {
    class method S hi::4() = S"hi"
    B::5 = {class method S world::6() = S"world"}
    }
  C = {
    class method Void print() = Debug(A::3.hi::4()++D.space::7()++A:3.B::5.world::6())
    D = { class method S space::7() = S" " }
    }
  }
Main5 = MultiConcrete2.C.print() //still prints "hi world"
]]></pre>

Private members in 42 are obtained by relying on unique unguessable numbers:
These names do not show up in the outline and can not be invoked by user code; moreover those numbers are automatically renamed to avoid clashing during code composition; overall, those numbers are completely invisible for the user of the code.
While it is possible to manually use unique numbers, it is so much more convenient to write open code and then seal it later.

</p><h2> Clear </h2> <p>
Hidden code is still part of the result, but it is no more accessible.
Symmetrically, cleared code is not part of the result, but its entry point is still accessible, but abstract; clearing code allows us to override already defined behaviour, as shown below:

<pre class="l42Big"><![CDATA[
MultiConcrete3 = Class:MultiLevel[ clear='A ]:{
  A = {
    class method S hi() = S"hello"
    B = {class method S world() = S"42"}
    }
  }
Main6 = MultiConcrete3.C.print() //now prints "hello 42"
]]></pre>

Of course, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clearSingle='A]]></span><it style="font-style: bold; color:green;">&#187;</it> would clear only the nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> and not also <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.B]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Soft rename </h2> <p>
Clearing code allows us to override code by removing code.
This is different with respect to what happens with overriding in most languages, where the former code still exists and can be invoked, for example with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[super]]></span><it style="font-style: bold; color:green;">&#187;</it>.

In 42 we can easily emulate super by using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[->]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear]]></span><it style="font-style: bold; color:green;">&#187;</it>; the code below shows how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[->]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used on both methods and nested classes:
<pre class="l42Big"><![CDATA[
MultiConcrete4 = Class:MultiLevel[ 'A->'SuperA; 'C.D.space()->'C.D.superSpace() ]:{
  SuperA = { class method S hi() B={class method S world()}}
  A = {
    class method S hi() = S"[%SuperA.hi()]"
    B = {class method S world() = S"[%SuperA.B.world()]"}
    }
  C={
    D={
      class method S superSpace()
      class method S space()=S"[%this.superSpace()]"
      }
    }
  }
Main7 = MultiConcrete4.C.print() //now prints "[hi][ ][world]"
]]></pre>

Note how in this case we explicitly declare <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SuperA.hi()]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SuperA.B.world()]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C.D.superSpace()]]></span><it style="font-style: bold; color:green;">&#187;</it> in the composed code, even if they are already present in the 
result of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MultiLevel[ 'A->'SuperA; 'C.D.space()->'C.D.superSpace() ]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

We will soon show a way to avoid redeclaring them, but our experience programming in 42 suggests that when only a few methods are involved, the code is often more clear and easier to understand by redeclaring them.


</p><h2> Redirect </h2> <p>
Finally, programmatic refactoring allows us to rename a nested class into an externally declared class. We call this kind of rename <it style="font-style: italic;">redirect</it>.
This also provides a simple encoding for generics.
Consider the following code:
<pre class="l42Big"><![CDATA[
BoxTrait = Trait:Data:{
  T = {}//declaring a nested class called 'T'
  T that //a field of type T called 'that'
  }
NumBox = Class:BoxTrait['T=>Num]
Main = (
  myBox = NumBox(3Num)
  Debug(myBox)
  Num n = myBox.that()
  Debug(n)
  )
]]></pre>
Note how we wrote <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait['T=>Num]]]></span><it style="font-style: bold; color:green;">&#187;</it> and not <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait['T=>'Num]]]></span><it style="font-style: bold; color:green;">&#187;</it>:
In <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['T=>Num]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is the numeric class defined outside.
If we instead wrote <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['T=>'Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Num]]></span><it style="font-style: bold; color:green;">&#187;</it> would be the class nested inside <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait]]></span><it style="font-style: bold; color:green;">&#187;</it> and called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Generics classes are straightforward to implement with redirect, and indeed
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> uses the redirect operator internally.
</p><p>
We can redirect multiple nested classes at the same time, and we 
can put arbitrary constraints on the structural type of the destination types simply by specifying abstract methods and implemented interfaces.
Consider the following example:

<pre class="l42Big"><![CDATA[
Operation = Trait:{
  Elem = {Index myIndex}
  Index = {[HasToS]
    method Num eval(Elem that)
    }
  class method Elem best(Elem e1,Elem e2) = {
    res=e1.myIndex().eval(e2)>e2.myIndex().eval(e1)
    if res return e1
    return e2
    }
  }
Adventurer = Data:{S name, Num attack, Level level}
Level = Data:{
  Num exp
  S profession
  method Num eval(Adventurer that) = {..}
  }

DuelOperation = Class:Operation
  ['Elem.myIndex()=>'Elem.level()]
  ['Elem=>Adventurer;'Index=>Level]

Main= /*..*/ DuelOperation.best(e1=luke e2=gandalf) /*..*/
]]></pre>

Here we can define a generic <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Operation]]></span><it style="font-style: bold; color:green;">&#187;</it> working on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Elem]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Elements must have an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index myIndex()]]></span><it style="font-style: bold; color:green;">&#187;</it> method and indexes must
implement <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[HasToS]]></span><it style="font-style: bold; color:green;">&#187;</it> and offer a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[method Num eval(Elem that)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In a language like Java with F-Bound polymorphism, we would have been required to rely on a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[HasEval<Elem>]]></span><it style="font-style: bold; color:green;">&#187;</it> interface, while in 42 we can simply list the required operations.

Note how  before specifing the actual types for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Elem]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index]]></span><it style="font-style: bold; color:green;">&#187;</it> we can 
tweak the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Operation]]></span><it style="font-style: bold; color:green;">&#187;</it>, so that we can accept the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[level()]]></span><it style="font-style: bold; color:green;">&#187;</it> method instead of the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myIndex()]]></span><it style="font-style: bold; color:green;">&#187;</it> one.

Redirect is very powerful; checking also subtype relationships between redirected members, as shown below:
<pre class="l42Big"><![CDATA[
GeometryOperation = Trait:{
  Shape = {interface}
  Triangle = {[Shape]
    class method This (Point p1,Point p2,Point p3)
    }
  Line = {[Shape]
    Point p1, Point p2
    class method This (Point p1,Point p2)
    }
  class method Triangle reorganize(Line base,line extra) = 
    Triangle(p1=base.p1(), p2=base.p2(), p3=extra.p1())
  }
]]></pre>
Note how we can also require class methods on the redirect nested classes.
Overall, the whole philosophy of generic programming is different in 42:
instead of raising the level of abstraction and designing classes with type parameters,
we just design normal classes with nested classes, that just so happens to be fully abstract.
Those classes will represent external dependencies.
Then we can redirect those nested classes onto others.

</p><h2> (3/5) Different ways to supply missing dependencies </h2> <p>
As we have seen, in 42 it is convenient to write self contained code, where the dependencies 
can be specified as nested classes with abstract methods.
In 42 there are three different ways to satisfy those dependencies:
<ul>
<li>
Sum:
We can compose two traits with the operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it> to provide some of the missing method implementations.
</li>
</ul>
<pre class="l42Big"><![CDATA[
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  })
+Trait({
  A = Data:{ I a }
  })
]]></pre>
<ul>
<li>
Redirect:
We can rename a class to an external one 
</li>
</ul>
<pre class="l42Big"><![CDATA[
Foo = Data:{ I a }
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  })['A=>Foo]
]]></pre>
<ul>
<li>
Rename:
We can rename a member to another member in the same unit of code:
</li>
</ul>
<pre class="l42Big"><![CDATA[
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  C = Data:{ I a }
  })['C=>'A]
]]></pre>

This last solution works like the sum, but is happening inside of the a single unit of code.
If this inner sum is successful, it behaves as trait composition would.
There are a few corner cases where this inner sum will fail; they involve details of composing classes with interfaces and adding methods to interfaces.


</p><h2> (4/5) Introspection and Info </h2> <p>
It is also possible to programmatically query the code structure and make decisions about it.
For example
<pre class="l42Big"><![CDATA[
Larger = {class method Trait (Trait t1, Trait t2)={
  if t1.info().methods().size()>t2.info().methods().size() return t1
  return t2
  }}
MyClass = Class:Larger(t1=ATrait, t2=AnotherTrait)
]]></pre>

The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait.info()]]></span><it style="font-style: bold; color:green;">&#187;</it> returns an instance of class
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it>, offering methods to query all the visible information about
the trait code.
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> represents a nested class, and also contains 
classes representing other kinds of code elements:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Method]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Type]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Doc]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> contains a lot of useful methods.
Some of those methods query information about the class and how it is used in its code unit: for example the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[watched()]]></span><it style="font-style: bold; color:green;">&#187;</it> returns the list of types whose private members are used.
<br/>
A class that is watched can not be cleared. Indeed, all the possible errors of programmatic refactoring can be predicted by relying on the methods of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait({..}).info()]]></span><it style="font-style: bold; color:green;">&#187;</it> provides an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> for a library literal and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> provides an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> for a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class Any]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example, while 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait({ method S foo()}).info()]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to know about this <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[foo()]]></span><it style="font-style: bold; color:green;">&#187;</it> method, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info(S)]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to get information about the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.size()]]></span><it style="font-style: bold; color:green;">&#187;</it> method.


</p><h2> (5/5)Programmatic refactoring summary </h2> <p>
<ul><li>
Many kinds of operations can be performed on code
</li><li>
Rename, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>'B]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.foo()=>'A.bar()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
is used to rename all the occurrences of a member into another name or
form, for the sake of the final user.
</li><li>
Soft Rename, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A->'B]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.foo()->'A.bar()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
only moves the declaration. It leaves in place all the usages and an abstract version of the original signature.
</li><li>
Clear, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear='A]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear='A.foo()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
removes the implementation and all the private details of a member. It leaves in places all the usages and an abstract version of the original signature.
</li><li>
Hide, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hide='A]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hide='A.foo()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
renames all the occurrences of a member into an uniquely named one.
This new name is now completely invisible from outside the code unit.
</li><li>
Redirect, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
redirects all the usages of a nested class into an externally declared one.
The internal declaration is simply trashed.
</li></ul>
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> allows us to explore the shape of code as metadata.


 </p><p id="MoreDecorators"> </p><div style="break-after:page"></div><h1> More decorators </h1> <p>
Using the expressive power of programmatic refactoring many different decorators can be designed. Here we list and explain some of the most useful.

</p><h2> (1/5)Public </h2> <p>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator allows us to 
select certain members as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it>, and to hide all the others: for any nested class containing at least one <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> hides all the non <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> annotated members.
<br/>
Consider the following example:
<pre class="l42Big"><![CDATA[
MyProgram = Public:{
  Person = Data:{
    @Public var S name
    var I age
    @Public class method mut This (S name, I age)
    @Public mut method Void birthDay() = this.age(\age+1I)
    }
  Car = Data:{
    capsule Person driver
    @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
]]></pre>
Here we have a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> class with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[name]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[age]]></span><it style="font-style: bold; color:green;">&#187;</it>,
but we expose only the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[name]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We also expose the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[birthDay]]></span><it style="font-style: bold; color:green;">&#187;</it>, that can update the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[age]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> is generating a bunch of other methods, but we are not exposing them.
In order to make our <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> class usable, we need to at least expose a factory, as we do in line 5.
<br/>
On the other side, consider <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it>: since there is no <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it>, no members are hidden.
Also, note how the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it> invariant can refer to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person.age()]]></span><it style="font-style: bold; color:green;">&#187;</it> normally. This works because the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator is applied outside of both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it>. This is indeed a very common pattern: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> is often used high up in the nested tree, to allow for tightly connected classes to see each others private members when needed.
Using the outline IDE feature, we could see the following:
<pre class="l42Big"><![CDATA[
  MyProgram={
    Car={
      [This2.HasToS]
      class method mut This #apply(capsule This1.Person driver)=(..)
      method This2.Bool #bangequal0(This that)=(..)
      method This2.Bool #equalequal0(This that)=(..)
      class method This #immK(This1.Person driver)=(..)
      mut method capsule This capsuleClone()=(..)
      read method This immClone()=(..)
      read method read This1.Person driver()=(..)
      @This2.Cache.Now read method Void drivingAge()native{..}=(..)
      class method Void drivingAge(read This1.Person driver)=(..)
      method This norm()=(..)
      read method This2.Bool readEquality(read This that)=(..)
      read method This2.S toS()=(..)
      method This with(This1.Person driver)=(..)
      }
    Person={
      [This2.HasToS]
      @This2.Public class method mut This #apply(This2.S name, This2.I age)=(..)
      @This2.Public mut method Void birthDay()=(..)
      @This2.Public read method This2.S name()=(..)
      @This2.Public mut method Void name(This2.S that)=(..)
      read method This2.S toS()=(..)
      }
    }
]]></pre>
As you can see, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it> exposes all of the methods generated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, while <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> exposes only a minimal interface.
</p><p>
Alternativelly,
when we only wish to hide a few specific methods,
we could just specify the private members. To this aim, we need to specify in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> the path to use to indicate privateness. We could for example use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[X]]></span><it style="font-style: bold; color:green;">&#187;</it>, that loosely speaking represents a form of denial:

<pre class="l42Big"><![CDATA[
MyProgram = Public(private=\(X)):{
  Person = Data:{ /*..as before..*/}
  Car = Data:{
    capsule Person driver
    @X @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
]]></pre>
The code above hides the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it> invariant; this of course means that the invariant is still enforced, but methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[drivingAge()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[drivingAge(driver)]]></span><it style="font-style: bold; color:green;">&#187;</it> are not polluting the interface of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Car]]></span><it style="font-style: bold; color:green;">&#187;</it> any more.
</p><p>
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> is closing all the nested classes;
this means that the fields and constructors are not any more abstract methods but implemented methods delegating  to hidden ones.
A sealed class encapsulates its state, but can be reused in less flexible ways: the code of two sealed classes can not be merged with trait operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> (2/5)Organize </h2> <p>

With metaprogramming, often we have to create code in a certain order,
and this order may be in contrast with the final structure we want to create.
For example, we may want to have an interface whose nested classes implements such interface.
However, the following code:
<pre class="l42Big"><![CDATA[
I = {interface
  method Void foo()
  A= Data:{[I] foo()=void}
  }
]]></pre>
Would not work: we can not apply Data on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[{[I] foo()=void}]]></span><it style="font-style: bold; color:green;">&#187;</it> since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[I]]></span><it style="font-style: bold; color:green;">&#187;</it> it is not compiled yet.

We could use rename and write
<pre class="l42Big"><![CDATA[
I = Class:Trait({
  Top = {interface method Void foo() }
  A= Data:{[Top] foo()=void}
  })['Top=>'This]
]]></pre>
That is, first we create a bunch of nested classes, and then we organize the result by renaming to obtain the desired shape.
This common pattern is automated by the decorator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it>
performing a standard pattern of renames:
<br/>
Names containing the special <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[$]]></span><it style="font-style: bold; color:green;">&#187;</it> character are renamed in names where <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[$]]></span><it style="font-style: bold; color:green;">&#187;</it> is replaced with a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.]]></span><it style="font-style: bold; color:green;">&#187;</it> or just removed; for example <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A$B$C]]></span><it style="font-style: bold; color:green;">&#187;</it> is renamed in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.B.C]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A$]]></span><it style="font-style: bold; color:green;">&#187;</it> is renamed in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[$]]></span><it style="font-style: bold; color:green;">&#187;</it> is renamed into <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Thus, we could rewrite the code above as
<pre class="l42Big"><![CDATA[
I = Organize:{
  $ = {interface method Void foo() }
  A= Data:{[$] foo()=void}
  }
]]></pre>
</p><p>

In metaprogramming systems, code generation needs to proceed in a specific order. This sometimes creates difficoult situations.
For example, the following naive implementation of a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> with a map of friends to locations would not work:

<pre class="l42Big"><![CDATA[
Point = Data:{ Num x, Num y }
Person = Data:{ Map friends }
Map = Collection.map(key=Person, val=Point)
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it> can not be generated, since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> is untypable until <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it> is generated.
<br/>
We can circumvent
those limitations with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> by writing:
<pre class="l42Big"><![CDATA[
MyCode = Organize:{
  Point = Data:{ Num x, Num y }
  Person$ = {}
  Map = Collection.map(key=Person$, val=Point)
  Person = Data:{ Map friends }
  }
]]></pre>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> is also very useful to avoid redeclaring 
abstract methods when extending code.
This sometimes requires <it style="font-style: italic;">late typing</it>, usually by introducing an extra nested class that will only be used
as a dependency.

One such case happened while designing a little 42 videogame; where we encountered the setting below:
We have <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NPC]]></span><it style="font-style: bold; color:green;">&#187;</it>s following each other in a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Each <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NPC]]></span><it style="font-style: bold; color:green;">&#187;</it> knows about the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it>, the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it> values are <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NPC]]></span><it style="font-style: bold; color:green;">&#187;</it> objects.
Moreover, we do not just reuse a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.map]]></span><it style="font-style: bold; color:green;">&#187;</it> but we add new operations to it: the map is going to have specialized location aware operations.


<pre class="l42Big"><![CDATA[
Point = Data:{I x, I y}
Game = Organize:{
  NPC$ = {}
  Map$ = Collection.map(key=Point, val=NPC$)
  NPC = Data:{
    var Point location
    var I lifePoints
    var mut This target
    mut method Void step(mut Map$ map) = /*lots of code*/
    }
  Map = {
    mut method Void add(mut NPC that) = this.#put(key=that.location(), val=that)
    mut method Void remove(mut NPC that) = this.remove(key=that.location())
    mut method Void move(mut NPC that,Point to) = (
      this.remove(that)
      that.location(to)
      this.add(that)
      )
    mut method mut NPC get(Point that) =
      (this<:mut @Late Map$).#val(key=that).#val()
    mut method Void stepAll() =
      for (mut val) in this<:mut Map$
        (val<:mut NPC).step(map=this)
    }
  }
Late = {}
]]></pre>
The former code declares both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NPC]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NPC$]]></span><it style="font-style: bold; color:green;">&#187;</it>, and both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>.
They will be merged by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> but are still separated inside the code library, before <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> can act.
This is relevant when type inference is required.
For example, method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map.get(that)]]></span><it style="font-style: bold; color:green;">&#187;</it>
can not be simply implemented as
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.#val(key=that).#val()]]></span><it style="font-style: bold; color:green;">&#187;</it>
since there is no method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#val(key)]]></span><it style="font-style: bold; color:green;">&#187;</it> in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it>; such method is presented in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The solution is to add an up-cast to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>.
However, if this code was typed before <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> could
run, such a cast would not typecheck, since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map$]]></span><it style="font-style: bold; color:green;">&#187;</it> is not <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We can easly delay the type checking by adding an annotation:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this<:mut @Late Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>
casts <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this]]></span><it style="font-style: bold; color:green;">&#187;</it> to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut Map$]]></span><it style="font-style: bold; color:green;">&#187;</it> only when also nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Late]]></span><it style="font-style: bold; color:green;">&#187;</it> can be typed. Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Late]]></span><it style="font-style: bold; color:green;">&#187;</it> is declared after <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Game]]></span><it style="font-style: bold; color:green;">&#187;</it>, this is happening after <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it> has been applied.
Alternatively, we could use a local variable declaration and write the following:
<pre class="l42Big"><![CDATA[
mut method mut NPC get(Point that) = (
  mut @Late Map$ self=this
  self.#val(key=that).#val()
  )
]]></pre>
<br/>
Also method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[stepAll()]]></span><it style="font-style: bold; color:green;">&#187;</it> requires upcasting; however we do not need to repeat the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Late]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation since type dependencies are class-wide: a single <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Late]]></span><it style="font-style: bold; color:green;">&#187;</it> annotation anywhere in any method covers all the methods of the same class (but not the methods in nested classes).

Note that this approach does not rely on any dynamic checks; the 42 upcast operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[<:]]></span><it style="font-style: bold; color:green;">&#187;</it> is only guiding the type system, and even if the typing happens later, it will happen before the code is ready for execution.

Instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Late]]></span><it style="font-style: bold; color:green;">&#187;</it> we could rely on the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Game]]></span><it style="font-style: bold; color:green;">&#187;</it> itself, and
write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this<:mut @Game Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>.
If we want to make what is happening more explicit, we could even get creative and write <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this<:mut @Deploy{after @Game} Map$]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> (3/5)Data.** </h2> <p>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator contains many useful nested classes, that can be used as independent decorators.

</p><h2> Data.AddList, Data.AddOpt, Data.AddSet </h2> <p>
Decorators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddList]]></span><it style="font-style: bold; color:green;">&#187;</it>, allows us to add a
nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[List]]></span><it style="font-style: bold; color:green;">&#187;</it> working as a list of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This]]></span><it style="font-style: bold; color:green;">&#187;</it>.
 <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddOpt]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddSet]]></span><it style="font-style: bold; color:green;">&#187;</it> work similarly, but for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Opt]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Set]]></span><it style="font-style: bold; color:green;">&#187;</it>.
That is, to define a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> supporting both lists of points and sets of points we can simply write:
<pre class="l42Big"><![CDATA[
Point = Data:Data.AddList:Data.AddSet:{
  I x, I y
  }
..
ps = Point.List[\(x=3I,y=4I);\(x=5I,y=6I);]
]]></pre>
Note that the order of application of the above decorators is not important.

</p><h2> Data.AddConstructors </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddConstructors]]></span><it style="font-style: bold; color:green;">&#187;</it> applies a heuristic to decide what are the field of a class and add two constructors:
The first is called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#immK]]></span><it style="font-style: bold; color:green;">&#187;</it> and the second has the empty name; also known as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#apply]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#immK]]></span><it style="font-style: bold; color:green;">&#187;</it> simply takes all fields as immutable and produces an immutable result.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#apply]]></span><it style="font-style: bold; color:green;">&#187;</it> takes the most general type for the fields and produces a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[mut]]></span><it style="font-style: bold; color:green;">&#187;</it> result if class instances are mutable, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> otherwise.
The most general type for fields may be <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd imm]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd mut]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We have not seen <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd]]></span><it style="font-style: bold; color:green;">&#187;</it> types yet in this guide; they are useful for circular initialization. For example 
<pre class="l42Big"><![CDATA[
Person = Data:{S name, Person bestFriend}
..
fred = Person(name='Fred, bestFriend=barney)
barney = Person(name='Barney, bestFriend=fred)
]]></pre>
This code works in 42 and creates two circularly connected deeply immutable objects.
Forward types can also be used as parameters in regular methods, and the type system will check that their values can not be directly accessed but only passed around until they reach an abstract factory method.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddConstructors]]></span><it style="font-style: bold; color:green;">&#187;</it> takes two parameters:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool noFwd]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> choses the nested class to influence, and it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name"This"]]></span><it style="font-style: bold; color:green;">&#187;</it> by default.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool noFwd]]></span><it style="font-style: bold; color:green;">&#187;</it> is false by default, and 
prevents <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd imm]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[fwd mut]]></span><it style="font-style: bold; color:green;">&#187;</it> constructors when true.

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> can also specify an alternative name for the empty name constructor and the field names and order.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddConstructors]]></span><it style="font-style: bold; color:green;">&#187;</it> can also be built as an alphanumeric to simply initialize the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> parameter.
Also <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> can be built as an alphanumeric and it will internally propagate that parameter
to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.AddConstructors]]></span><it style="font-style: bold; color:green;">&#187;</it>.
The code below provides good examples:
<pre class="l42Big"><![CDATA[
Data:{ Num y, Num x } //no explict constructor, #apply(y,x) is inferred
Data"(x,y)":{ Num y, Num x } //#apply(x,y) is explicitly provided
Data.AddConstructors"(x,y)":{ Num y, Num x } //to add only the constructors
Data"of(x,y)":{ Num y, Num x } //of(x,y) explicitly provided
Data"B(x,y)":{ B={ Num y, Num x } } //The nested B is completed, constructor provided
Data"B.of(x,y)":{ B={ Num y, Num x } } //The nested B is completed, constructor provided
Data"B":{ B={ Num y, Num x } } //The nested B is completed, constructor inferred
Data.Relax"(x,y)":{ Num x, Num y  method Num foo() } //ensures 'foo' is not a field

]]></pre>
Passing the constructor parameter names explicitly is very useful in case we want to
 reorganize the order of the fields or explicitly exclude some abstract method 
that would be inferred to be a field otherwise.

</p><h2> Data.Seal </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal]]></span><it style="font-style: bold; color:green;">&#187;</it> also takes two parameters:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool autoNorm]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name that]]></span><it style="font-style: bold; color:green;">&#187;</it> chooses the nested class to influence, and it is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Name"This"]]></span><it style="font-style: bold; color:green;">&#187;</it> by default.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool autoNorm]]></span><it style="font-style: bold; color:green;">&#187;</it> is false by default, and if it is true attempts to use an already existent <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[norm()]]></span><it style="font-style: bold; color:green;">&#187;</it> method to only expose normalized values out.
It only works if class instances are immutable
and fails if any constructor parameter is forward.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal]]></span><it style="font-style: bold; color:green;">&#187;</it> is the part of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> processing and activating of all the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Cache.**]]></span><it style="font-style: bold; color:green;">&#187;</it> annotations.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal]]></span><it style="font-style: bold; color:green;">&#187;</it> implements all of the abstract state operations by delegating to an equivalent private method.
The class is then <it style="font-style: italic;">sealed</it>. 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal.all(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> is a convenient class method that applies <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal]]></span><it style="font-style: bold; color:green;">&#187;</it> on all the nested classes in a library literal.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it> uses <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Seal.all(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> internally.
As discussed for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Public]]></span><it style="font-style: bold; color:green;">&#187;</it>, code composition of sealed classes is less flexible since the state is now set in stone.

</p><h2> Data.Wither </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Wither]]></span><it style="font-style: bold; color:green;">&#187;</it> takes an open class and adds 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[with(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> methods; one for each field.
Those methods create a new object calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#immK]]></span><it style="font-style: bold; color:green;">&#187;</it>, where all the fields are the same, except for the one provided as a parameter.
For example, in the usual iconic <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point]]></span><it style="font-style: bold; color:green;">&#187;</it> example, we could write 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point(x=3I,y=4I).with(x=5I)]]></span><it style="font-style: bold; color:green;">&#187;</it>
to get <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Point(x=5I,y=4I)]]></span><it style="font-style: bold; color:green;">&#187;</it>
Note that this generates only the withers to update a single parameter at a time.

</p><h2> Data.Defaults </h2> <p>

In 42, methods are distinguished by their full selector, not their name; this is particularly convenient to encode default arguments, so that calling a method without mentioning a parameter will be equivalent to passing a default value to it.
This can be done by hand; as shown in the example below:
<pre class="l42Big"><![CDATA[
Point = Data:{
  I x, I y
  class method This () = \(x=0I,y=0I)
  method This moveUp(I that) = this.with(x=\x+that)
  method This moveUp() = this.moveUp(1I)
  }
]]></pre>
The decorator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Defaults]]></span><it style="font-style: bold; color:green;">&#187;</it>
allows us to generate those delegator methods more easily.
The code above could equivalently be rewritten as follows
<pre class="l42Big"><![CDATA[
Point = Data:{
  I x=0I, I y=0I
  method This moveUp(I that) = this.with(x=\x+that)
  method I #default#moveUp#that() = 1I
  }
]]></pre>
Methods starting with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it> are recognized by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Defaults]]></span><it style="font-style: bold; color:green;">&#187;</it> and used to create delegators. Moreover, in the same way fields are expanded into methods, the expression associated with the field is expanded in a no-arg <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
Manually defined <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it> methods can also take parameters; they must have the same name and type of parameters specified before the current parameter in the original method.
<br/>
In more detail: for every method where at least one <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it> method is recognized, another method will be generated. 
</p><p>
This generate method will not have any of the parameter with a recognized <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it>; it will call those <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#default#]]></span><it style="font-style: bold; color:green;">&#187;</it> methods to produce the needed values and delegates to the original method.

</p><h2> Data.Relax </h2> <p>

<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data.Relax]]></span><it style="font-style: bold; color:green;">&#187;</it>
works exactly like <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it>, 
but does not call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This.checkCoherent(..)]]></span><it style="font-style: bold; color:green;">&#187;</it>
on the result.

</p><h2> Data traits </h2> <p>

Finally, the following methods return traits
with one operation each, as obvious from their name:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addHasToS()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addEqOp()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addReadEqOp()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addNEqOp()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addCapsuleClone()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addImmClone()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addImmNorm()]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Data as a combination of decorators </h2> <p>

In the end, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> just composes all of those decorators and traits together as follows:
<pre class="l42Big"><![CDATA[
method Trait :(Trait that)[Data$Fail]=(
  name=this.that()
  cs=Name(string=name.path())
  autoNorm=this.autoNorm()
  var Trait acc=that
  acc:=this.optionallyApply(This.addHasToS(), acc=acc)
  acc:=this.optionallyApply(This.addEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addReadEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addNEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addCapsuleClone(), acc=acc)
  acc:=this.optionallyApply(This.addImmClone(), acc=acc)
  acc:=this.optionallyApply(This.addImmNorm(), acc=acc)  
  acc:=AddConstructors(name,noFwd=autoNorm):acc
  acc:=Wither(cs):acc
  acc:=Defaults(cs):acc
  acc:=Seal(cs,autoNorm=autoNorm):acc
  if this.check() (This.checkCoherent(acc.code()))
  acc
  )  
]]></pre> 
Where <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[optionallyApply(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> applies the trait in the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[name]]></span><it style="font-style: bold; color:green;">&#187;</it> position only if this causes no error. In this way if a method with the same name was already defined, the operation is simply skipped.

</p><h2> (4/5)Decorator </h2> <p>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Decorator]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator simplifies  creating new decorators.
for example, for a variant of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> that always normalize, we could do as follows, where we simply specify a method from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait]]></span><it style="font-style: bold; color:green;">&#187;</it> into <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait]]></span><it style="font-style: bold; color:green;">&#187;</it> that can throw any kind of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Message.Guard]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Value = Decorator:{
  method Trait(Trait trait)[Message.Guard] =
    Data('This,autoNorm=Bool.true()):trait
  }
]]></pre>
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Decorator]]></span><it style="font-style: bold; color:green;">&#187;</it> decorator will then use our code to create a decorator.
It will provide the following:
<pre class="l42Big"><![CDATA[
class method This #apply() //no-arg factory
method Library #colon0(Library lib)[This.Fail] //decorator for Library
method This1.Trait #colon0(This1.Trait trait)[This.Fail]//decorator for Trait
ClassOperators={..}//support for 'Value:..'
//instead of requiring 'Value():..'
Fail={[Message.Guard]..}//dedicated exception type
]]></pre>
We can also define parameters in our decorator, but we need to ensure the object could be created with the unnamed no-arg factory.

For example,
to add to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Value]]></span><it style="font-style: bold; color:green;">&#187;</it> the option of acting in an arbitrary nested class of the input,
 we could write:
<pre class="l42Big"><![CDATA[
Value = Decorator:Data:{
  Name that=Name"This"
  method Trait(Trait trait)[Message.Guard] =
    Data(this.that(),autoNorm=Bool.true()):trait
  }
]]></pre>
</p><p>
We can produce very liberal variations of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Data]]></span><it style="font-style: bold; color:green;">&#187;</it> by simply re-implementing the method that composes all the individual decorators and traits.
For example, if we wanted a variation of data that does not generate the withers, we could just write:
<pre class="l42Big"><![CDATA[
DataNoWither = Decorator:Data:{
  Name that=Name"This"
  Bool autoNorm=Bool.false()
  Bool relax=Bool.false()

  method Trait(Trait trait)[Message.Guard] = (
    name=this.that()
    autoNorm=this.autoNorm()
    data = Data(name,autoNorm=autoNorm)
    var Trait acc=trait
    acc:=data.optionallyApply(Data.addHasToS(), acc=acc)
    acc:=data.optionallyApply(Data.addEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addReadEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addNEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addCapsuleClone(), acc=acc)
    acc:=data.optionallyApply(Data.addImmClone(), acc=acc)
    acc:=data.optionallyApply(Data.addImmNorm(), acc=acc)  
    acc:=Data.AddConstructors(name,noFwd=autoNorm):acc
    //acc:=Data.Wither(name):acc//for example, we can just skip this line
    acc:=Data.Defaults(name):acc
    acc:=Data.Seal(name,autoNorm=autoNorm):acc
    if !this.relax() (Data.checkCoherent(acc.code()))
    acc
    )
  }
]]></pre>
As you can see, with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Decorator]]></span><it style="font-style: bold; color:green;">&#187;</it> we can easy tweak any existing decorator and compose them into new ones.

Another interesting example is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.Alphanumeric]]></span><it style="font-style: bold; color:green;">&#187;</it>;
it is present in AdamsTowel, but it is quite easy to redefine:
<pre class="l42Big"><![CDATA[
Alphanumeric = Decorator:{
  AlphanumericTrait = Trait:{[HasToS]
    S that
    method toS()=this.that()
    @Cache.Call class method This #from(S.StringBuilder stringLiteral) = 
      this(string=stringLiteral.toS())
    class method This (S string)
    }
  method Trait(Trait trait)[Message.Guard] = 
    Data('This,autoNorm=Bool.true()):AlphanumericTrait():trait
  }
]]></pre>
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Enum]]></span><it style="font-style: bold; color:green;">&#187;</it> is a much more challenging decorator
to define, but we have finally explored all the needed features. 
As a reminder, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection.Enum]]></span><it style="font-style: bold; color:green;">&#187;</it>
generates one enumeration element for any nested class. Thus, for example
<pre class="l42Big"><![CDATA[
Directions = Collections.Enum:{
  Left={}, Top={}, Right={}, Bottom={}}
]]></pre>
would turn the top level nested class into an interface and would enrich those 4 nested classes so that they implement <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This1]]></span><it style="font-style: bold; color:green;">&#187;</it> and support equality.
Moreover, a nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals]]></span><it style="font-style: bold; color:green;">&#187;</it> is added allowing us to list all the elements of the enumeration, and to map them from string.

We will now see how to encode such a complex behaviour.
<pre class="l42Big"><![CDATA[
Enum = Decorator:{
  //we start with 3 composable units of code
  TraitEnumBase = Trait:{...}//the starting point

  TraitEnumStep = Trait:{...}//the inductive step.

  TraitCacheVals = Organize:Trait:{...}//the final touch

  method Trait(Trait trait)[Message.Guard] = (
    var res = TraitEnumBase()  //we start from the TraitEnumBase code
    for (nameFromRoot) in trait.info().nesteds() (  //for all the names of all the nesteds:
      base = res['Vals.next()=>'Vals.prev()]  //res.Vals.next is renamed into .prev
      step = TraitEnumStep['E=>nameFromRoot]  //set the current TraitEnumStep name
      res := (step+base)[hide='Vals.prev()]  //the new candidate result composes step and base
      //res.Vals.prev is hidden, so that the next iteration we can rename next onto prev
      )
    res := (res+TraitCacheVals)[hide='Vals.next()]  //res.Vals.next connects the
    //inductive step with the result, and can then be hidden
    (res+trait)[hide='sealed()]  //finally, we compose what we created with
    //any extra code that the user provided, and we seal the top level interface
    )
  }
]]></pre>
The general pattern shown above is quite common when building complex decorators:
Start from some base code.
Iterate on a number of steps depending on the input trait; for each step combine the base code with code representing this extra step.
At the end of each step apply some renaming and hiding so that the resulting code has the same structural shape of the base code.
Finally, compose the result with the original user input and some more code providing a better user API.
<br/>
For <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Enum]]></span><it style="font-style: bold; color:green;">&#187;</it>, the base code is as follow:
<pre class="l42Big"><![CDATA[
TraitEnumBase = Trait:{
  List = {class method mut This()}
  Vals = { class method List next() = List() }
  }
]]></pre>
We have a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[List]]></span><it style="font-style: bold; color:green;">&#187;</it> nested, that will be the list type returned by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[List]]></span><it style="font-style: bold; color:green;">&#187;</it> we only declare the abstract methods used in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals.next()]]></span><it style="font-style: bold; color:green;">&#187;</it>.

The inductive code is much more interesting:
we declare the top level as an interface, with a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[sealed()]]></span><it style="font-style: bold; color:green;">&#187;</it> method. This is the device to finally seal the hierarchy, so that the enumeration only has a fixed set of options.
The enumeration offers the three methods that are usually provided by classes supporting equality: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[readEquality]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[==]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[!=]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[E]]></span><it style="font-style: bold; color:green;">&#187;</it> represents an arbitrary element of our enumeration, and provides a standard implementation for those methods.
It is a class with sealed state and no fields, thus 42 will implicitly use the normalized value for its single instance.
This means that the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[System.immClone(this)]]></span><it style="font-style: bold; color:green;">&#187;</it> will simply convert the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[read]]></span><it style="font-style: bold; color:green;">&#187;</it> reference to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[imm]]></span><it style="font-style: bold; color:green;">&#187;</it> without the need of any expensive computation.
<pre class="l42Big"><![CDATA[
TraitEnumStep = Trait:{interface
  class method Void sealed()
  read method Bool readEquality(read This that)
  method Bool ==(This that)
  method Bool !=(This that)
  E = {[This1,HasToS]
    class method This of::0()
    class method This() = this.of::0()
    class method Void sealed() = void
    method readEquality(that) = 
      System.immEquality(System.immClone(this) and=System.immClone(that))
    method ==(that) = this.readEquality(that)
    method !=(that) = !this.readEquality(that)
    method toS() = Info(This).outerName().toS()
    }
  List = { method This withAlsoRight(This1 that) }
  Vals = {
    class method List prev()
    class method List next() = this.prev().withAlsoRight(E())
    }
  }
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[List]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals]]></span><it style="font-style: bold; color:green;">&#187;</it> are now playing the inductive game of growing a list.
The base code <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[next()]]></span><it style="font-style: bold; color:green;">&#187;</it> starts with an empty list, and any base case will append to the right the instance of the current <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[E]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
Finally, to provide a good and efficient API,
we cache <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals()]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Vals.map()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This is also the place where we provide an actual implementation for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[List]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Map]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
TraitCacheVals = Organize:Trait:{
  $ = {interface[HasToS],    read method Bool readEquality(read This that) }
  List = Collection.list($)
  Map = Collection.map(key=S val=$)
  Vals = Data.Relax:{
    class method List next()
    @Cache.Lazy class method List () = this.next()
    @Cache.Lazy class method Map map() = \()( for e in this() \put(key=e.toS() val=e) )
    class method $ (S that) = {
      return this.map().val(key=that).val()
      catch error Any _ error S.ParseError(S"""
        |Invalid enumeration name: %(that).
        |Valid enumeration names are %this()
        """)
      }
    }
  }
]]></pre>
We carefully capture and regenerate errors: <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MyEnum.Vals('MisspelledName)]]></span><it style="font-style: bold; color:green;">&#187;</it> should provide a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.ParseError]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
As you can see, with a little experience it is possible to define decorators that behave like language extensions.
Developement on a large 42 program should start defining some appropriate decorators to make the rest of the code more fluent and compact.




</p><h2> (5/5)Metaprogramming summary </h2> <p>
<ul><li>
Metaprogramming is hard; 42 tries to make it simpler, but it is still not trivial.
</li><li>
Making your own decorators it is easy when your decorators are just a simple composition of other decorators.
</li><li>
Error handling is important while writing decorators.
A large part of decorators code should be dedicated
to handling errors and lifting them into a more understandable
form, for the sake of the final user.
</li><li>
We are just scratching the surface of what we
can do with metaprogramming.
If you are interested in becoming a Magrathean, then
join our effort to design the painful metaprogramming guide.
</li><li>
In the current state of the art we do not have an answer for what is the best 42 (meta-)programming style.
Indeed, we still do not understand the question.
</li></ul>
 </p><p id="ExampleOfProgram"> </p><div style="break-after:page"></div><h1> Example of a 42 program </h1> <p>

In this chapter, we will see how to develop a GUI connected with a DataBase.
For simplicity, consider that we have a database with a single table <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> that contains a few fields.
We want to make a GUI that displays the data and allows us to edit it.

</p><h2> (1/5) Query boxes </h2> <p>
First we load the libraries we need:
Unit, JavaServer, GuiBuilder and Query.

<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
Unit = Load:{reuse [L42.is/Unit]}
LoadJ = Load:{reuse [L42.is/JavaServer]}
LoadGui = Load:{reuse [L42.is/GuiBuilder]}
Query = Load:{reuse [L42.is/Query]}
]]></pre>
We then declare some useful units. <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> objects have ages expressed in years,
heights expressed in meters and weights expressed in Kgs.
<pre class="l42Big"><![CDATA[
Year = Unit(I)
Meter = Unit(Num)
Kg = Unit(Num)
]]></pre>
</p><p>
We then ask <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Query.sql]]></span><it style="font-style: bold; color:green;">&#187;</it> to generate a class to support SQL queries using a Java slave and a connection string.
As an example, we are using a derby DB.
For now, we consider the DB to be already populated. In the end we discuss how to initialize the DB itself.
<pre class="l42Big"><![CDATA[
DBJ = LoadJ(slaveName=S"dbServer{}") //slave for the DB connection
DB = Query.sql(//instantiate Query for SQL queries
  connectionString=S"jdbc:derby:PersonsGui;create=true",
  javaServer=DBJ)
]]></pre>


The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DB]]></span><it style="font-style: bold; color:green;">&#187;</it> can now reify the DB tables; here it is just <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Table.Person]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Table = DB.#$of().tables()
]]></pre>


Finally, we can make a query box with all the queries that are relevant for this application.
A query box is a capability class, whose methods are able to do queries on a given database.
It is obtained with the decorartor <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DB.QueryBox]]></span><it style="font-style: bold; color:green;">&#187;</it>,
that can recognize nested classes created with the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DB.query]]></span><it style="font-style: bold; color:green;">&#187;</it> method.
Since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DB]]></span><it style="font-style: bold; color:green;">&#187;</it> was created by providing the connection string, queries are aware of their database.

<pre class="l42Big"><![CDATA[
Queries = DB.QueryBox:{...}
]]></pre>
<pre class="l42Big"><![CDATA[
//file Queries.L42
All = DB.query[Table.Person.List]"SELECT * FROM Person"
  
Insert = DB.query[Void;S;Year;Meter;Kg]"""
  |INSERT INTO Person (name,age,height,weight)
  |Values (@name,@age,@height,@weight)
  """
DeleteId = DB.query[Void;I]"DELETE FROM Person WHERE id=@id"
DeleteName = DB.query[Void;S]"DELETE FROM Person WHERE name=@name"
]]></pre>
The symbol <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@]]></span><it style="font-style: bold; color:green;">&#187;</it> identifies parameters in the queries, while the types
in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[..]]]></span><it style="font-style: bold; color:green;">&#187;</it> are the query result type followed by any parameters.
Queries return lists of objects. Those objects are constructed by calling a (factory) method whose arguments have the same name as the query fields.
</p><p>

Right now the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Query]]></span><it style="font-style: bold; color:green;">&#187;</it> supports both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SQL]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[IQL]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We expect to add more query languages in the future.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[IQL]]></span><it style="font-style: bold; color:green;">&#187;</it> is a query language to query the user by asking them to complete a form.
Using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[IQL]]></span><it style="font-style: bold; color:green;">&#187;</it> in 42 is very similar to using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SQL]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In particular, the result of both SQL and IQL queries is a lists of objects instantiated using a unique #immK(..) method.
While this is a consistent and flexible way to process tabular data,
it means  that for queries returning a single column we must have a 
type with such a single field.
In 42, declaring those types and their corresponding list type takes just a single line.
Note how for Person we can use our specialized units <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Year]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Meter]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Kg]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<pre class="l42Big"><![CDATA[
Key = Data:Data.AddList:{I id}
PName = Data:Data.AddList:{S name}
Person = Data:Data.AddList:{S name, Year age, Meter height, Kg weight}
]]></pre>
In the same way, if a query returns a single row, we will have it served as the only element of a length 1 list.
</p><p>
We can now make the set of all user queries with another <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[QueryBox]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
GuiJ = LoadJ(slaveName=S"miniGuiSlave{}") //slave for IQL and Gui
IQL = Query.iql(javaServer=GuiJ)//instantiate Query for IQL queries
Dialogs = IQL.QueryBox:{...}//A box with all the queries we want to support
]]></pre>
<pre class="l42Big"><![CDATA[
//file Dialogs.L42
AddPersons = IQL.query[Person.List]"""
  | 'Add persons' Pages('Add data for more persons')
  | name 'person name:' String
  | age  'person age:'  Integer
  | height 'person height:' Decimal{regex='[0-9]*\\.[0-9][0-9]'}
  | weight 'person weight:' Decimal{regex='[0-9]*\\.[0-9]'}
  """
RemoveById=IQL.query[Key.List]"""
  | 'Deleting an entry' Single('Entry to delete?')
  | id 'index' String
  """
RemoveByName = IQL.query[PName.List]"""
  | 'Deleting entries' Tabular('Entries to delete?')
  | name 'person name:' String
  """
]]></pre>
For a complete guide to IQL, you can refer to the well designed
IQL guide, located in the readme of the
<a href='https://github.com/RegevBenita/IQL'>IQL repository</a>.

</p><h2> (2/5) Model </h2> <p>
To write a GUI we need a <it style="font-style: italic;">Model</it> and a <it style="font-style: italic;">View</it>.
The model is an object whose methods are triggered by events of the view.
Comparing this with the conventional MVC, here the model serves both the roles of the model and the controller.
In this example, the model will have the two boxes and the java slave to control the Gui.
<pre class="l42Big"><![CDATA[
Gui = LoadGui(javaServer=GuiJ)  
Model = Data:GuiJ.Handler:{...} //the model answering to Java events
]]></pre>
<pre class="l42Big"><![CDATA[
//file Model.L42
mut GuiJ j
mut Queries sql
mut Dialogs iql
@GuiJ.Handler mut method Void printAll(S msg)=(/*..*/)
@GuiJ.Handler mut method Void addPerson(S msg)=(/*..*/)
@GuiJ.Handler mut method Void removeById(S msg)=(/*..*/)
@GuiJ.Handler mut method Void removeByName(S msg)=(/*..*/)
]]></pre>
Methods annotated with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[GuiJ.Handler]]></span><it style="font-style: bold; color:green;">&#187;</it> will respond to the corresponding event from the view.
Those methods must all take a single <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S]]></span><it style="font-style: bold; color:green;">&#187;</it> parameter, used by the view to communicate extra information. This parameter is often unused.
Those methods are defined as follows:
<pre class="l42Big"><![CDATA[
@GuiJ.Handler mut method Void printAll(S msg)=(
  this.#j().submitEvent(key='Example.Display, id=S"tableClear", msg=S"")
  for (id,name,age,height,weight) in this.#sql().all()() (
    this.#j().submitEvent(key='Example.Display, id=S"tableAdd",
      msg=S"%id,%name,%age,%Double(height),%Double(weight),")
    )
  whoops DB.Fail, GuiJ.Fail
  )
]]></pre>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[printAll(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it> first asks the view to clear the table; then
it executes the query <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[all]]></span><it style="font-style: bold; color:green;">&#187;</it> by doing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.#sql().all()()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
That is:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.#sql()]]></span><it style="font-style: bold; color:green;">&#187;</it> is the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[QueryBox]]></span><it style="font-style: bold; color:green;">&#187;</it> offering access to all the individual query objects.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[this.#sql().all()]]></span><it style="font-style: bold; color:green;">&#187;</it> is the field access for the query object doing the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DB.query[Table.Person.List]"SELECT * FROM Person"]]></span><it style="font-style: bold; color:green;">&#187;</it> query.
Finally, since this query takes no parameters, we just use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[()]]></span><it style="font-style: bold; color:green;">&#187;</it> to call it. Calling the query returns a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Table.Person.List]]></span><it style="font-style: bold; color:green;">&#187;</it> object,
that is iterated with the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it>. We map the fields of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> onto local variables <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(id,name,age,height,weight)]]></span><it style="font-style: bold; color:green;">&#187;</it> for easy access in the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[for]]></span><it style="font-style: bold; color:green;">&#187;</it> body.
For each <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it>, the body asks the view to add a line into the table. Information has to be encoded as a string to be passed to the view. String interpolation <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[%]]></span><it style="font-style: bold; color:green;">&#187;</it> make this easy, and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> values are converted as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Double]]></span><it style="font-style: bold; color:green;">&#187;</it> to print them with decimal points instead of printing them as a fraction.
Finally, we <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[whoops]]></span><it style="font-style: bold; color:green;">&#187;</it> exceptions to assert that we do not expect them to be leaked.
<br/>
This is quite a mouthful.
42 code tends to be quite compact, but for the sake of clearity and to support learning, we will now encode it again in a more verbose style:
<pre class="l42Big"><![CDATA[
@GuiJ.Handler mut method Void printAll(S msg)=(
  eventChannel = S"Example.Display" //the view lissens on this channel
  eventId = S"tableClear" //the view reacts to this id
  this.#j().submitEvent(key=eventChannel, id=eventId, msg=S"")
  selectAll = this.#sql().all()
  Table.Person.List allPersons = selectAll()
  for person in allPersons (
    id = person.id()
    name = person.name()
    age = person.age()
    height = Double(person.height())//creates a Double from a Num
    weight = Double(person.weight())
    msg=S"%id,%name,%age,%height,%weight,"//a string format for the view
    this.#j().submitEvent(key=eventChannel, id=S"tableAdd", msg=msg)
    )
  catch exception DB.Fail x error x
  catch exception GuiJ.Fail x error x  
  )
]]></pre>
As you can see, you are free to make the code more readable by declaring a lot of local variables, but you can also keep a more compact style.
In the end, more verbose code may end up less readable simply because there is much more of it.

</p><p>
The other methods have a similar structure.
<pre class="l42Big"><![CDATA[
@GuiJ.Handler mut method Void addPerson(S msg)=(
  for (name,age,height,weight) in this.#iql().addPersons()() (
    this.#sql().insert()(name=name, age=age, height=height, weight=weight)
    )
  this.printAll(msg=msg)
  whoops DB.Fail, IQL.Fail
  )
]]></pre>
The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addPerson(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it> ask the user to provide data for a list of persons by running the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.addPersons()]]></span><it style="font-style: bold; color:green;">&#187;</it> IQL query,
returning a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person.List]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Then, the data of each <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> is inserted in the database.
Note how the parameters of the query <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.insert()]]></span><it style="font-style: bold; color:green;">&#187;</it> are provided using the names of the query declaration
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[".. Values (@name,@age,@height,@weight)"]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[@name]]></span><it style="font-style: bold; color:green;">&#187;</it> in the query string was used to create the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[name]]></span><it style="font-style: bold; color:green;">&#187;</it> parameter; and so on for the others. Thanks to metaprogramming
the query method is synthesized out of the query string.
<br/>
After inserting all the new data in the database, we refresh the displayed table by manually calling <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[.printAll(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><p>
<pre class="l42Big"><![CDATA[
@GuiJ.Handler mut method Void removeById(S msg)=(
  for (id) in this.#iql().removeById()() (//zero or one time
    this.#sql().deleteId()(id=id)
    )
  this.printAll(msg=msg)
  whoops DB.Fail, IQL.Fail
  )
@GuiJ.Handler mut method Void removeByName(S msg)=(
  for (name) in this.#iql().removeByName()() (//zero or many times
    this.#sql().deleteName()(name=name)
    )
  this.printAll(msg=msg)
  whoops DB.Fail, IQL.Fail
  )
]]></pre>
Methods <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[removeById(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[removeByName(msg)]]></span><it style="font-style: bold; color:green;">&#187;</it>
are very similar; they call the corresponding <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[IQL]]></span><it style="font-style: bold; color:green;">&#187;</it> query, 
extract the single field (using the notations <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(id)]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[(name)]]></span><it style="font-style: bold; color:green;">&#187;</it>) and update the database using the corresponding <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SQL]]></span><it style="font-style: bold; color:green;">&#187;</it> query.

</p><p>
In this setting we represent persons in two different classes:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Table.Person]]></span><it style="font-style: bold; color:green;">&#187;</it>.
This allows for those two different classes to actually be quite different:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Table.Person]]></span><it style="font-style: bold; color:green;">&#187;</it> have an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[id]]></span><it style="font-style: bold; color:green;">&#187;</it> field and fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[weight]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[height]]></span><it style="font-style: bold; color:green;">&#187;</it> are of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>.
On the other side <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> have no <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[id]]></span><it style="font-style: bold; color:green;">&#187;</it> field and 
fields <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[weight]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[height]]></span><it style="font-style: bold; color:green;">&#187;</it> are of type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Kg]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Meter]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Those two classes serve different roles, and if we wish to change the
kind of data the user must provid we can change <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Person]]></span><it style="font-style: bold; color:green;">&#187;</it> and make it even more distant with respect to the information stored in the database.
On the other side, if we wanted to apply a transformation on the data readed from the DB, we could use another custom person class, instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Table.Person]]></span><it style="font-style: bold; color:green;">&#187;</it>, and define and appropriate <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#immK]]></span><it style="font-style: bold; color:green;">&#187;</it> method to adapt the data from the database into any shape we need.
</p><p>
It is also interesting to consider what happens if the database schema changes.
If the person table is removed, or the person fields are renamed,
then we will get an error while typing the model.
<br/>
In some sense we are turning events that would have caused a runtime exception into
understandable compile time errors.


</p><h2> (3/5) View </h2> <p>
The library <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[GuiBuilder]]></span><it style="font-style: bold; color:green;">&#187;</it> allows to write a GUI
using Java Swing.
For safety reasons, Java code is compiled and executed on a separated JVM.
We can easily generate a GUI for our example in the following way:
<pre class="l42Big"><![CDATA[
OpenGui = {...}
]]></pre>
<pre class="l42Big"><![CDATA[
//file OpenGui.L42
class method Void (mut GuiJ j)[_] = (
  gui=Gui(j=j,package=S"miniGui",imports=S"""%
    | %Gui.defaultImports()
    | import javax.swing.table.DefaultTableModel;
    """,
    name='Example,x=800\,y=600\
    )
  gui"""%
    |JPanel screen1=new JPanel();
    |{add(screen1);}
    |JPanel buttons=new JPanel();
    |{addNorth(screen1,buttons);}
    |%gui.button(id=S"addPerson",msg='PressedAdd,text=S"add")
    |{addFlow(buttons,addPerson);}
    |%gui.button(id=S"removeById",msg='PressedRemove,text=S"remove by id")
    |{addFlow(buttons,removeById);}
    |%gui.button(id=S"removeByName",msg='PressedRemove,text=S"remove by name")
    |{addFlow(buttons,removeByName);}
    |%gui.button(id=S"printAll" msg='PressedPrint text=S"printAll")
    |{addFlow(buttons,printAll);}
    |Object[] tLabels={"id","name","age","height","weight"};
    |DefaultTableModel tModel=new DefaultTableModel(new Object[][]{},tLabels);
    |JTable table = new JTable(tModel);
    |{addCenter(screen1,new JScrollPane(table));}
    |{event.registerEvent("Example.Display","tableAdd",
    |  (k,id,msg)->SwingUtilities.invokeLater(()->tModel.addRow(msg.split(","))));}
    |{event.registerEvent("Example.Display","tableClear",
    |  (k,id,msg)->SwingUtilities.invokeLater(()->tModel.setRowCount(0)));}
    """
  )
]]></pre>

Where <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[gui.addButton(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> is a convenient way to generate a button raising 42 events.
When such 42 code will run, the following Java code will be generated:
<pre class="java"><![CDATA[
package miniGui; //generated and compiled code, it is not saved on any file
import javax.swing.*;
import l42Gui.*;//contained in GuiSupport.jar
import is.L42.platformSpecific.javaEvents.Event; //standard 42 Event class
import javax.swing.table.DefaultTableModel;

public class Example {
  public Example (Event event){
    l42Gui.L42Frame f=l42Gui.L42Frame.open(
      ()->new l42Gui.L42Frame(event,"Example",800,600){
        JPanel screen1=new JPanel();
        {add(screen1);}
        JPanel buttons=new JPanel();
        {addNorth(screen1,buttons);}
        JButton addPerson = new JButton("add");{
          addPerson.addActionListener(e->event
            .submitEvent("Example","addPerson","PressedAdd"));
        }
        {addFlow(buttons,addPerson);}
        JButton removeById = new JButton("remove by id");{
          removeById.addActionListener(e->event
            .submitEvent("Example","removeById","PressedRemove"));
        }
        {addFlow(buttons,removeById);}
        JButton removeByName = new JButton("remove by name");{
          removeByName.addActionListener(e->event
            .submitEvent("Example","removeByName","PressedRemove"));
        }
        {addFlow(buttons,removeByName);}
        JButton printAll = new JButton("printAll");{
          printAll.addActionListener(e->event
            .submitEvent("Example","printAll","PressedPrint"));
        }
        {addFlow(buttons,printAll);}
        Object[] tLabels={"id","name","age","height","weight"};
        DefaultTableModel tModel=new DefaultTableModel(new Object[][]{},tLabels);
        JTable table = new JTable(tModel);
        {addCenter(screen1,new JScrollPane(table));}
        {event.registerEvent("Example.Display","tableAdd",
          (k,id,msg)->SwingUtilities.invokeLater(
            ()->tModel.addRow(msg.split(","))));
        }
        {event.registerEvent("Example.Display","tableClear",
          (k,id,msg)->SwingUtilities.invokeLater(
            ()->tModel.setRowCount(0)));
        }
      }
    );
  }
}
]]></pre>
and in the java main <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[new Example(eventCapability)]]></span><it style="font-style: bold; color:green;">&#187;</it>
will be called.
As you can see, the code provided by the user is simply injected into
the body of a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JFrame]]></span><it style="font-style: bold; color:green;">&#187;</it> class.
From that context we can declare fields and methods, and we can declare initialization actions using (non-static) java initialization blocks.

This code would look trivial if you are a Java Swing expert, and very obscure otherwise.

Note how we use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[tModel.addRow(msg.split(","))]]></span><it style="font-style: bold; color:green;">&#187;</it>
to add the row to the table: in java <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[addRow]]></span><it style="font-style: bold; color:green;">&#187;</it> wants an array
and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[msg.split(",")]]></span><it style="font-style: bold; color:green;">&#187;</it> will produce an array from a string whose parts are separated by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it>.
We made in this way for the sake of a simple example, but
we are unsatisfied by this brittle solution: it only works since names or numbers should not have the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it> inside.

</p><h2> (4/5) Putting all together </h2> <p>
Finally, a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> puts this all together
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
Unit = Load:{reuse [L42.is/Unit]}
LoadJ = Load:{reuse [L42.is/JavaServer]}
LoadGui = Load:{reuse [L42.is/GuiBuilder]}
Query = Load:{reuse [L42.is/Query]}
Year = Unit(I)
Meter = Unit(Num)
Kg = Unit(Num)
DBJ = LoadJ(slaveName=S"dbServer{}")
DB = Query.sql(connectionString=S"jdbc:derby:PersonsGui;create=true", javaServer=DBJ)
Table = DB.#$of().tables()
Queries = DB.QueryBox:{...}
GuiJ = LoadJ(slaveName=S"miniGuiSlave{}")
IQL = Query.iql(javaServer=GuiJ)
Dialogs = IQL.QueryBox:{...}
Gui = LoadGui(javaServer=GuiJ)  
Model = Data:GuiJ.Handler:{...}
OpenGui = {...}

Main=(
  j=GuiJ.#$of()//the Java GUI slave
  sql=Queries(DB.#$of())//sql queries and the Java DB slave
  iql=Dialogs(IQL(j))//iql queries supported by the GUI slave
  model=Model(j=j,sql=sql,iql=iql)
  OpenGui(j=j)
  for e in j(\['Example]) ( e>>model )//event loop
  )
]]></pre>
As you can see, the GUI produces events on the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Example]]></span><it style="font-style: bold; color:green;">&#187;</it> (the name of the generated Java class) and 
consumes events on the channel <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Example.Display]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
If we wanted to add functionalities to initialize and 
to clear the database, we could do as follow: 
<pre class="l42Big"><![CDATA[
Create = DB.query[Void]"""
  |CREATE TABLE Person (
  |  id int NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY
  |    (Start with 1, Increment by 1),
  |  name varchar(255),
  |  age int,
  |  height decimal(5,2),
  |  weight decimal(5,1)
  |  )
  """
PopulateIfEmpty = { //if the DB is already set up, executing Create
  return Create(DB.#$of())() //will throw an exception.
  catch Message _ return void // if we ignore it such exception encodes
  } //an "initialize the DB if needed" operation.
]]></pre>
</p><p>
<pre class="l42Big"><![CDATA[
Drop = DB.query[Void]"DROP TABLE Person"
AfterMain = Drop(DB.#$of())()
]]></pre>

</p><h2> (5/5) Summary </h2> <p>
42 metaprogramming allows for complex applications to be written in compact and secure ways:
in this application we used 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[JavaServer]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[GuiBuilder]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Query]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Those are all normal 42 libraries that 42 programmers could write themselves, and indeed studying the implementation of those libraries is currently the best way to become a Magrathean.
</p><p>
In particular, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Query]]></span><it style="font-style: bold; color:green;">&#187;</it> allows us 
to take queries written in another language (for now, just SQL and IQL, but the concept is expandable)
and converts them into a simple 42 well typed API that can be used
to build programs in an compact and elegant way.
Concepts like the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[QueryBox]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to control what part of an application is allowed to do important operations, adding a great deal of security.
 </p><p id="DeployCode"> </p><div style="break-after:page"></div><h1> Deploy 42 </h1> <p>
In the context of 42 and AdamsTowel, there are three things that can be deployed:
 Executable programs,  Towels and Modules.

</p><h2> (1/5)Deploy Towels </h2> <p>

A towel is about the most massively useful thing a programmer can have.
A towel has immense psychological value, and you should always know where your towel is.
All the classes that we have used up to now without defining them, are defined in AdamsTowel.
They are all normal classes/libraries.
<br/>
You can code without a towel, but this means starting from first principles,
which could be quite unpleasant; especially since the only
primitive things that 42 offers are Library literals
(code as first class entities), the constant <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[void]]></span><it style="font-style: bold; color:green;">&#187;</it>,
and the types <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Library]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Void]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Any]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>

Towels are libraries providing standard
functionalities and types, such as number, boolean,
string and various kinds of decorators and system errors.

</p><p>
However, we do not expect all 42 programs to reuse the same exact towel.
For hygienic reasons, in real life everyone tends to use their own towel.
For similar reasons, any sizeable 42 program will use its own towel.
</p><p>

We expect different programs to use massively different libraries for
what in other languages is the standard library.
That is, there is no such thing as 'the 42 standard library'.

</p><h2> Using multiple Towels </h2> <p>

Towels shines when multiple towels are used at the same time.

<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
//here you can access to lots of utility classes defined inside the towel
//including numbers, strings and so on.
C = {reuse [L42.is/FordTowel]
  //here you can access a different set of classes.
  //For example, Num would refer to the number in FordTowel
  //and to see the number defined in AdamsTowel you have to write This1.N
  }
]]></pre>

Different code parts build upon different set of classes.
That is, by introducing multiple towels in nested scopes,
the names of the other scopes are <it style="font-style: italic;">masked</it>.
This is very useful for code that reasons on code; such task is pervasive in 42. 

</p><h2> Staining Towels </h2> <p>
If you are writing a sizeable program, 
or many similar programs, it make sense to
enrich a towel with some pre loaded libraries
and basic classes.

<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
RichTowel = Trait:{
  reuse [L42.is/AdamsTowel]
  Unit = Load:{reuse [L42.is/Unit]}
  Kg = Units.of(Num)
  Meter = Units.of(Num)
  }
Secret = {...}//Be careful to not commit the file 'Secret'
  //It should contain your passwords/tokens, as in 
  //class method S #$of()=S"ghp_..."
GW = Load:{reuse [L42.is/GitWriter]}
LoadDeploy = Load:{reuse [L42.is/Deploy]}
DeployGit = LoadDeploy.with(writer=GW)
DeployRicherTowel = DeployGit.towel(RichTowel()
  on=Url"github.com/Bob/Modules42/RichTowel.L42"
  writer=GW.#$of(token=Secret.#$of(),message=S".."))
]]></pre>
If you have write access to a github project under <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bob/Modules42]]></span><it style="font-style: bold; color:green;">&#187;</it>, the former code will create your towel and update it
on your github repository every time you run it.
If you want to just write on your hard drive, you could just do

<pre class="l42Big"><![CDATA[
FS = Load:{reuse [L42.is/FileSystem]}
LoadDeploy = Load:{reuse [L42.is/Deploy]}
DeployFS = LoadDeploy.with(writer=FS)
DeployRicherTowel = DeployFS.towel(RichTowel()
  on=Url"myLocalPath/RichTowel.L42"
  writer=FS.#$of())
]]></pre>

We are considering adding more variants, for example to allow writing on your FTP servers, google drives, dropbox and other similar services.
</p><p>
A <span style="color:#ff1111; font-weight: bold;"> Stained Towel </span> is a towel that looks like another but it is enriched by adding more things, either at the bottom.
In our example, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[RichTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> is just a stained variation of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> (2/5)Module deployment </h2> <p>

If you start writing in 42, you will soon feel the need
to factorize your project into libraries that can
be independently tested, deployed and loaded.
We call those library <it style="font-style: italic;">Modules</it>.
Very successful modules are used by multiple 
independent projects and developers; they are what is often called a third party library.
However, most modules exists just as development tools in 
order to keep the complexity of big projects under control.
</p><p>
In 42 it is easy to code with multiple modules, and modules can be much smaller than usual third party libraries and frameworks in other languages.
</p><p>
In 42 it is possible to employ a programming model where every developer (or every pair of developers in a pair programming style) is the
only one responsible of one (or more) modules and their maintenance process, while the group leader gives specifications and tests to be met by the various module developers and will glue all the code together.
</p><p>

Modules can be deployed in a way similar to towel deployment;
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> is used to load libraries,
but it also contains all the knowledge to deploy
them.
<br/>
The following example code deploys a Module
using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>:
<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
//could be L42.is/RichTowel and nothing would change
//...
Module = Trait:{
  reuse [L42.is/RichTowel]
  //need to be RichTowel in this example,
  //where AirplaneUnits is using Unit
  AirplaneUnitsUtilities = {...}
  AirplaneUnits = {...}
  }
DeployAirplaneModule = DeployGit.module(Module()
  name='AirplaneUnits
  on=Url"github.com/Bob/Modules42/AirplaneUnits.L42"
  writer=GW.#$of(token=Secret.#$of(),message=S".."))
]]></pre>

This code deploys <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Module.AirplaneUnits]]></span><it style="font-style: bold; color:green;">&#187;</it> to an URL as a module,
and turns <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnitsUtilities]]></span><it style="font-style: bold; color:green;">&#187;</it> and any other 
nested classes stained on top of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> private.
This includes 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Kg]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Meter]]></span><it style="font-style: bold; color:green;">&#187;</it> from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[RichTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
If there were any nested classes unreachable from public classes inside
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnitsUtilities]]></span><it style="font-style: bold; color:green;">&#187;</it> it will be pruned away.
Same for any nested class stained on top of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> and for 
any private unreachable one in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnits]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
The deployed library can be imported as usual.
For example the main
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnits = Load:{reuse [github.com/Bob/Modules42/AirplaneUnits]}]]></span><it style="font-style: bold; color:green;">&#187;</it>
allows us to see the content of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnits]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>

All the deployed code is closed code.
Towels are closed because they contain all the code to implement strings, numbers and so on.
Modules are also closed. They have abstract classes/methods
for each of the original towel concepts (before staining), and they can be rebound
to a multitude of towels.
In particular all stained versions of the same towel are compatible.
Every needed nested library
that was not present in the original towel, will be made private.
On the other side, all the classes in the original towel will 
be made abstract by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DeployGit.module(..)]]></span><it style="font-style: bold; color:green;">&#187;</it>
and will be rebound to the current towel by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>

Thus, in our example, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Unit]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Kg]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Meter]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AirplaneUnitsUtilities]]></span><it style="font-style: bold; color:green;">&#187;</it>
would become a private implementation detail of the exposed library.


</p><h2> (3/5)Deploy programs </h2> <p>

We can run our  applications inside 42, but we can also deploy them as  Jars, so that they can be run as a Java application.
<br/>
In 42 libraries can be directly manipulated, and
one possible manipulation is to convert them in 
another format, like an executable jar or a native program
and then save the result somewhere, such as on the website where the users can download it.
<br/>
For example, we could rework the code of the former chapter as follows:

<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
ToJar = Trait:{reuse [L42.is/AdamsTowel]
  Unit = Load:{reuse [L42.is/Unit]}
  LoadJ = Load:{reuse [L42.is/JavaServer]}
  LoadGui = Load:{reuse [L42.is/GuiBuilder]}
  Query = Load:{reuse [L42.is/Query]}
  Year = Unit(I)
  Meter = Unit(Num)
  Kg = Unit(Num)
  DBJ = LoadJ(slaveName=S"dbServer{}")
  DB = Query.sql(connectionString=S"jdbc:derby:PersonsGui;create=true", javaServer=DBJ)
  Table = DB.#$of().tables()
  Queries = DB.QueryBox:{...}
  GuiJ = LoadJ(slaveName=S"miniGuiSlave{}")
  IQL = Query.iql(javaServer=GuiJ)
  Dialogs = IQL.QueryBox:{...}
  Gui = LoadGui(javaServer=GuiJ)  
  Model = Data:GuiJ.Handler:{...}
  OpenGui = {...}
  class method Void #$main() = ( //method #$main instead of 'Main'
    j=GuiJ.#$of()
    sql=Queries(DB.#$of())
    iql=Dialogs(IQL(j))
    model=Model(j=j,sql=sql,iql=iql)
    OpenGui(j=j)
    for e in j(\['Example]) ( e>>model )
    )
  }
//..
Tast = DeployGit.jar(ToJar()
  on=Url"github.com/Bob/Modules42/MyApplication.jar"
  writer=GW.#$of(token=Secret.#$of(),message=S".."))
]]></pre>
As you can see,
we are wrapping the application code into a trait, including
a second reuse of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In this way the code of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ToJar]]></span><it style="font-style: bold; color:green;">&#187;</it> is fully self contained, and 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> in the outer scope can still use all of the towel features by taking them from the outer <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reuse [AdamsTowel]]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We then use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DeployGit.jar(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> to deploy our application onto a jar in a specific location.
Again, we could just deploy it on our file system or on another kind of service by using another kind of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[writer]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
When 42 is used to deploy an application as a Jar, you can see the whole 42 execution as a comprehensive compilation framework,
encompassing all the tools and phases that could possibly be needed into a single cohesive abstraction.

Such jar can be run with the following command
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[java -cp "L42.jar;MyApplication.jar" is.L42.metaGenerated.ExportedMain]]></span><it style="font-style: bold; color:green;">&#187;</it>
</p><p>
In this example we reuse AdamsTowel both outside <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ToJar]]></span><it style="font-style: bold; color:green;">&#187;</it>
and inside of it.
The two towels do not need to be the same.
The outermost just has to support the deployment process
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[DeployGit]]></span><it style="font-style: bold; color:green;">&#187;</it>, while the inner one is needed to make
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[ToJar]]></span><it style="font-style: bold; color:green;">&#187;</it> a closed library: only libraries that do not refer to external classes can be deployed.

</p><h2> A 42 project testing and deploying </h2> <p>

A common way to use 42 is to have a folder with the name of your project, containing
a folder <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main]]></span><it style="font-style: bold; color:green;">&#187;</it> with all the actual code,
and then various files providing testing and deploying functionalities, as in the following example:

<pre class="l42Big"><![CDATA[
reuse [L42.is/AdamsTowel]
Main = Trait:{
  ...
  Tests = {
    TestSuite_1 = {...}
    /*..*/
    TestSuite_n = {...}
    }
  }
Secret = {...}
GW = Load:{reuse [L42.is/GitWriter]}
LoadDeploy = Load:{reuse [L42.is/Deploy]}
DeployGit = LoadDeploy.with(writer=GW)
Tast = DeployGit.jar(Main()
  on=Url"github.com/Bob/Modules42/MyApplication.jar"
  writer=GW.#$of(token=Secret.#$of(),message=S".."))
]]></pre>

In general, for medium size projects is a good idea to keep executing the tests before the deployment; for example
we can have a test suite after the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[...]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Do not panic, If the test are not reachable from <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Main.#$main()]]></span><it style="font-style: bold; color:green;">&#187;</it>, they are not going to be included in the executable jar.
</p><p>


</p><h2> (4/5)Towel embroidery: Define and deploy our own towel </h2> <p>


Towel embroidery it is like adding your initials to your towel.
</p><p>
While we can simply add to the end by staining, embroidery is much more powerful.
</p><p>
The most common embroidery tool 
is <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Organize]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Together with late casts, we can add methods to any existing class as shown below:
<pre class="l42Big"><![CDATA[
Code = Trait:Organize:{reuse [L42.is/AdamsTowel]
  S$ = {/*..more methods for string here..*/
    method S reverse() = (/*..*/ (this<:@This1 S).size() /*..*/)
    }
  Num$ = {/*..more methods for numbers here..*/}
  }
]]></pre>



The advantage with respect to composing two separated
libraries is that the scope is the same:
the implementation of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[reverse()]]></span><it style="font-style: bold; color:green;">&#187;</it> will be able to use <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Bool]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> and so on.


Towel staining is a very minimal personalization, and stained towels are fully compatible with the original one.

With embroidery you can personalize the content of your towel a lot more,
but when module deployment 
relies on an embroidered towel, compatibility with the original towel is lost.
For example, an embroidered version of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> 
can <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it> a library developed on the original 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>, but a library developed on the embroidered version 
needs to be loaded into a similarly embroidered towel.

One typical reason to embroider a towel is to
extend the set of classes that are shared between libraries.
For example, one may want to develop a Towel for scientific use
where the existence of some units of measure can be shared between all the libraries.
We could do the following:
<pre class="l42Big"><![CDATA[
RawCode = Trait:{reuse [L42.is/AdamsTowel]
  Unit = Class:Trait({@AbstractTowel{
    "en.wikipedia.org/wiki/Quantity"}}):
    Load:{reuse [L42.is/Unit]}
  SI = Class:Unit.TraitSI['Support=>Num]:{@AbstractTowel{
    "en.wikipedia.org/wiki/International_System_of_Units"}}
  Load$={
    class method Introspection.Nested.List _baseDeps()
    class method Introspection.Nested.List baseDeps() = this._baseDeps().withAlso(\[
      Info(Unit);
      Info(SI);
      ])      
    }
  }
Secret = {...}
GW = Load:{reuse [L42.is/GitWriter]}
LoadDeploy = Load:{reuse [L42.is/Deploy]}
DeployGit = LoadDeploy.with(writer=GW)
DeployRicherTowel = DeployGit.towel(
  Organize:RawCode
    ['Load.baseDeps()->'Load._baseDeps()]
    [hide='Load._baseDeps()]
  on=Url"github.com/Bob/Modules42/SITowel.L42"
  writer=GW.#$of(token=Secret.#$of(),message=S".."))
]]></pre>
Now <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[github.com/Bob/Modules42/SITowel]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used as a towel,
and can be used to deploy modules that can be loaded by 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[github.com/Bob/Modules42/SITowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.
</p><p>
By using semantic URIs as
ontological nodes, we
can create a basis for other libraries when trying to infer the meaning of our added types.
In the example above we used wikipedia links to relevant concepts.
This may not be the best solution, devising a good solution for this problem would require very intense research in the area of Ontological mapping.
</p><p>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SITowel]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used now to deploy and load libraries wrote in
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SITowel]]></span><it style="font-style: bold; color:green;">&#187;</it>, and libraries deployed and loaded in this way will 
share a unique definition for certain units of measure.
Note that libraries originally developed for
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> can still be loaded normally since <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SITowel]]></span><it style="font-style: bold; color:green;">&#187;</it> is structurally a superset of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> (5/5)Deployment: programs, libraries and towels; summary </h2> <p>
<ul><li>
42 is a metaprogramming tool.
It is natural to use 42 either as a language (to run a program)
or as a compiler (to deploy programs, libraries and towels).
</li><li>
Indeed we expect all sizeable 42 projects to use 42 as a compiler,
to produce some reusable artefacts.
</li><li>
The distinction between towels (that do not need <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Load]]></span><it style="font-style: bold; color:green;">&#187;</it>)
and modules is 
introduced not by 42, but by <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it>; radically different towels may provide different meaning for the concepts of deploying and
loading libraries/towels.
</li><li>
Application developers can freely stain and embroider towels;
in this way they can adapt <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[AdamsTowel]]></span><it style="font-style: bold; color:green;">&#187;</it> to serve them better.
However, library developers need to carefully consider the effect of embroidery.
</li></ul>
        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'>
            <a href="mailto:marco.servetto@gmail.com" rel="me">Contact Us</a> |</li>
            <li style='display:inline;'>
            <a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>
