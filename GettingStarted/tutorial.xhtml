<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logo.png' alt='42'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<div class="index"><div class="wrapFloat">
<div class="rotate90 inFloat"> Index of Content</div>
<ol class="inFloat">
 <li><a href="#Basics"> Basic concepts </a></li>
 <li><a href="#ModifiersIntro"> Introduction to modifiers </a></li>
 <li><a href="#BasicClasses"> Basic Classes </a></li>
 <li><a href="#InterfacesAndData"> Interfaces and Data </a></li>
 <li><a href="#Sequences"> Collections and Sequences </a></li>
 <li><a href="#ErrorsAndExceptions"> Errors and Exceptions </a></li>
 <li><a href="#Exercises"> Exercises </a></li>
 <li><a href="#ExamplesOfLibraries"> Examples of libraries </a></li>
 <li><a href="#MetaprogrammingIntro"> Introduction to Metaprogramming </a></li>
 <li><a href="#DeployCode"> Deploy code </a></li>
 <li><a href="#Philosophy"> Guaranties and Philosophy </a></li>
</ol>
</div><div class="finishFloat"></div></div>

 </p><p id="Exercises"> </p><h1> Exercises </h1> <p>

A very large class of practically useful programs can be obtained by
just declaring
elemental classes, collections
and simple Data classes.

Let's see some exercises and solutions 
to understand better how 42 code looks like

</p><h2> (1/5) Max method </h2> <p>
Write a class method <span class="code"><![CDATA[max]]></span> returning the max from a list of numbers
</p><p>
Solution:
<pre class="l42Big"><![CDATA[
UndefinedOnEmpty:Message.$<<{implements Guard}
//Max is undefined on empty lists.
//Since there was no mention of preconditions,
//we should explicitly handle all the error cases!
class method
Num max(Nums that) {
  if that.isEmpty() (error UndefinedOnEmpty"Max is undefined on empty lists")
  //now that we know we can proceed:
  var Num maxCandidate=that.left()
  //there is no such thing like a minimum number,
  //we need to select one element from the list.
  with n in that.vals() (
    //we could write 'that.withoutLeft().vals()'
    //to avoid cheching on the first again
    if maxCandidate<n (maxCandidate:=n)
    //update the variable to keep track of the max so far.
    )
  return maxCandidate
  }
]]></pre>

</p><h2> (2/5) Merge two lists of strings </h2> <p>
Write a class method map producing a string from to lists of strings of the same length.
 For example
<span class="code"><![CDATA[map(keys:Strings[S"a";S"b";S"c"],vals:Strings[S"z";S"y";S"z"])]]></span>
should produce <span class="code"><![CDATA[S"[a->z, b->y, c->z]"]]></span>
</p><p>
Solution:
<pre class="l42Big"><![CDATA[
UnequalSize:Message.$<<{implements Guard}
class method
S map(Strings keys, Strings values) {
  if keys.size() != values.size() (error UnequalSize
    "keys="[keys.size()]", values="[values.size()]"" )
  //the former formatting allows us to keep a whole line for the error message
  return S"["[with k in keys.vals(), v in values.vals() (
    use[k++S"->"++v, sep:S", "]
    )]"]"
  }
]]></pre>

</p><h2> (3/5) Filtering </h2> <p>
Write a <span class="code"><![CDATA[class method Strings upTo(Strings that, Size size)]]></span> that filters out from a list of strings the ones longer
than size.
For example 
<span class="code"><![CDATA[upTo(Strings[S"a";S"ab";S"abc"],size:2Size)==Strings[S"a";S"ab"]]]></span>
</p><p>
Precondition: size is not negative
</p><p>
Solution:
<pre class="l42Big"><![CDATA[
class method
Strings upTo(Strings that, Size size) (//no need of '{..return..}' for simple methods
  Assert.Pre[size>=0Size]
  Strings[with s in that.vals() (  if s.size()<=size (use[s]) )]
  )
]]></pre>

</p><h2> (4/5) Random mole </h2> <p>
For a longer example, represent a piece of land as a 80*80 bi-dimensional vector,
where every cell can be full of dirt (90%) or rock (10%).
Then a mole start from the left top corner and attempts to
digs through dirt randomly.
After 100 steps the mole stops.
declare the opportune classes and write a randomDig
method. 
</p><p>
You can use the library <span class="code"><![CDATA[L42.is/Random]]></span>
for randomness. You can use <span class="code"><![CDATA[Range(stop)]]></span> to iterate over
all (<span class="code"><![CDATA[Size]]></span>) nubers from 0 to <span class="code"><![CDATA[stop]]></span>-1 included.
</p><p>
A possible solution:
<pre class="l42Big"><![CDATA[
Random:Load<<{reuse L42.is/Random}

Cell:Enumeration"dirt, rock, empty, mole"

Direction:Enumeration"up, down, left, right"

Point:Data<<{implements Concept.Invariant
  Size x, Size y

  method invariant()
    x>=0Size & x<80Size & y>=0Size & y<80Size
  This go(Direction that) {
    if that.isUp() (return this.with(x:\-1Size))
    if that.isDown() (return this.with(x:\+1Size))
    if that.isLeft() (return this.with(y:\-1Size))
    Assert.Bug[that.isRight()]
    return this.with(y:\+1Size)
    catch error Concept.Invariant.Failure err  (return this)
    }
  }

Land:Data<<{//we may want to put the field and the predefined factory private;
  //we will learn how to do that later.
  mut Cell.List cells
  
  class method
  mut This ()
    This(cells:Cell.List[
      with i in Range(stop:80Size*80Size) (
        if Random(10Size)==0Size (use[Cell.rock()])
        else (use[Cell.dirt()])
        )
      ])   

  mut method
  Void randomDig() (
    var Point current=Point(x:0Size,y:0Size)
    with i in Range(stop:100Size) (
      this.set(current,val:Cell.empty())
      d=Direction.from(index:Random(4Size)
      newPoint=current.go(d)
      if !this.get(d).isRock() (//no digging in rock
        current:=newPoint
        )
      )
    this.set(current,val:Cell.mole())//finally, the mole is where we ends up
    )
  
  //implementation of the matrix as an example,
  //should be imported from a library
  mut method 
  Void set(Point that, Cell val)
    this.#cells()(that.y()*80Size+that.x(), val:val)
    
  read method 
  Cell get(Point that)
    this.#cells().val(that.y()*80Size+that.x())    
  
  toS() S""[with x in Range(stop:80Size) (
      use[S.nl()]//newline
      with y in Range(stop:80Size) (
        p=Point(x:x,y:y)
        if this.get(p).isRock() (use[S"#"])
        else if this.get(p).isDirt() (use[S"%"])
        else if this.get(p).isEmpty() (use[S" "])
        else (Assert.Bug[this.get(p).isMole()] use[S"M"])         
      ))]""
  //since we define it explicitly, Data will leave it alone :)
  }
]]></pre>


</p><h2> (5/5) Examples summary </h2> <p>
<ul><li>
Always think about what can go wrong upfront
</li><li>
Most methods can be completed by first checking for 
errors/issues and then using a <span class="code"><![CDATA[with]]></span>
</li><li>
Before heading into a problem,
spend some time to define your problem domain.
We dodged a lot of headaches by defining
points with invariants.
</li></ul>

Some may argue that in a real object oriented implementation,
directions and cells should be interfaces with subtypes;
so that we can use single dispatch to
avoid the cascades of ifs.
We have mixed feelings about this:
shorter code is better and more maintainable then longer code, and the version with subtyping would have been much longer.

The crucial point is that the 'random mole' code is not designed to be used by other programmers as a library.
Libraries should have well modularize code,
and provide convenient hooks for adaptation.
Metaprogramming and interfaces are the right tool for this task.

We should not confound adaptability (without touching the original source, make it so that a new problem can be tackled), with maintenability (change the original source to keep it up to date
with the ever-changing set of requirements).
 </p><p id="ExamplesOfLibraries"> </p><h1> Example of Libraries </h1> <p>

</p><h2> (1/5)Gui </h2> <p>
42 stands for the primate of libraries, so let see some libraries in action.
We have already see how to chose a towel, and many classes that are likely to be present in such towel, like
<span class="code"><![CDATA[S]]></span> and <span class="code"><![CDATA[Data]]></span>.
Let see now how to load a library from its url: 
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Gui: Load<<{reuse L42.is/Gui}
Main: {
  Gui.alert(S"hi!")
  return ExitCode.success()
  }
}
]]></pre>
Load is another decorator, here it modifies the library found in L42.is/Gui
 so that it can be used easily from AdamTowel.

Gui allows to create graphical user interfaces using html.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Gui: Load<<{reuse L42.is/Gui}
MyGui: Gui(
  title: S"My Gui" //seek for index.html in your basePath
  basePath: S"base/path/for/my/files"// use / on all operative systems
  x: 600Gui.Pixel
  y: 400Gui.Pixel
  )<<{
  mut method
  Void event_quit(mut Gui gui, S msg)
    gui.close()

  mut method
  Void event_sayHi(mut Gui gui, S msg)
    Gui.alert(S"hi")

  mut method
  Void event_say(mut Gui gui, S msg) (
    //msg is going to be a multiline string,
    //first line equal to "say", other lines give more info
    Strings ss=msg.split(S.nl())
    Gui.alert(S"hi dear "+ss.val(1\))
    )
  }

Main: MyGui()
}
]]></pre>
And the file <span class="code"><![CDATA[index.html]]></span>
would look like: 
<pre class="html"><![CDATA[
<html>
  <head> </head>
  <body>
    Hi, buttons here
    <Button onclick='event42("quit");'> Quit</Button>
    <Button onclick='event42("sayHi");'> Say Hi</Button>
    <Button onclick='event42("say\ncaterpillar");'> Say Hi</Button>
  </body>
</html>
]]></pre>
Do not forget the two layers of quotes: you need to quote both the call to <span class="code"><![CDATA[event42]]></span>
and the string codifying the event itself.

To make something happen in the gui, you can use 
<span class="code"><![CDATA[gui.executeJs(cmd)]]></span>.
For example
<pre class="l42Big"><![CDATA[
mut method
Void event_useJSToWriteOnTextArea(mut Gui gui, S msg) (
  Strings ss=msg.split(S.nl())
  js1=Gui.JavaScript"document.getElementById('myTextAreaId').value = 'Hi! event happened';"
  //or, to use information in the message
  js2=Gui.JavaScript"document.getElementById('"[ss.val(1\)]"').value = '"[ss.val(2\)]"';"
  gui.executeJS(js2)
  )
]]></pre>

Gui provide help to visualize datastructures of various kind, 
for example vectors of Data classes can be shown as tables in the following way: 
<pre class="l42Big"><![CDATA[
Person: Data<<{ Size id, Name name, Name surname, Year age }
Persons: Collections.vector(of: Person)
ShowPersons: Gui.widget(table: Persons)
InputPerson: Gui.input(dialogForm: Person)//rely on JQuery UI
MyGui: Gui(/*..*/)<<{ mut Persons persons //field
  /*..*/
  mut method
  Void eventLoad(mut Gui gui, S msg) ( //no underscore for system events
    gui.add(ShowPersons(this.#persons(), into: Gui.Id"divLeft"))
    //the element with that id will contain the table
    )
  mut method
  Void event_addPerson(mut Gui gui,S msg) (
    Person p=InputPerson(gui,title: S"New Person details")
    catch exception InputPerson.Cancelled exc ( void)//do nothing
    this.persons().add(left: p)
    gui.refresh()
    )
  }
Main: MyGui(persons: Persons[])
]]></pre>

</p><h2> (2/5) Files </h2> <p>
In 42 you can import <span class="code"><![CDATA[FSystem]]></span> to read and write files.


<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
FSystem: Load<<{reuse L42.is/FSystem}

Main: {
  files=FSystem()
  files.write(S"foo.txt",S"foo foo foo!")
  S foos=files.read(S"foo.txt")//most likely, it contains 'foo foo foo!'
  return ExitCode.normal()
  }
}
]]></pre>

42 can execute every closed expression early, even at compile time, if it could give 
a performance boost.
To avoid unexpected early effects
you should
pass a files object to functions that do
I/O: 

<pre class="l42Big"><![CDATA[

method S readFoo()
 FSystem().read(S"foo.txt") //may read foo once and for all at compile time,
//and then return the same value every time. It can be useful
//for loading resources, like image files in a simple game.

method S readFoo(mut FSystem that)
 that.read(S"foo.txt") //need the parameter to act, thus
 //will wait until a parameter is provided
]]></pre>

In general, all the system interaction that happens over the same system object are
chronologically sorted with respect to each other, but there is no guarantee 
of ordering between different system objects.

</p><h2> (3/5) Db </h2> <p>
In AdamTowel, databases can be access in two ways: 
Raw access (similar to what is supported by
<span class="code"><![CDATA[DBC]]></span> or <span class="code"><![CDATA[JDBC]]></span> libraries) 
and Structured access.
<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel
Db: Load<<{reuse L42.is/Db}//Db can do Raw access
UnivDb: Db.importStructure(Db.ConnectionS"...")
QueryCountry: UnivDb.Query"select * from students where country=@country"
Main: {
  connection=UnivDb.connect()
  UnivDb.Student.Table ss=QueryCountry(connection, country: S"Italy")
  /*..*/
  }
}
]]></pre>
Here
we use <span class="code"><![CDATA[Db]]></span> to 
import the structure of the database. This means that 
<span class="code"><![CDATA[UnivDb]]></span> will contain a class for each table-row of the database,
every class will have a nested type representing 
multiple rows (that is, a table).
<span class="code"><![CDATA[UnivDb.Query]]></span> allows prepared queryes.
In the case in the example, we can use
<span class="code"><![CDATA[QueryCountry(that,country)]]></span>
to get the italian students.
Note how <span class="code"><![CDATA[country]]></span> is a parameter of the method: in this way the  query users are informed of the query expectations.
Our query used <span class="code"><![CDATA[*]]></span>, so the type <span class="code"><![CDATA[UnivDb.Student.Table]]></span>
could be reused.
In other cases a new type would be generated.

</p><h2> (4/5) example Gui and Db together </h2> <p>

In the following code we show an example where a Gui visualize the Italian students.

We could visualize directly elements of 
type <span class="code"><![CDATA[UnivDb.Student]]></span>, but we chose 
to write more flexible and maintainable code,
where we define our basic classes (<span class="code"><![CDATA[Name]]></span> and
<span class="code"><![CDATA[Year]]></span>)
and we define an injection from
<span class="code"><![CDATA[UnivDb.Student]]></span>
to
<span class="code"><![CDATA[Person]]></span>.
Then we just use the 
<span class="code"><![CDATA[eventLoad]]></span> method
to load the information from the DB and
to display it.

<pre class="l42Big"><![CDATA[
{reuse L42.is/AdamTowel

Name:Alphanumeric:<<{This parse(S that) (
  if that.contains(S.nl()) (error Alphanumeric.ParseError
    "new lines not allowed in method names")
  This(that) 
  )}

Year:Unit.of(Num)

Db: Load<<{reuse L42.is/Db}

UnivDb: Db.importStructure(Db.ConnectionS"...")//will not use Name and Year

QueryCountry: UnivDb.Query"select * from students where country=@country"

Person: Data<<{ Name name, Name surname, Year age 
  class method
  This from(UnivDb.Student db)
    Person(
      name: Name.from(base:db.name())
      surname:Name.from(base:db.surname())
      age:Year.from(base:db.age())
      )
  }

Persons: Collections.vector(of: Person)

ShowPersons: Gui.widget(table: Persons)

MyGui: Gui(/*..*/)<<{
  mut method
  Void eventLoad(mut Gui gui, S msg) (
    connection=UnivDb.connect()
    UnivDb.Student.Table ss=QueryCountry(connection, country: S"Italy")
    ps=Persons[with s in ss.vals() (use[Person.from(db:s)])]
    gui.add(ShowPersons(ps, into: Gui.Id"divLeft"))
    )
  }

Main: MyGui()
}
]]></pre>

It is interesting to notice that if we wish to change the
content of the students graphical representation, we just need to change the class <span class="code"><![CDATA[Person]]></span> and add/remove/swap fields.
</p><p>

It is also interesting to consider what happens if the database schema changes.

If there are no more students, or the students do not have countries any more,
then we will get an error while generating the class <span class="code"><![CDATA[QueryCountry]]></span>.

If the students will not have names, surnames or ages
any more, then we will get an error while generating the
<span class="code"><![CDATA[Person]]></span> class.
In some sense we are turning into understandable compile time errors events that would have caused a runtime exception in most other languages.

</p><h2> (5/5) Libraries </h2> <p>

42 is designed to support libraries and cooperation of multiple libraries at the same time.

Since 42 is still in its infancy, there are not many libraries around yet.
Stay tuned for more!
        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <!--<li style='display:inline;'><a href="http://ecs.victoria.ac.nz/Main/MarcoServetto" >Contact Us</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/disclaimer">Mailing list</a> |</li>
            <li style='display:inline;'><a href="http://www.victoria.ac.nz/ecs/accessibility" >Site Accessibility</a></li>
			-->
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>

