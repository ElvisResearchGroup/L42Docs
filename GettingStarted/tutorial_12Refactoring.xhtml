<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <link rel="stylesheet" type="text/css" href="css/style.css" media="all"/>
    <script src="js/ace.js"></script>
    <script src="js/utils.js"></script>
    <link rel="shortcut icon" href="css/favicon.ico"/>
    <title>42 - Metaprogramming as default</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="https://www.googletagmanager.com/gtag/js?id=G-M0E4M0XH2Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-M0E4M0XH2Z');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-212820693-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-212820693-1');
    </script>
    <script src="https://www.googletagmanager.com/gtag/js?id=AW-10810288706"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'AW-10810288706');
    </script>
<!-- Event snippet for Page view conversion page -->
<script>
gtag('event', 'conversion', {'send_to': 'AW-10810288706/U3KJCKekmIUDEMLU36Io'});
</script>
  </head>
  <body onload='doOnLoad();'>
    <div id="wrapper">
      <div id="headerwrap">
        <div id="header">
          <img style='float:left;'
            src='css/logoBlue.png' alt='42' width='120' height='120'/>
          <h3 style='float:left;'>
            <p style='font-size:150%; color:rgb(250,250,250);'>42 - The definitive answer to design, code and everything</p>
            <p style='font-size:100%; color:rgb(250,250,250);'> --But you are not going to like it</p>
          </h3>
        </div>
      </div>
      <div id="contentwrap">
        <div id="content">
<p>
<div class="index"><div class="wrapFloat"><div class="inFloat">
<div class="rotate90"> Index of Content</div>
</div><div class="inFloat">
<ol>
 <li><a href="tutorial_01Basics.xhtml"> Basic concepts </a></li>
 <li><a href="tutorial_02ModifiersIntro.xhtml"> Introduction to modifiers </a></li>
 <li><a href="tutorial_03BasicClasses.xhtml"> Basic Classes </a></li>
 <li><a href="tutorial_04ErrorsAndExceptions.xhtml"> Errors and Exceptions </a></li>
 <li><a href="tutorial_05Caching.xhtml"> Caching </a></li>
 <li><a href="tutorial_06CachingMut.xhtml"> Caching on Mutable objects </a></li>
 <li><a href="tutorial_07InterfacesAndMatching.xhtml"> Interfaces and Matching </a></li>
 <li><a href="tutorial_08Sequences.xhtml"> Collections and Sequences </a></li>
 <li><a href="tutorial_09InputOutput.xhtml"> Input Output </a></li>
 <li><a href="tutorial_10Exercises.xhtml"> Exercises </a></li>
 <li><a href="tutorial_11MetaprogrammingIntro.xhtml"> Metaprogramming Introduction </a></li>
 <li><a href="tutorial_12Refactoring.xhtml"> Programmatic Refactoring </a></li> 
 <li><a href="tutorial_13MoreDecorators.xhtml"> More Decorators </a></li>
 <li><a href="tutorial_14ExampleOfProgram.xhtml"> Example of a 42 Program </a></li>
 <li><a href="tutorial_15DeployCode.xhtml"> Deploy code </a></li>
</ol>
</div></div><div class="finishFloat"></div></div>
<br/>
<div class="index"><div class="wrapFloat"><div class="inFloat">
</div><div class="inFloat">
&nbsp; &nbsp; &nbsp; <a href="tutorial_11MetaprogrammingIntro.xhtml"> Previous </a>...<a href="tutorial_13MoreDecorators.xhtml"> Next </a>
</div></div><div class="finishFloat"></div></div>
<br/>

 </p><p id="Refactoring"> </p><div style="break-after:page"></div><h1> Traits and rename </h1> <p>

</p><h2> (1/5)An introduction to Programmatic Refactoring </h2> <p>

Traits allow us to programmatically rename methods and nested classes to other names.
Consider the following example code, defining trait <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Code1]]></span><it style="font-style: bold; color:green;">&#187;</it>, containing many nested classes:
the interface <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>, the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> implementing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>,
the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>, that is similar to <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> but does not implements <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>
and finally the class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[D]]></span><it style="font-style: bold; color:green;">&#187;</it> that uses both <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>:

<pre class="l42Big"><![CDATA[
Code1 = Trait:{
  A = {interface,  method S m()}
  B = {[A],        method S m()=S"Hi"                    class method This()}
  C = {            method S m()=S" world"                class method This()}
  D = {            method S callBoth()=B().m()++C().m()  class method This()}
  }
Concrete1 = Class:Code1
Main1 = Debug(Concrete1.D().callBoth())
]]></pre>
We can extract the code into class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Concrete1]]></span><it style="font-style: bold; color:green;">&#187;</it>, and then use it to print 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA["Hi World"]]></span><it style="font-style: bold; color:green;">&#187;</it>.
We show below how we can use the operator <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[[_]]]></span><it style="font-style: bold; color:green;">&#187;</it> to programmatically rename elements of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Code1]]></span><it style="font-style: bold; color:green;">&#187;</it> while preserving the semantic:
<pre class="l42Big"><![CDATA[
Concrete2 = Class:Code1['A.m()=>'A.k()]
Concrete2 = {//equivalent to just writing the following directly:
  A = {interface,  method S k()}
  B = {[A],        method S k()=S"Hi"                    class method This()}
  C = {            method   m()=S" world"                class method This()}
  D = {            method S callBoth()=B().k()++C().m()  class method This()}
  }
Main2 = Debug(Concrete2.D().callBoth()) //still prints "Hi World"
]]></pre>
As you can see above, the mapping <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.m()=>'A.k()]]></span><it style="font-style: bold; color:green;">&#187;</it> renamed all
the occurrences of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.m()]]></span><it style="font-style: bold; color:green;">&#187;</it> into <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.k()]]></span><it style="font-style: bold; color:green;">&#187;</it>. This includes all the
declarations refining such method and all the usages of such method, either from the
static type <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> or from any nested class implementing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it>.
On the other side, you can see how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C().m()]]></span><it style="font-style: bold; color:green;">&#187;</it> was not renamed; the rename is type driven.
We can also rename multiple names at once; in this way we can even swap names:

<pre class="l42Big"><![CDATA[
Concrete2 = Class:Code1[
  'A.m()=>'A.k();
  'B.#apply() =>'B.of();
  'C=>'D;
  'D=>'C;
  ]
Concrete3 = {//equivalent to just writing the following directly:
  A = {interface,  method S k()}
  B = {[A],        method S k()=S"Hi"                       class method This of()}
  C = {            method S callBoth()=B.of().k()++D().m()  class method This()}
  D = {            method   m()=S" world"                   class method This()}
  }
Main3 = Debug(Concrete3.C().callBoth()) //still prints "Hi World"
]]></pre>
Note how the call <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B()]]></span><it style="font-style: bold; color:green;">&#187;</it> is now replaced with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[B.of()]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[#apply()]]></span><it style="font-style: bold; color:green;">&#187;</it> is the extended name for the method with the empty name.
Also binary operator methods can be renamed by using their extended name;
The complete list of extended names for binary operators is discussed later, but you can also just use the overview feature to see them in any compiled class.
The <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it> sign is a syntactic sugar similar to the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\]]></span><it style="font-style: bold; color:green;">&#187;</it>;
indeed <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Foo.bar(x)]]></span><it style="font-style: bold; color:green;">&#187;</it> is equivalent to
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[\"Foo.bar(x)"]]></span><it style="font-style: bold; color:green;">&#187;</it>; where the text after the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[']]></span><it style="font-style: bold; color:green;">&#187;</it> has strict syntactic restrictions, requiring it to be either a valid path (as <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Beer.Foo]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[This]]></span><it style="font-style: bold; color:green;">&#187;</it>, for example), a valid method selector, or 
a path followed by a method selector.
A method selector can also be followed by an argument name, as in <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Foo.bar(x).x]]></span><it style="font-style: bold; color:green;">&#187;</it>
In 42 programmatic refactoring and other tasks requiring us to express paths and method selectors are very common, and writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myTrait['A=>'B]]]></span><it style="font-style: bold; color:green;">&#187;</it> is so much more convenient that writing <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myTrait[Name"A"=>Name"B"]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> (2/5) Programmatic Refactoring: all kinds of operations </h2> <p>
</p><h2> Single </h2> <p>
Programmatic refactoring of nested classes is transitive by default.
All the nested classes are going to be renamed together with the renamed root.
The code below shows how to specify a single rename instead:
<pre class="l42Big"><![CDATA[
MultiLevel = Trait:{
  A = {
    class method S hi() = S"hi"
    B = {class method S world() = S"world"}
    }
  C = {
    class method Void print() = Debug(A.hi()++D.space()++A.B.world())
    D = { class method S space() = S" " }
    }
  }
MultiConcrete = Class:MultiLevel[ single='C=>'K; 'A=>'D.H ]
MultiConcrete = {//equivalent to just writing the following directly:
  D = {
    H = {
      class method S hi() = S"hi"
      B = {class method S world() = S"world"}
      }
    }
  C = {
    D = { class method S space() = S" " }
    }
  K = {
    class method Void print() = Debug(D.H.hi()++C.D.space()++D.H.B.world())
    }
  }
Main4 = MultiConcrete.K.print() //still prints "hi world"
]]></pre>
As you can see, we did a single rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['C=>'K]]></span><it style="font-style: bold; color:green;">&#187;</it> and a transitive rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>'D.H]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Since there were nested classes inside of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it>, the single rename has left a shell of
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C]]></span><it style="font-style: bold; color:green;">&#187;</it> in place so that the nested <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C.D]]></span><it style="font-style: bold; color:green;">&#187;</it> could stay in position.
</p><p>

We can also rename <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['This]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example, with the code below we can make the original top level into a nested class, and the nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[NewTop]]></span><it style="font-style: bold; color:green;">&#187;</it> into the top level:
<pre class="l42Big"><![CDATA[
Res=Class:Trait({
  method S originalTop()=S"originalTop"
  NewTop ={method S newTop()=S"newTop"}
  })[single='This=>'OriginalTop;single='NewTop=>'This]
]]></pre>
</p><p>
On the other side, self rename, for example <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['C=>'C]]></span><it style="font-style: bold; color:green;">&#187;</it> is usually an error, and thus it will raise an exception. However, we can silence such errors and turn self rename into a no-op by using
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myCode[ignoreSelfRename='C=>'C]]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myCode[ignoreSelfRenameSingle='C=>'C]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

</p><h2> Hide </h2> <p>
The code below shows how to  hide a method or a class:
<pre class="l42Big"><![CDATA[
MultiConcrete2 = Class:MultiLevel[ hide='A; hide='D.space() ]
MultiConcrete2 = {//equivalent to just writing the following directly:
  A::3 = {
    class method S hi::4() = S"hi"
    B::5 = {class method S world::6() = S"world"}
    }
  C = {
    class method Void print() = Debug(A::3.hi::4()++D.space::7()++A:3.B::5.world::6())
    D = { class method S space::7() = S" " }
    }
  }
Main5 = MultiConcrete2.C.print() //still prints "hi world"
]]></pre>

Private members in 42 are obtained by relying on unique unguessable numbers:
These names do not show up in the outline and can not be invoked by user code; moreover those numbers are automatically renamed to avoid clashing during code composition; overall, those numbers are completely invisible for the user of the code.
While it is possible to manually use unique numbers, it is so much more convenient to write open code and then seal it later.

</p><h2> Clear </h2> <p>
Hidden code is still part of the result, but it is no more accessible.
Symmetrically, cleared code is not part of the result, but its entry point is still accessible, but abstract; clearing code allows us to override already defined behaviour, as shown below:

<pre class="l42Big"><![CDATA[
MultiConcrete3 = Class:MultiLevel[ clear='A ]:{
  A = {
    class method S hi() = S"hello"
    B = {class method S world() = S"42"}
    }
  }
Main6 = MultiConcrete3.C.print() //now prints "hello 42"
]]></pre>

Of course, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clearSingle='A]]></span><it style="font-style: bold; color:green;">&#187;</it> would clear only the nested class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A]]></span><it style="font-style: bold; color:green;">&#187;</it> and not also <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[A.B]]></span><it style="font-style: bold; color:green;">&#187;</it>.


</p><h2> Soft rename </h2> <p>
Clearing code allows us to override code by removing code.
This is different with respect to what happens with overriding in most languages, where the former code still exists and can be invoked, for example with <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[super]]></span><it style="font-style: bold; color:green;">&#187;</it>.

In 42 we can easily emulate super by using <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[->]]></span><it style="font-style: bold; color:green;">&#187;</it> instead of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear]]></span><it style="font-style: bold; color:green;">&#187;</it>; the code below shows how <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[->]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used on both methods and nested classes:
<pre class="l42Big"><![CDATA[
MultiConcrete4 = Class:MultiLevel[ 'A->'SuperA; 'C.D.space()->'C.D.superSpace() ]:{
  SuperA = { class method S hi() B={class method S world()}}
  A = {
    class method S hi() = S"[%SuperA.hi()]"
    B = {class method S world() = S"[%SuperA.B.world()]"}
    }
  C={
    D={
      class method S superSpace()
      class method S space()=S"[%this.superSpace()]"
      }
    }
  }
Main7 = MultiConcrete4.C.print() //now prints "[hi][ ][world]"
]]></pre>

Note how in this case we explicitly declare <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SuperA.hi()]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[SuperA.B.world()]]></span><it style="font-style: bold; color:green;">&#187;</it> and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[C.D.superSpace()]]></span><it style="font-style: bold; color:green;">&#187;</it> in the composed code, even if they are already present in the 
result of 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[MultiLevel[ 'A->'SuperA; 'C.D.space()->'C.D.superSpace() ]]]></span><it style="font-style: bold; color:green;">&#187;</it>.

We will soon show a way to avoid redeclaring them, but our experience programming in 42 suggests that when only a few methods are involved, the code is often more clear and easier to understand by redeclaring them.


</p><h2> Redirect </h2> <p>
Finally, programmatic refactoring allows us to rename a nested class into an externally declared class. We call this kind of rename <it style="font-style: italic;">redirect</it>.
This also provides a simple encoding for generics.
Consider the following code:
<pre class="l42Big"><![CDATA[
BoxTrait = Trait:Data:{
  T = {}//declaring a nested class called 'T'
  T that //a field of type T called 'that'
  }
NumBox = Class:BoxTrait['T=>Num]
Main = (
  myBox = NumBox(3Num)
  Debug(myBox)
  Num n = myBox.that()
  Debug(n)
  )
]]></pre>
Note how we wrote <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait['T=>Num]]]></span><it style="font-style: bold; color:green;">&#187;</it> and not <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait['T=>'Num]]]></span><it style="font-style: bold; color:green;">&#187;</it>:
In <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['T=>Num]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it> is the numeric class defined outside.
If we instead wrote <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['T=>'Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['Num]]></span><it style="font-style: bold; color:green;">&#187;</it> would be the class nested inside <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[BoxTrait]]></span><it style="font-style: bold; color:green;">&#187;</it> and called <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Num]]></span><it style="font-style: bold; color:green;">&#187;</it>.

Generics classes are straightforward to implement with redirect, and indeed
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Collection]]></span><it style="font-style: bold; color:green;">&#187;</it> uses the redirect operator internally.
</p><p>
We can redirect multiple nested classes at the same time, and we 
can put arbitrary constraints on the structural type of the destination types simply by specifying abstract methods and implemented interfaces.
Consider the following example:

<pre class="l42Big"><![CDATA[
Operation = Trait:{
  Elem = {Index myIndex}
  Index = {[HasToS]
    method Num eval(Elem that)
    }
  class method Elem best(Elem e1,Elem e2) = {
    res=e1.myIndex().eval(e2)>e2.myIndex().eval(e1)
    if res return e1
    return e2
    }
  }
Adventurer = Data:{S name, Num attack, Level level}
Level = Data:{
  Num exp
  S profession
  method Num eval(Adventurer that) = {..}
  }

DuelOperation = Class:Operation
  ['Elem.myIndex()=>'Elem.level()]
  ['Elem=>Adventurer;'Index=>Level]

Main= /*..*/ DuelOperation.best(e1=luke e2=gandalf) /*..*/
]]></pre>

Here we can define a generic <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Operation]]></span><it style="font-style: bold; color:green;">&#187;</it> working on <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Elem]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index]]></span><it style="font-style: bold; color:green;">&#187;</it>.
Elements must have an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index myIndex()]]></span><it style="font-style: bold; color:green;">&#187;</it> method and indexes must
implement <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[HasToS]]></span><it style="font-style: bold; color:green;">&#187;</it> and offer a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[method Num eval(Elem that)]]></span><it style="font-style: bold; color:green;">&#187;</it>.
In a language like Java with F-Bound polymorphism, we would have been required to rely on a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[HasEval<Elem>]]></span><it style="font-style: bold; color:green;">&#187;</it> interface, while in 42 we can simply list the required operations.

Note how  before specifing the actual types for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Elem]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Index]]></span><it style="font-style: bold; color:green;">&#187;</it> we can 
tweak the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Operation]]></span><it style="font-style: bold; color:green;">&#187;</it>, so that we can accept the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[level()]]></span><it style="font-style: bold; color:green;">&#187;</it> method instead of the
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[myIndex()]]></span><it style="font-style: bold; color:green;">&#187;</it> one.

Redirect is very powerful; checking also subtype relationships between redirected members, as shown below:
<pre class="l42Big"><![CDATA[
GeometryOperation = Trait:{
  Shape = {interface}
  Triangle = {[Shape]
    class method This (Point p1,Point p2,Point p3)
    }
  Line = {[Shape]
    Point p1, Point p2
    class method This (Point p1,Point p2)
    }
  class method Triangle reorganize(Line base,line extra) = 
    Triangle(p1=base.p1(), p2=base.p2(), p3=extra.p1())
  }
]]></pre>
Note how we can also require class methods on the redirect nested classes.
Overall, the whole philosophy of generic programming is different in 42:
instead of raising the level of abstraction and designing classes with type parameters,
we just design normal classes with nested classes, that just so happens to be fully abstract.
Those classes will represent external dependencies.
Then we can redirect those nested classes onto others.

</p><h2> (3/5) Different ways to supply missing dependencies </h2> <p>
As we have seen, in 42 it is convenient to write self contained code, where the dependencies 
can be specified as nested classes with abstract methods.
In 42 there are three different ways to satisfy those dependencies:
<ul>
<li>
Sum:
We can compose two traits with the operators <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[:]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[+]]></span><it style="font-style: bold; color:green;">&#187;</it> to provide some of the missing method implementations.
</li>
</ul>
<pre class="l42Big"><![CDATA[
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  })
+Trait({
  A = Data:{ I a }
  })
]]></pre>
<ul>
<li>
Redirect:
We can rename a class to an external one 
</li>
</ul>
<pre class="l42Big"><![CDATA[
Foo = Data:{ I a }
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  })['A=>Foo]
]]></pre>
<ul>
<li>
Rename:
We can rename a member to another member in the same unit of code:
</li>
</ul>
<pre class="l42Big"><![CDATA[
Trait({
  A = { method I a() }
  B = { method I b(A a)=a.a() }
  C = Data:{ I a }
  })['C=>'A]
]]></pre>

This last solution works like the sum, but is happening inside of the a single unit of code.
If this inner sum is successful, it behaves as trait composition would.
There are a few corner cases where this inner sum will fail; they involve details of composing classes with interfaces and adding methods to interfaces.


</p><h2> (4/5) Introspection and Info </h2> <p>
It is also possible to programmatically query the code structure and make decisions about it.
For example
<pre class="l42Big"><![CDATA[
Larger = {class method Trait (Trait t1, Trait t2)={
  if t1.info().methods().size()>t2.info().methods().size() return t1
  return t2
  }}
MyClass = Class:Larger(t1=ATrait, t2=AnotherTrait)
]]></pre>

The method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait.info()]]></span><it style="font-style: bold; color:green;">&#187;</it> returns an instance of class
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it>, offering methods to query all the visible information about
the trait code.
The class <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> represents a nested class, and also contains 
classes representing other kinds of code elements:
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Method]]></span><it style="font-style: bold; color:green;">&#187;</it>, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Type]]></span><it style="font-style: bold; color:green;">&#187;</it> and <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Doc]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> contains a lot of useful methods.
Some of those methods query information about the class and how it is used in its code unit: for example the method <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[watched()]]></span><it style="font-style: bold; color:green;">&#187;</it> returns the list of types whose private members are used.
<br/>
A class that is watched can not be cleared. Indeed, all the possible errors of programmatic refactoring can be predicted by relying on the methods of <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it>.
<br/>
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait({..}).info()]]></span><it style="font-style: bold; color:green;">&#187;</it> provides an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> for a library literal and
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info(..)]]></span><it style="font-style: bold; color:green;">&#187;</it> provides an <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> for a <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[class Any]]></span><it style="font-style: bold; color:green;">&#187;</it>.
For example, while 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Trait({ method S foo()}).info()]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to know about this <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[foo()]]></span><it style="font-style: bold; color:green;">&#187;</it> method, 
<it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info(S)]]></span><it style="font-style: bold; color:green;">&#187;</it> can be used to get information about the <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[S.size()]]></span><it style="font-style: bold; color:green;">&#187;</it> method.


</p><h2> (5/5)Programmatic refactoring summary </h2> <p>
<ul><li>
Many kinds of operations can be performed on code
</li><li>
Rename, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>'B]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.foo()=>'A.bar()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
is used to rename all the occurrences of a member into another name or
form, for the sake of the final user.
</li><li>
Soft Rename, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A->'B]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A.foo()->'A.bar()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
only moves the declaration. It leaves in place all the usages and an abstract version of the original signature.
</li><li>
Clear, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear='A]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[clear='A.foo()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
removes the implementation and all the private details of a member. It leaves in places all the usages and an abstract version of the original signature.
</li><li>
Hide, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hide='A]]></span><it style="font-style: bold; color:green;">&#187;</it> or <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[hide='A.foo()]]></span><it style="font-style: bold; color:green;">&#187;</it>,
renames all the occurrences of a member into an uniquely named one.
This new name is now completely invisible from outside the code unit.
</li><li>
Redirect, as for <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA['A=>Num]]></span><it style="font-style: bold; color:green;">&#187;</it>,
redirects all the usages of a nested class into an externally declared one.
The internal declaration is simply trashed.
</li></ul>
Finally, <it style="font-style: bold; color:green;">&#171;</it><span class="code"><![CDATA[Info]]></span><it style="font-style: bold; color:green;">&#187;</it> allows us to explore the shape of code as metadata.


<br/>
<div class="index"><div class="wrapFloat"><div class="inFloat">
</div><div class="inFloat">
&nbsp; &nbsp; &nbsp; <a href="tutorial_11MetaprogrammingIntro.xhtml"> Previous </a>...<a href="tutorial_13MoreDecorators.xhtml"> Next </a>
</div></div><div class="finishFloat"></div></div>
<br/>

        </p>
        </div>
      </div>
      <div id="footerwrap">
        <div id="footer">
          <ul style='padding: 10px;'>
            <li style='display:inline;'>
            <a href="mailto:marco.servetto@gmail.com" rel="me">Contact Us</a> |</li>
            <li style='display:inline;'>
            <a href= "http://ecs.victoria.ac.nz/mailman/listinfo/team42">Mailing list</a> |</li>
          </ul>
        </div>
      </div>
    </div>

	
  </body>
</html>

